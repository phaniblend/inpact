{
  "id": "search-rotated-sorted-array",
  "title": "Search in Rotated Sorted Array",
  "difficulty": "medium",
  "pattern": "binary-search-variant",
  "language": "javascript",
  "quality": "PERFECT",
  "version": "v1.0-fixed",
  "flow": [
    {
      "stepId": "problem-statement",
      "mentorSays": "You are given a list of **distinct numbers** that was originally sorted in ascending order.\n\nAt some unknown point, the list was **rotated**.\n\nYou are also given a target number.\n\nYour task is to return the **index of the target**, or -1 if it does not exist.",
      "example": "Input: nums = [4,5,6,7,0,1,2], target = 0",
      "action": "next"
    },
    {
      "stepId": "what-rotated-means",
      "mentorSays": "What does **rotated** mean?\n\nTake a sorted list:\n[0,1,2,4,5,6,7]\n\nRotate it at some point:\n[4,5,6,7,0,1,2]\n\nNotice:\n• The list is no longer fully sorted\n• But **each half is still sorted**",
      "action": "next"
    },
    {
      "stepId": "tiny-example",
      "mentorSays": "Tiny example:\n\nOriginal: [1,2,3,4]\nRotated:  [3,4,1,2]\n\nBoth halves:\n• [3,4]\n• [1,2]\nare sorted.",
      "action": "next"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Pause and think.\n\nIf the list was fully sorted, we would use binary search.\n\nBut now it is rotated.\n\nWhat property can we still rely on?",
      "choices": [
        {
          "label": "At least one half is always sorted",
          "next": "key-observation"
        },
        {
          "label": "The entire list is random",
          "next": "key-observation"
        }
      ]
    },
    {
      "stepId": "key-observation",
      "mentorSays": "Correct.\n\nAt **any point**, one of the two halves is guaranteed to be sorted.\n\nThat single fact allows us to keep using binary search logic.",
      "action": "next"
    },
    {
      "stepId": "decision-logic",
      "mentorSays": "At each step:\n\n• Pick a middle index\n• Decide which half is sorted\n• Check if the target lies inside that sorted half\n• Narrow the search range accordingly",
      "action": "next"
    },
    {
      "stepId": "how-to-detect-sorted-half",
      "mentorSays": "How do we know which half is sorted?\n\nIf:\nnums[left] ≤ nums[mid]\n\nThen the **left half is sorted**.\n\nOtherwise, the **right half is sorted**.",
      "action": "next"
    },
    {
      "stepId": "tiny-walkthrough",
      "mentorSays": "Example:\nnums = [4,5,6,7,0,1,2], target = 0\n\nleft = 0, right = 6\nmid = 3 → nums[mid] = 7\n\nLeft half [4,5,6,7] is sorted.\nTarget 0 is not in this range.\n\nSo we search the right half.",
      "action": "next"
    },
    {
      "stepId": "logic-summary",
      "mentorSays": "Repeat this process:\n\n• Identify sorted half\n• Check target range\n• Move left or right pointers\n\nEach step cuts the search space in half.",
      "action": "next"
    },
    {
      "stepId": "pseudocode",
      "mentorSays": "Let’s write the steps clearly.\n\nNo JavaScript yet.",
      "pseudocode": [
        "set left = 0, right = length - 1",
        "while left <= right:",
        "  mid = floor((left + right) / 2)",
        "  if nums[mid] == target, return mid",
        "  if left half is sorted:",
        "    if target in left half range:",
        "      move right to mid - 1",
        "    else:",
        "      move left to mid + 1",
        "  else:",
        "    if target in right half range:",
        "      move left to mid + 1",
        "    else:",
        "      move right to mid - 1",
        "return -1"
      ],
      "action": "next"
    },
    {
      "stepId": "coding-js",
      "mentorSays": "Now translate the logic into JavaScript.",
      "code": "function search(nums, target) {\n  let left = 0;\n  let right = nums.length - 1;\n\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n\n    if (nums[mid] === target) return mid;\n\n    if (nums[left] <= nums[mid]) {\n      if (nums[left] <= target && target < nums[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    } else {\n      if (nums[mid] < target && target <= nums[right]) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n  }\n\n  return -1;\n}",
      "action": "next"
    },
    {
      "stepId": "final-check",
      "mentorSays": "Final checks:\n\n[4,5,6,7,0,1,2], target=0 → index 4\n[4,5,6,7,0,1,2], target=3 → -1\n\nWorks correctly in all cases.",
      "action": "complete"
    }
  ]
}
