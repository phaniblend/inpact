{
  "id": "fibonacci-dp",
  "title": "Fibonacci with DP",
  "pattern": "dynamic-programming",
  "difficulty": "easy",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what the Fibonacci sequence is\n2. Use dynamic programming to compute Fibonacci numbers efficiently\n3. Build the solution by storing previously computed values\n4. Implement the solution step by step in your chosen language",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Fibonacci is the classic introduction to Dynamic Programming!\n\nPROBLEM:\nCalculate F(n) where:\nF(0) = 0\nF(1) = 1\nF(n) = F(n-1) + F(n-2)\n\nExample: F(6) = ?\nF(0) = 0\nF(1) = 1\nF(2) = 1\nF(3) = 2\nF(4) = 3\nF(5) = 5\nF(6) = 8\n\nAPPROACH 1: Naive Recursion (SLOW!)\nfunction fib(n) {\n  if (n <= 1) return n;\n  return fib(n-1) + fib(n-2);\n}\n\nRECURSION TREE for F(6):\n                F(6)\n              /      \\\n          F(5)        F(4)\n         /    \\      /    \\\n     F(4)   F(3)  F(3)   F(2)\n     / \\     / \\   / \\    / \\\n  F(3) F(2)...\n\nNotice: F(3) is calculated 3 times!\n        F(4) is calculated 2 times!\n\nTIME: O(2^n) - EXPONENTIAL! Very slow!\n\nAPPROACH 2: Memoization (Top-Down DP)\nlet memo = {};\nfunction fib(n) {\n  if (n <= 1) return n;\n  if (memo[n]) return memo[n];\n  memo[n] = fib(n-1) + fib(n-2);\n  return memo[n];\n}\n\nNow each F(i) is calculated only once!\nTIME: O(n) - LINEAR! Much faster!\n\nAPPROACH 3: Tabulation (Bottom-Up DP)\nfunction fib(n) {\n  let dp = [0, 1];\n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i-1] + dp[i-2];\n  }\n  return dp[n];\n}\n\nTIME: O(n)\nSPACE: O(n)\n\nAPPROACH 4: Space Optimized\nfunction fib(n) {\n  if (n <= 1) return n;\n  let prev2 = 0, prev1 = 1;\n  for (let i = 2; i <= n; i++) {\n    let current = prev1 + prev2;\n    prev2 = prev1;\n    prev1 = current;\n  }\n  return prev1;\n}\n\nTIME: O(n)\nSPACE: O(1) - Optimal!\n\nCOMPARISON:\nn=10:  Recursive calls\nNaive:     177\nMemo:       19\nTabulation: 10\nOptimized:  10\n\nThis shows the power of DP!",
      "example": "n = 6\n\nFind F(6):\nF(0) = 0\nF(1) = 1\nF(2) = 1\nF(3) = 2\nF(4) = 3\nF(5) = 5\nF(6) = 8 âœ“\n\nAnswer: 8\n\nAnother example:\nn = 10\n\nAnswer: 55\n\nAnother example:\nn = 0\n\nAnswer: 0",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Now that you understand what the problem wants, here's the real question:\n\nHow would YOU compute the nth Fibonacci number?\n\nThink about it for a moment. What approach feels natural to you?",
      "choices": [
        {
          "label": "Use dynamic programming to store and reuse computed values",
          "next": "explore-dp"
        },
        {
          "label": "Use recursion to compute F(n) = F(n-1) + F(n-2)",
          "next": "explore-recursion"
        },
        {
          "label": "Use a mathematical formula (Binet's formula)",
          "next": "explore-math"
        }
      ]
    },
    {
      "stepId": "explore-recursion",
      "mentorSays": "That's a straightforward approach! You're thinking: \"I'll use recursion: F(n) = F(n-1) + F(n-2) with base cases F(0) = 0 and F(1) = 1.\"\n\nThis works! However, it's exponential time complexity because we recalculate the same values many times.\n\nFor example, to compute F(5):\n- F(5) calls F(4) and F(3)\n- F(4) calls F(3) and F(2)\n- F(3) calls F(2) and F(1)\n- F(2) is computed multiple times!\n\nWould you like to learn the dynamic programming approach which is O(n) time?",
      "action": "continue",
      "next": "explore-dp"
    },
    {
      "stepId": "explore-math",
      "mentorSays": "Great thinking! Binet's formula can compute Fibonacci numbers directly, but it involves floating-point arithmetic and may have precision issues for large n.\n\nFor learning purposes, let's use dynamic programming which is more intuitive and builds problem-solving skills!\n\nLet's learn the DP approach!",
      "action": "continue",
      "next": "explore-dp"
    },
    {
      "stepId": "explore-dp",
      "mentorSays": "Excellent choice! Dynamic programming is efficient and intuitive. Here's the core idea:\n\n1. **DP Array**: dp[i] = F(i) (the ith Fibonacci number)\n2. **Base Cases**:\n   - dp[0] = 0\n   - dp[1] = 1\n3. **Recurrence**: For i >= 2:\n   - dp[i] = dp[i-1] + dp[i-2]\n   - (each number is the sum of the two preceding ones)\n4. **Result**: dp[n]\n\nLet's trace with n = 6:\n\n- **dp[0] = 0** (base case)\n- **dp[1] = 1** (base case)\n- **dp[2] = 1 + 0 = 1**\n- **dp[3] = 1 + 1 = 2**\n- **dp[4] = 2 + 1 = 3**\n- **dp[5] = 3 + 2 = 5**\n- **dp[6] = 5 + 3 = 8** âœ“\n\nAnswer: 8\n\nThis is O(n) time and O(n) space! We can optimize to O(1) space by only keeping the last two values. Now let's code it step by step.",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Great! Now let's code this solution. Which programming language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "variable-check-js"
        },
        {
          "label": "Python",
          "next": "variable-check-python"
        },
        {
          "label": "Java",
          "next": "variable-check-java"
        },
        {
          "label": "C++",
          "next": "variable-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "variable-check-ts"
        }
      ]
    },
    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-js"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-js"
        }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'dp' or 'fib') and put data inside it.\n\nFor example, 'let dp = [];' creates a variable that stores an empty array.",
      "example": "let dp = [];\n\nNow the variable refers to an empty array",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "array-check-js"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-js"
        }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function add(a, b) {\n  return a + b;\n}\n\nadd(3, 5) returns 8",
      "action": "continue",
      "next": "array-check-js"
    },
    {
      "stepId": "array-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what an array is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know arrays",
          "next": "recursion-vs-dp-check-js"
        },
        {
          "label": "No, explain arrays",
          "next": "array-explanation-js"
        }
      ]
    },
    {
      "stepId": "recursion-vs-dp-check-js",
      "mentorSays": "Do you understand the difference between naive recursion and DP?",
      "choices": [
        {
          "label": "Yes, I know recursion-vs-dp",
          "next": "memoization-check-js"
        },
        {
          "label": "No, explain recursion-vs-dp",
          "next": "recursion-vs-dp-explanation-js"
        }
      ]
    },
    {
      "stepId": "memoization-check-js",
      "mentorSays": "Do you understand memoization (top-down DP)?",
      "choices": [
        {
          "label": "Yes, I know memoization",
          "next": "coding-start-js"
        },
        {
          "label": "No, explain memoization",
          "next": "memoization-explanation-js"
        }
      ]
    },
    {
      "stepId": "memoization-explanation-js",
      "mentorSays": "Memoization caches the results of recursive calls. When we compute fib(n), we store it in a memo object. If we need fib(n) again, we return the cached value instead of recalculating. This transforms exponential time to linear time!\n\n// Memoization: cache recursive results\nlet memo = {};\n\nfunction fib(n) {\n  if (n <= 1) return n;\n  if (memo[n]) return memo[n];  // Return cached result\n  memo[n] = fib(n-1) + fib(n-2);  // Store result\n  return memo[n];\n}\n\nGot it?",
      "example": "// Memoization: cache recursive results\nlet memo = {};\n\nfunction fib(n) {\n  if (n <= 1) return n;\n  if (memo[n]) return memo[n];  // Return cached result\n  memo[n] = fib(n-1) + fib(n-2);  // Store result\n  return memo[n];\n}",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "recursion-vs-dp-explanation-js",
      "mentorSays": "Naive recursion recalculates the same subproblems many times, leading to exponential time O(2^n). DP solves each subproblem once and reuses the result, leading to linear time O(n). This is the key benefit of dynamic programming!\n\n// Naive recursion: O(2^n)\nfunction fib(n) {\n  if (n <= 1) return n;\n  return fib(n-1) + fib(n-2);  // Recalculates same values!\n}\n\n// DP: O(n)\nlet dp = [0, 1];\nfor (let i = 2; i <= n; i++) {\n  dp[i] = dp[i-1] + dp[i-2];  // Each value calculated once!\n}\n\nGot it?",
      "example": "// Naive recursion: O(2^n)\nfunction fib(n) {\n  if (n <= 1) return n;\n  return fib(n-1) + fib(n-2);  // Recalculates same values!\n}\n\n// DP: O(n)\nlet dp = [0, 1];\nfor (let i = 2; i <= n; i++) {\n  dp[i] = dp[i-1] + dp[i-2];  // Each value calculated once!\n}",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "array-explanation-js",
      "mentorSays": "An array is like a list of items that keeps them in order. Each item has a position number called an 'index'. Array indices start counting from 0.",
      "example": "arr = [1, 2, 3]\n\narr[0] = 1\narr[1] = 2\narr[2] = 3",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Perfect! Let's implement Fibonacci using dynamic programming in JavaScript.",
      "example": "function fib(n) {\n  // Your code here\n}",
      "action": "continue",
      "next": "coding-base-js"
    },
    {
      "stepId": "coding-base-js",
      "mentorSays": "First, handle edge cases: if n is 0, return 0. If n is 1, return 1.",
      "example": "function fib(n) {\n  if (n === 0) return 0;\n  if (n === 1) return 1;",
      "action": "continue",
      "next": "coding-init-js"
    },
    {
      "stepId": "coding-init-js",
      "mentorSays": "Now, create a DP array to store Fibonacci numbers. Initialize base cases: dp[0] = 0, dp[1] = 1.",
      "example": "function fib(n) {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  \n  const dp = new Array(n + 1);\n  dp[0] = 0;\n  dp[1] = 1;",
      "action": "continue",
      "next": "coding-fill-js"
    },
    {
      "stepId": "coding-fill-js",
      "mentorSays": "Now, fill the DP array: for each i from 2 to n, compute dp[i] = dp[i-1] + dp[i-2].",
      "example": "function fib(n) {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  \n  const dp = new Array(n + 1);\n  dp[0] = 0;\n  dp[1] = 1;\n  \n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i-1] + dp[i-2];\n  }",
      "action": "continue",
      "next": "coding-memoization-js"
    },
    {
      "stepId": "coding-memoization-js",
      "mentorSays": "Let's add memoization to the recursive solution.\n\nWe create a memo object to cache results:\n- Before computing fib(n), check if memo[n] exists\n- If yes, return cached value\n- If no, compute it, store in memo, then return\n\nThis transforms O(2^n) to O(n) time!",
      "example": "let memo = {};\n\nfunction fib(n) {\n  if (n <= 1) return n;\n  if (memo[n]) return memo[n];  // Return cached\n  memo[n] = fib(n-1) + fib(n-2);  // Store result\n  return memo[n];\n}",
      "action": "continue",
      "next": "coding-space-optimization-js"
    },
    {
      "stepId": "coding-space-optimization-js",
      "mentorSays": "We can optimize space from O(n) to O(1).\n\nNotice: we only need the previous 2 values!\n\nInstead of storing all values:\nlet dp = [0, 1, 1, 2, 3, 5, 8]\n\nWe can use just two variables:\nlet prev2 = 0, prev1 = 1;\n\nSpace: O(n) â†’ O(1)\nTime: still O(n)",
      "example": "// Space optimized version:\nif (n <= 1) return n;\nlet prev2 = 0, prev1 = 1;\nfor (let i = 2; i <= n; i++) {\n  let current = prev1 + prev2;\n  prev2 = prev1;\n  prev1 = current;\n}\nreturn prev1;",
      "action": "continue",
      "next": "coding-return-js"
    },
    {
      "stepId": "coding-return-js",
      "mentorSays": "Finally, return dp[n], which contains the nth Fibonacci number.",
      "example": "function fib(n) {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  \n  const dp = new Array(n + 1);\n  dp[0] = 0;\n  dp[1] = 1;\n  \n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i-1] + dp[i-2];\n  }\n  \n  return dp[n];\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nn = 6\n\nAfter calling fib(6), it should return:\n8\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nn = 6\n\nAfter fib(6):\n8",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Python?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-python"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-python"
        }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'dp' or 'fib') and put data inside it.\n\nFor example, 'dp = []' creates a variable that stores an empty list.",
      "example": "dp = []\n\nNow the variable refers to an empty list",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Python?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "array-check-python"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-python"
        }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "def add(a, b):\n    return a + b\n\nadd(3, 5) returns 8",
      "action": "continue",
      "next": "array-check-python"
    },
    {
      "stepId": "array-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a list is in Python?",
      "choices": [
        {
          "label": "Yes, I know lists",
          "next": "recursion-vs-dp-check-python"
        },
        {
          "label": "No, explain lists",
          "next": "array-explanation-python"
        }
      ]
    },
    {
      "stepId": "recursion-vs-dp-check-python",
      "mentorSays": "Do you understand the difference between naive recursion and DP?",
      "choices": [
        {
          "label": "Yes, I know recursion-vs-dp",
          "next": "memoization-check-python"
        },
        {
          "label": "No, explain recursion-vs-dp",
          "next": "recursion-vs-dp-explanation-python"
        }
      ]
    },
    {
      "stepId": "memoization-check-python",
      "mentorSays": "Do you understand memoization (top-down DP)?",
      "choices": [
        {
          "label": "Yes, I know memoization",
          "next": "coding-start-python"
        },
        {
          "label": "No, explain memoization",
          "next": "memoization-explanation-python"
        }
      ]
    },
    {
      "stepId": "memoization-explanation-python",
      "mentorSays": "Memoization caches the results of recursive calls. When we compute fib(n), we store it in a memo object. If we need fib(n) again, we return the cached value instead of recalculating. This transforms exponential time to linear time!\n\n# Memoization: cache recursive results\nmemo = {}\n\ndef fib(n):\n    if n <= 1:\n        return n\n    if n in memo:\n        return memo[n]  # Return cached result\n    memo[n] = fib(n-1) + fib(n-2)  # Store result\n    return memo[n]\n\nGot it?",
      "example": "# Memoization: cache recursive results\nmemo = {}\n\ndef fib(n):\n    if n <= 1:\n        return n\n    if n in memo:\n        return memo[n]  # Return cached result\n    memo[n] = fib(n-1) + fib(n-2)  # Store result\n    return memo[n]",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "recursion-vs-dp-explanation-python",
      "mentorSays": "Naive recursion recalculates the same subproblems many times, leading to exponential time O(2^n). DP solves each subproblem once and reuses the result, leading to linear time O(n). This is the key benefit of dynamic programming!\n\n# Naive recursion: O(2^n)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)  # Recalculates same values!\n\n# DP: O(n)\ndp = [0, 1]\nfor i in range(2, n + 1):\n    dp[i] = dp[i-1] + dp[i-2]  # Each value calculated once!\n\nGot it?",
      "example": "# Naive recursion: O(2^n)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)  # Recalculates same values!\n\n# DP: O(n)\ndp = [0, 1]\nfor i in range(2, n + 1):\n    dp[i] = dp[i-1] + dp[i-2]  # Each value calculated once!",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "array-explanation-python",
      "mentorSays": "A list is like an array - a collection of items that keeps them in order. Each item has a position number called an 'index'. List indices start counting from 0.",
      "example": "arr = [1, 2, 3]\n\narr[0] = 1\narr[1] = 2\narr[2] = 3",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Perfect! Let's implement Fibonacci using dynamic programming in Python.",
      "example": "def fib(n):\n    # Your code here\n    pass",
      "action": "continue",
      "next": "coding-base-python"
    },
    {
      "stepId": "coding-base-python",
      "mentorSays": "First, handle edge cases: if n is 0, return 0. If n is 1, return 1.",
      "example": "def fib(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1",
      "action": "continue",
      "next": "coding-init-python"
    },
    {
      "stepId": "coding-init-python",
      "mentorSays": "Now, create a DP list to store Fibonacci numbers. Initialize base cases: dp[0] = 0, dp[1] = 1.",
      "example": "def fib(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 0\n    dp[1] = 1",
      "action": "continue",
      "next": "coding-fill-python"
    },
    {
      "stepId": "coding-fill-python",
      "mentorSays": "Now, fill the DP list: for each i from 2 to n, compute dp[i] = dp[i-1] + dp[i-2].",
      "example": "def fib(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 0\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]",
      "action": "continue",
      "next": "coding-memoization-python"
    },
    {
      "stepId": "coding-memoization-python",
      "mentorSays": "Let's add memoization to the recursive solution.\n\nWe create a memo object to cache results:\n- Before computing fib(n), check if memo[n] exists\n- If yes, return cached value\n- If no, compute it, store in memo, then return\n\nThis transforms O(2^n) to O(n) time!",
      "example": "let memo = {};\n\nfunction fib(n) {\n  if (n <= 1) return n;\n  if (memo[n]) return memo[n];  // Return cached\n  memo[n] = fib(n-1) + fib(n-2);  // Store result\n  return memo[n];\n}",
      "action": "continue",
      "next": "coding-space-optimization-python"
    },
    {
      "stepId": "coding-space-optimization-python",
      "mentorSays": "We can optimize space from O(n) to O(1).\n\nNotice: we only need the previous 2 values!\n\nInstead of storing all values:\nlet dp = [0, 1, 1, 2, 3, 5, 8]\n\nWe can use just two variables:\nlet prev2 = 0, prev1 = 1;\n\nSpace: O(n) â†’ O(1)\nTime: still O(n)",
      "example": "// Space optimized version:\nif (n <= 1) return n;\nlet prev2 = 0, prev1 = 1;\nfor (let i = 2; i <= n; i++) {\n  let current = prev1 + prev2;\n  prev2 = prev1;\n  prev1 = current;\n}\nreturn prev1;",
      "action": "continue",
      "next": "coding-return-python"
    },
    {
      "stepId": "coding-return-python",
      "mentorSays": "Finally, return dp[n], which contains the nth Fibonacci number.",
      "example": "def fib(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 0\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nn = 6\n\nAfter calling fib(6), it should return:\n8\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nn = 6\n\nAfter fib(6):\n8",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Java?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-java"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-java"
        }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'dp' or 'fib') and put data inside it.\n\nFor example, 'int[] dp = new int[n + 1];' creates a variable that stores an array.",
      "example": "int[] dp = new int[n + 1];\n\nNow the variable refers to an array",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a method is in Java?",
      "choices": [
        {
          "label": "Yes, I know methods",
          "next": "array-check-java"
        },
        {
          "label": "No, explain methods",
          "next": "function-explanation-java"
        }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A method is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "public int add(int a, int b) {\n    return a + b;\n}\n\nadd(3, 5) returns 8",
      "action": "continue",
      "next": "array-check-java"
    },
    {
      "stepId": "array-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what an array is in Java?",
      "choices": [
        {
          "label": "Yes, I know arrays",
          "next": "recursion-vs-dp-check-java"
        },
        {
          "label": "No, explain arrays",
          "next": "array-explanation-java"
        }
      ]
    },
    {
      "stepId": "recursion-vs-dp-check-java",
      "mentorSays": "Do you understand the difference between naive recursion and DP?",
      "choices": [
        {
          "label": "Yes, I know recursion-vs-dp",
          "next": "memoization-check-java"
        },
        {
          "label": "No, explain recursion-vs-dp",
          "next": "recursion-vs-dp-explanation-java"
        }
      ]
    },
    {
      "stepId": "memoization-check-java",
      "mentorSays": "Do you understand memoization (top-down DP)?",
      "choices": [
        {
          "label": "Yes, I know memoization",
          "next": "coding-start-java"
        },
        {
          "label": "No, explain memoization",
          "next": "memoization-explanation-java"
        }
      ]
    },
    {
      "stepId": "memoization-explanation-java",
      "mentorSays": "Memoization caches the results of recursive calls. When we compute fib(n), we store it in a memo object. If we need fib(n) again, we return the cached value instead of recalculating. This transforms exponential time to linear time!\n\n// Memoization: cache recursive results\nMap<Integer, Integer> memo = new HashMap<>();\n\nint fib(int n) {\n    if (n <= 1) return n;\n    if (memo.containsKey(n)) return memo.get(n);\n    memo.put(n, fib(n-1) + fib(n-2));\n    return memo.get(n);\n}\n\nGot it?",
      "example": "// Memoization: cache recursive results\nMap<Integer, Integer> memo = new HashMap<>();\n\nint fib(int n) {\n    if (n <= 1) return n;\n    if (memo.containsKey(n)) return memo.get(n);\n    memo.put(n, fib(n-1) + fib(n-2));\n    return memo.get(n);\n}",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "recursion-vs-dp-explanation-java",
      "mentorSays": "Naive recursion recalculates the same subproblems many times, leading to exponential time O(2^n). DP solves each subproblem once and reuses the result, leading to linear time O(n). This is the key benefit of dynamic programming!\n\n// Naive recursion: O(2^n)\nint fib(int n) {\n    if (n <= 1) return n;\n    return fib(n-1) + fib(n-2);  // Recalculates same values!\n}\n\n// DP: O(n)\nint[] dp = new int[n + 1];\ndp[0] = 0; dp[1] = 1;\nfor (int i = 2; i <= n; i++) {\n    dp[i] = dp[i-1] + dp[i-2];  // Each value calculated once!\n}\n\nGot it?",
      "example": "// Naive recursion: O(2^n)\nint fib(int n) {\n    if (n <= 1) return n;\n    return fib(n-1) + fib(n-2);  // Recalculates same values!\n}\n\n// DP: O(n)\nint[] dp = new int[n + 1];\ndp[0] = 0; dp[1] = 1;\nfor (int i = 2; i <= n; i++) {\n    dp[i] = dp[i-1] + dp[i-2];  // Each value calculated once!\n}",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "array-explanation-java",
      "mentorSays": "An array is like a list of items that keeps them in order. Each item has a position number called an 'index'. Array indices start counting from 0.",
      "example": "int[] arr = {1, 2, 3};\n\narr[0] = 1\narr[1] = 2\narr[2] = 3",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Perfect! Let's implement Fibonacci using dynamic programming in Java.",
      "example": "public int fib(int n) {\n    // Your code here\n}",
      "action": "continue",
      "next": "coding-base-java"
    },
    {
      "stepId": "coding-base-java",
      "mentorSays": "First, handle edge cases: if n is 0, return 0. If n is 1, return 1.",
      "example": "public int fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;",
      "action": "continue",
      "next": "coding-init-java"
    },
    {
      "stepId": "coding-init-java",
      "mentorSays": "Now, create a DP array to store Fibonacci numbers. Initialize base cases: dp[0] = 0, dp[1] = 1.",
      "example": "public int fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    \n    int[] dp = new int[n + 1];\n    dp[0] = 0;\n    dp[1] = 1;",
      "action": "continue",
      "next": "coding-fill-java"
    },
    {
      "stepId": "coding-fill-java",
      "mentorSays": "Now, fill the DP array: for each i from 2 to n, compute dp[i] = dp[i-1] + dp[i-2].",
      "example": "public int fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    \n    int[] dp = new int[n + 1];\n    dp[0] = 0;\n    dp[1] = 1;\n    \n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i-1] + dp[i-2];\n    }",
      "action": "continue",
      "next": "coding-memoization-java"
    },
    {
      "stepId": "coding-memoization-java",
      "mentorSays": "Let's add memoization to the recursive solution.\n\nWe create a memo object to cache results:\n- Before computing fib(n), check if memo[n] exists\n- If yes, return cached value\n- If no, compute it, store in memo, then return\n\nThis transforms O(2^n) to O(n) time!",
      "example": "let memo = {};\n\nfunction fib(n) {\n  if (n <= 1) return n;\n  if (memo[n]) return memo[n];  // Return cached\n  memo[n] = fib(n-1) + fib(n-2);  // Store result\n  return memo[n];\n}",
      "action": "continue",
      "next": "coding-space-optimization-java"
    },
    {
      "stepId": "coding-space-optimization-java",
      "mentorSays": "We can optimize space from O(n) to O(1).\n\nNotice: we only need the previous 2 values!\n\nInstead of storing all values:\nlet dp = [0, 1, 1, 2, 3, 5, 8]\n\nWe can use just two variables:\nlet prev2 = 0, prev1 = 1;\n\nSpace: O(n) â†’ O(1)\nTime: still O(n)",
      "example": "// Space optimized version:\nif (n <= 1) return n;\nlet prev2 = 0, prev1 = 1;\nfor (let i = 2; i <= n; i++) {\n  let current = prev1 + prev2;\n  prev2 = prev1;\n  prev1 = current;\n}\nreturn prev1;",
      "action": "continue",
      "next": "coding-return-java"
    },
    {
      "stepId": "coding-return-java",
      "mentorSays": "Finally, return dp[n], which contains the nth Fibonacci number.",
      "example": "public int fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    \n    int[] dp = new int[n + 1];\n    dp[0] = 0;\n    dp[1] = 1;\n    \n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i-1] + dp[i-2];\n    }\n    \n    return dp[n];\n}",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nn = 6\n\nAfter calling fib(6), it should return:\n8\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nn = 6\n\nAfter fib(6):\n8",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in C++?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-cpp"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'dp' or 'fib') and put data inside it.\n\nFor example, 'vector<int> dp(n + 1);' creates a variable that stores a vector.",
      "example": "vector<int> dp(n + 1);\n\nNow the variable refers to a vector",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in C++?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "array-check-cpp"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "int add(int a, int b) {\n    return a + b;\n}\n\nadd(3, 5) returns 8",
      "action": "continue",
      "next": "array-check-cpp"
    },
    {
      "stepId": "array-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a vector is in C++?",
      "choices": [
        {
          "label": "Yes, I know vectors",
          "next": "recursion-vs-dp-check-cpp"
        },
        {
          "label": "No, explain vectors",
          "next": "array-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "recursion-vs-dp-check-cpp",
      "mentorSays": "Do you understand the difference between naive recursion and DP?",
      "choices": [
        {
          "label": "Yes, I know recursion-vs-dp",
          "next": "memoization-check-cpp"
        },
        {
          "label": "No, explain recursion-vs-dp",
          "next": "recursion-vs-dp-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "memoization-check-cpp",
      "mentorSays": "Do you understand memoization (top-down DP)?",
      "choices": [
        {
          "label": "Yes, I know memoization",
          "next": "coding-start-cpp"
        },
        {
          "label": "No, explain memoization",
          "next": "memoization-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "memoization-explanation-cpp",
      "mentorSays": "Memoization caches the results of recursive calls. When we compute fib(n), we store it in a memo object. If we need fib(n) again, we return the cached value instead of recalculating. This transforms exponential time to linear time!\n\n// Memoization: cache recursive results\nunordered_map<int, int> memo;\n\nint fib(int n) {\n    if (n <= 1) return n;\n    if (memo.find(n) != memo.end()) return memo[n];\n    memo[n] = fib(n-1) + fib(n-2);\n    return memo[n];\n}\n\nGot it?",
      "example": "// Memoization: cache recursive results\nunordered_map<int, int> memo;\n\nint fib(int n) {\n    if (n <= 1) return n;\n    if (memo.find(n) != memo.end()) return memo[n];\n    memo[n] = fib(n-1) + fib(n-2);\n    return memo[n];\n}",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "recursion-vs-dp-explanation-cpp",
      "mentorSays": "Naive recursion recalculates the same subproblems many times, leading to exponential time O(2^n). DP solves each subproblem once and reuses the result, leading to linear time O(n). This is the key benefit of dynamic programming!\n\n// Naive recursion: O(2^n)\nint fib(int n) {\n    if (n <= 1) return n;\n    return fib(n-1) + fib(n-2);  // Recalculates same values!\n}\n\n// DP: O(n)\nvector<int> dp(n + 1);\ndp[0] = 0; dp[1] = 1;\nfor (int i = 2; i <= n; i++) {\n    dp[i] = dp[i-1] + dp[i-2];  // Each value calculated once!\n}\n\nGot it?",
      "example": "// Naive recursion: O(2^n)\nint fib(int n) {\n    if (n <= 1) return n;\n    return fib(n-1) + fib(n-2);  // Recalculates same values!\n}\n\n// DP: O(n)\nvector<int> dp(n + 1);\ndp[0] = 0; dp[1] = 1;\nfor (int i = 2; i <= n; i++) {\n    dp[i] = dp[i-1] + dp[i-2];  // Each value calculated once!\n}",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "array-explanation-cpp",
      "mentorSays": "A vector is like an array - a collection of items that keeps them in order. Each item has a position number called an 'index'. Vector indices start counting from 0.",
      "example": "vector<int> arr = {1, 2, 3};\n\narr[0] = 1\narr[1] = 2\narr[2] = 3",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Perfect! Let's implement Fibonacci using dynamic programming in C++.",
      "example": "int fib(int n) {\n    // Your code here\n}",
      "action": "continue",
      "next": "coding-base-cpp"
    },
    {
      "stepId": "coding-base-cpp",
      "mentorSays": "First, handle edge cases: if n is 0, return 0. If n is 1, return 1.",
      "example": "int fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;",
      "action": "continue",
      "next": "coding-init-cpp"
    },
    {
      "stepId": "coding-init-cpp",
      "mentorSays": "Now, create a DP vector to store Fibonacci numbers. Initialize base cases: dp[0] = 0, dp[1] = 1.",
      "example": "int fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    \n    vector<int> dp(n + 1);\n    dp[0] = 0;\n    dp[1] = 1;",
      "action": "continue",
      "next": "coding-fill-cpp"
    },
    {
      "stepId": "coding-fill-cpp",
      "mentorSays": "Now, fill the DP vector: for each i from 2 to n, compute dp[i] = dp[i-1] + dp[i-2].",
      "example": "int fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    \n    vector<int> dp(n + 1);\n    dp[0] = 0;\n    dp[1] = 1;\n    \n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i-1] + dp[i-2];\n    }",
      "action": "continue",
      "next": "coding-memoization-cpp"
    },
    {
      "stepId": "coding-memoization-cpp",
      "mentorSays": "Let's add memoization to the recursive solution.\n\nWe create a memo object to cache results:\n- Before computing fib(n), check if memo[n] exists\n- If yes, return cached value\n- If no, compute it, store in memo, then return\n\nThis transforms O(2^n) to O(n) time!",
      "example": "let memo = {};\n\nfunction fib(n) {\n  if (n <= 1) return n;\n  if (memo[n]) return memo[n];  // Return cached\n  memo[n] = fib(n-1) + fib(n-2);  // Store result\n  return memo[n];\n}",
      "action": "continue",
      "next": "coding-space-optimization-cpp"
    },
    {
      "stepId": "coding-space-optimization-cpp",
      "mentorSays": "We can optimize space from O(n) to O(1).\n\nNotice: we only need the previous 2 values!\n\nInstead of storing all values:\nlet dp = [0, 1, 1, 2, 3, 5, 8]\n\nWe can use just two variables:\nlet prev2 = 0, prev1 = 1;\n\nSpace: O(n) â†’ O(1)\nTime: still O(n)",
      "example": "// Space optimized version:\nif (n <= 1) return n;\nlet prev2 = 0, prev1 = 1;\nfor (let i = 2; i <= n; i++) {\n  let current = prev1 + prev2;\n  prev2 = prev1;\n  prev1 = current;\n}\nreturn prev1;",
      "action": "continue",
      "next": "coding-return-cpp"
    },
    {
      "stepId": "coding-return-cpp",
      "mentorSays": "Finally, return dp[n], which contains the nth Fibonacci number.",
      "example": "int fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    \n    vector<int> dp(n + 1);\n    dp[0] = 0;\n    dp[1] = 1;\n    \n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i-1] + dp[i-2];\n    }\n    \n    return dp[n];\n}",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nn = 6\n\nAfter calling fib(6), it should return:\n8\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nn = 6\n\nAfter fib(6):\n8",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-ts"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-ts"
        }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'dp' or 'fib') and put data inside it.\n\nFor example, 'let dp: number[] = [];' creates a variable that stores an empty array.",
      "example": "let dp: number[] = [];\n\nNow the variable refers to an empty array",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "array-check-ts"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-ts"
        }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function add(a: number, b: number): number {\n  return a + b;\n}\n\nadd(3, 5) returns 8",
      "action": "continue",
      "next": "array-check-ts"
    },
    {
      "stepId": "array-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what an array is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know arrays",
          "next": "recursion-vs-dp-check-ts"
        },
        {
          "label": "No, explain arrays",
          "next": "array-explanation-ts"
        }
      ]
    },
    {
      "stepId": "recursion-vs-dp-check-ts",
      "mentorSays": "Do you understand the difference between naive recursion and DP?",
      "choices": [
        {
          "label": "Yes, I know recursion-vs-dp",
          "next": "memoization-check-ts"
        },
        {
          "label": "No, explain recursion-vs-dp",
          "next": "recursion-vs-dp-explanation-ts"
        }
      ]
    },
    {
      "stepId": "memoization-check-ts",
      "mentorSays": "Do you understand memoization (top-down DP)?",
      "choices": [
        {
          "label": "Yes, I know memoization",
          "next": "coding-start-ts"
        },
        {
          "label": "No, explain memoization",
          "next": "memoization-explanation-ts"
        }
      ]
    },
    {
      "stepId": "memoization-explanation-ts",
      "mentorSays": "Memoization caches the results of recursive calls. When we compute fib(n), we store it in a memo object. If we need fib(n) again, we return the cached value instead of recalculating. This transforms exponential time to linear time!\n\n// Memoization: cache recursive results\nlet memo: { [key: number]: number } = {};\n\nfunction fib(n: number): number {\n  if (n <= 1) return n;\n  if (memo[n]) return memo[n];  // Return cached result\n  memo[n] = fib(n-1) + fib(n-2);  // Store result\n  return memo[n];\n}\n\nGot it?",
      "example": "// Memoization: cache recursive results\nlet memo: { [key: number]: number } = {};\n\nfunction fib(n: number): number {\n  if (n <= 1) return n;\n  if (memo[n]) return memo[n];  // Return cached result\n  memo[n] = fib(n-1) + fib(n-2);  // Store result\n  return memo[n];\n}",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "recursion-vs-dp-explanation-ts",
      "mentorSays": "Naive recursion recalculates the same subproblems many times, leading to exponential time O(2^n). DP solves each subproblem once and reuses the result, leading to linear time O(n). This is the key benefit of dynamic programming!\n\n// Naive recursion: O(2^n)\nfunction fib(n: number): number {\n  if (n <= 1) return n;\n  return fib(n-1) + fib(n-2);  // Recalculates same values!\n}\n\n// DP: O(n)\nlet dp: number[] = [0, 1];\nfor (let i = 2; i <= n; i++) {\n  dp[i] = dp[i-1] + dp[i-2];  // Each value calculated once!\n}\n\nGot it?",
      "example": "// Naive recursion: O(2^n)\nfunction fib(n: number): number {\n  if (n <= 1) return n;\n  return fib(n-1) + fib(n-2);  // Recalculates same values!\n}\n\n// DP: O(n)\nlet dp: number[] = [0, 1];\nfor (let i = 2; i <= n; i++) {\n  dp[i] = dp[i-1] + dp[i-2];  // Each value calculated once!\n}",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "array-explanation-ts",
      "mentorSays": "An array is like a list of items that keeps them in order. Each item has a position number called an 'index'. Array indices start counting from 0.",
      "example": "arr: number[] = [1, 2, 3]\n\narr[0] = 1\narr[1] = 2\narr[2] = 3",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Perfect! Let's implement Fibonacci using dynamic programming in TypeScript.",
      "example": "function fib(n: number): number {\n  // Your code here\n}",
      "action": "continue",
      "next": "coding-base-ts"
    },
    {
      "stepId": "coding-base-ts",
      "mentorSays": "First, handle edge cases: if n is 0, return 0. If n is 1, return 1.",
      "example": "function fib(n: number): number {\n  if (n === 0) return 0;\n  if (n === 1) return 1;",
      "action": "continue",
      "next": "coding-init-ts"
    },
    {
      "stepId": "coding-init-ts",
      "mentorSays": "Now, create a DP array to store Fibonacci numbers. Initialize base cases: dp[0] = 0, dp[1] = 1.",
      "example": "function fib(n: number): number {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  \n  const dp: number[] = new Array(n + 1);\n  dp[0] = 0;\n  dp[1] = 1;",
      "action": "continue",
      "next": "coding-fill-ts"
    },
    {
      "stepId": "coding-fill-ts",
      "mentorSays": "Now, fill the DP array: for each i from 2 to n, compute dp[i] = dp[i-1] + dp[i-2].",
      "example": "function fib(n: number): number {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  \n  const dp: number[] = new Array(n + 1);\n  dp[0] = 0;\n  dp[1] = 1;\n  \n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i-1] + dp[i-2];\n  }",
      "action": "continue",
      "next": "coding-memoization-ts"
    },
    {
      "stepId": "coding-memoization-ts",
      "mentorSays": "Let's add memoization to the recursive solution.\n\nWe create a memo object to cache results:\n- Before computing fib(n), check if memo[n] exists\n- If yes, return cached value\n- If no, compute it, store in memo, then return\n\nThis transforms O(2^n) to O(n) time!",
      "example": "let memo = {};\n\nfunction fib(n) {\n  if (n <= 1) return n;\n  if (memo[n]) return memo[n];  // Return cached\n  memo[n] = fib(n-1) + fib(n-2);  // Store result\n  return memo[n];\n}",
      "action": "continue",
      "next": "coding-space-optimization-ts"
    },
    {
      "stepId": "coding-space-optimization-ts",
      "mentorSays": "We can optimize space from O(n) to O(1).\n\nNotice: we only need the previous 2 values!\n\nInstead of storing all values:\nlet dp = [0, 1, 1, 2, 3, 5, 8]\n\nWe can use just two variables:\nlet prev2 = 0, prev1 = 1;\n\nSpace: O(n) â†’ O(1)\nTime: still O(n)",
      "example": "// Space optimized version:\nif (n <= 1) return n;\nlet prev2 = 0, prev1 = 1;\nfor (let i = 2; i <= n; i++) {\n  let current = prev1 + prev2;\n  prev2 = prev1;\n  prev1 = current;\n}\nreturn prev1;",
      "action": "continue",
      "next": "coding-return-ts"
    },
    {
      "stepId": "coding-return-ts",
      "mentorSays": "Finally, return dp[n], which contains the nth Fibonacci number.",
      "example": "function fib(n: number): number {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  \n  const dp: number[] = new Array(n + 1);\n  dp[0] = 0;\n  dp[1] = 1;\n  \n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i-1] + dp[i-2];\n  }\n  \n  return dp[n];\n}",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nn = 6\n\nAfter calling fib(6), it should return:\n8\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nn = 6\n\nAfter fib(6):\n8",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "final",
      "mentorSays": "ðŸŽ‰ Well done! You've learned Fibonacci with dynamic programming. You understand how to store and reuse computed values to avoid recalculating the same results!\n\nThis is O(n) time and O(n) space - much better than exponential recursion! Keep practicing!",
      "action": "continue"
    }
  ]
}