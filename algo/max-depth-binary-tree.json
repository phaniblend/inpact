{
  "id": "max-depth-binary-tree",
  "title": "Maximum Depth of Binary Tree",
  "pattern": "tree",
  "difficulty": "easy",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what the Maximum Depth of Binary Tree problem asks for\n2. Use recursion or iteration to traverse the tree\n3. Calculate the depth by finding the maximum depth of left and right subtrees\n4. Handle base cases (null nodes)\n5. Implement the solution step by step in your chosen language",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Perfect! Now let's understand what the Maximum Depth of Binary Tree problem is asking.\n\n**Problem Definition:**\nGiven the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n**Key Observations:**\n- Depth is measured in number of nodes (not edges)\n- We need to find the longest path from root to any leaf\n- A leaf is a node with no children\n- An empty tree (null root) has depth 0\n\n**Example 1:**\nTree:\n    3\n   / \\\n  9   20\n      / \\\n     15  7\n\nMaximum depth: 3 (path: 3 -> 20 -> 15 or 3 -> 20 -> 7)\n\n**Example 2:**\nTree:\n    1\n     \\\n      2\n\nMaximum depth: 2 (path: 1 -> 2)\n\n**Example 3:**\nTree: null (empty tree)\n\nMaximum depth: 0\n\n**Step-by-step trace for Example 1 (Recursive approach):**\n\nTree:\n    3\n   / \\\n  9   20\n      / \\\n     15  7\n\nWe'll use recursion:\n- **maxDepth(3)**:\n  - Left subtree depth = maxDepth(9) = 1\n  - Right subtree depth = maxDepth(20) = 2\n  - Return 1 + max(1, 2) = 1 + 2 = 3 âœ“\n\n- **maxDepth(9)**:\n  - Left = null, depth = 0\n  - Right = null, depth = 0\n  - Return 1 + max(0, 0) = 1 + 0 = 1\n\n- **maxDepth(20)**:\n  - Left subtree depth = maxDepth(15) = 1\n  - Right subtree depth = maxDepth(7) = 1\n  - Return 1 + max(1, 1) = 1 + 1 = 2\n\n- **maxDepth(15)**:\n  - Left = null, depth = 0\n  - Right = null, depth = 0\n  - Return 1 + max(0, 0) = 1\n\n- **maxDepth(7)**:\n  - Left = null, depth = 0\n  - Right = null, depth = 0\n  - Return 1 + max(0, 0) = 1\n\n**Key Insight:**\nThe maximum depth of a node = 1 (for the current node) + maximum depth of its left and right subtrees.\n\n**What makes this tricky:**\n1. Understanding that depth is measured in nodes (not edges)\n2. Handling the base case (null node returns 0)\n3. Recursive thinking: depth of current = 1 + max(depth of left, depth of right)\n4. Understanding that we need to find the maximum of left and right subtrees\n\n**Common pitfalls:**\n- Returning 0 for null node incorrectly (should return 0, not -1)\n- Not adding 1 for the current node\n- Confusing depth (nodes) with height (edges)\n- Not taking the maximum of left and right subtrees",
      "example": "Example 1:\n    3\n   / \\\n  9   20\n      / \\\n     15  7\n\nMax depth: 3\n\nExample 2:\n    1\n     \\\n      2\n\nMax depth: 2\n\nExample 3:\nnull\n\nMax depth: 0",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Now that you understand what the problem wants, here's the real question:\n\nHow would YOU find the maximum depth of a binary tree?\n\nThink about it for a moment. What approach feels natural to you?",
      "choices": [
        {
          "label": "Use recursion - depth = 1 + max(depth of left, depth of right)",
          "next": "explore-recursive"
        },
        {
          "label": "Use BFS (level-order traversal) and count levels",
          "next": "explore-bfs"
        },
        {
          "label": "Use DFS with a stack to track depth",
          "next": "explore-dfs"
        }
      ]
    },
    {
      "stepId": "explore-bfs",
      "mentorSays": "That's a great approach! You're thinking: \"I'll use BFS (level-order traversal) to visit nodes level by level, and count how many levels there are.\"\n\nThis works perfectly! However, it requires a queue and uses O(n) space in the worst case.\n\nThere's a more elegant recursive approach that uses O(h) space (where h is the height). Would you like to learn that?",
      "action": "continue",
      "next": "explore-recursive"
    },
    {
      "stepId": "explore-dfs",
      "mentorSays": "That's a solid approach! You're thinking: \"I'll use DFS with a stack to traverse the tree and track the depth at each node.\"\n\nThis works! However, it's more complex than needed.\n\nThere's a simpler recursive approach that's very elegant. Would you like to learn that?",
      "action": "continue",
      "next": "explore-recursive"
    },
    {
      "stepId": "explore-recursive",
      "mentorSays": "Excellent choice! Recursion is the most elegant solution for this problem. Here's the core idea:\n\n**The Algorithm:**\n1. **Base case**: If root is null, return 0 (empty tree has depth 0)\n2. **Recursive case**: \n   - Calculate depth of left subtree: leftDepth = maxDepth(root.left)\n   - Calculate depth of right subtree: rightDepth = maxDepth(root.right)\n   - Return 1 + max(leftDepth, rightDepth)\n\n**Why it works**:\n- The depth of a node = 1 (for the current node) + the maximum depth of its children\n- We recursively calculate the depth of each subtree\n- The base case handles null nodes (leaves' children)\n\n**Key insight**: We don't need to track depth explicitlyâ€”the recursion naturally builds it up from the bottom!\n\nLet's trace with tree:\n    3\n   / \\\n  9   20\n      / \\\n     15  7\n\n- **maxDepth(3)**:\n  - leftDepth = maxDepth(9) = 1\n  - rightDepth = maxDepth(20) = 2\n  - Return 1 + max(1, 2) = 3 âœ“\n\n- **maxDepth(9)**:\n  - leftDepth = maxDepth(null) = 0\n  - rightDepth = maxDepth(null) = 0\n  - Return 1 + max(0, 0) = 1\n\n- **maxDepth(20)**:\n  - leftDepth = maxDepth(15) = 1\n  - rightDepth = maxDepth(7) = 1\n  - Return 1 + max(1, 1) = 2\n\nThis is O(n) time (visit each node once) and O(h) space (recursion stack, where h is height)! Now let's code it step by step.",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Great! Now let's code this solution. Which programming language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "variable-check-js"
        },
        {
          "label": "Python",
          "next": "variable-check-python"
        },
        {
          "label": "Java",
          "next": "variable-check-java"
        },
        {
          "label": "C++",
          "next": "variable-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "variable-check-ts"
        }
      ]
    },
    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-js"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-js"
        }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'leftDepth' or 'rightDepth') and put data inside it.",
      "example": "let leftDepth = 0;   // Depth of left subtree\nlet rightDepth = 0;  // Depth of right subtree",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-js"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-js"
        }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function maxDepth(root) {\n  // Returns maximum depth\n  return 0;\n}",
      "action": "continue",
      "next": "parameter-check-js"
    },
    {
      "stepId": "parameter-check-js",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-js"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-js"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-js",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function maxDepth(root)', the 'root' is a parameter that receives the root node of the tree.",
      "example": "function maxDepth(root) {\n  // Parameter receives root node\n}\n\n// Call: maxDepth(rootNode)",
      "action": "continue",
      "next": "tree-check-js"
    },
    {
      "stepId": "tree-check-js",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-js"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-js"
        }
      ]
    },
    {
      "stepId": "tree-explanation-js",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.\n\nFor example, a tree:\n    3\n   / \\\n  9   20\n\nNode 3 has value 3, left child 9, and right child 20.\nNode 9 has value 9, no left child (null), no right child (null).\nNode 20 has value 20, and may have children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// Example tree:\n//     3\n//    / \\\n//   9   20",
      "action": "continue",
      "next": "recursion-check-js"
    },
    {
      "stepId": "recursion-check-js",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-js"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-js"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-js",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees\n\nFor example, to find max depth of a tree, we find max depth of left subtree and right subtree, then combine them.",
      "example": "function maxDepth(root) {\n  // Base case: empty tree\n  if (root === null) return 0;\n  \n  // Recursive case: solve for subtrees\n  let leftDepth = maxDepth(root.left);  // Recursive call!\n  let rightDepth = maxDepth(root.right); // Recursive call!\n  \n  return 1 + Math.max(leftDepth, rightDepth);\n}",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Perfect! Let's implement the maximum depth solution in JavaScript. We'll create a function that takes the root node and returns the maximum depth.",
      "example": "function maxDepth(root) {\n  \n}",
      "action": "continue",
      "next": "coding-base-case-js"
    },
    {
      "stepId": "coding-base-case-js",
      "mentorSays": "First, handle the base case: if the root is null (empty tree), return 0.",
      "example": "function maxDepth(root) {\n  // Base case: empty tree has depth 0\n  if (root === null) {\n    return 0;\n  }\n  \n}",
      "action": "continue",
      "next": "coding-recursive-left-js"
    },
    {
      "stepId": "coding-recursive-left-js",
      "mentorSays": "Calculate the depth of the left subtree by making a recursive call.",
      "example": "function maxDepth(root) {\n  if (root === null) {\n    return 0;\n  }\n  \n  // Recursively find depth of left subtree\n  let leftDepth = maxDepth(root.left);\n  \n}",
      "action": "continue",
      "next": "coding-recursive-right-js"
    },
    {
      "stepId": "coding-recursive-right-js",
      "mentorSays": "Calculate the depth of the right subtree by making another recursive call.",
      "example": "function maxDepth(root) {\n  if (root === null) {\n    return 0;\n  }\n  \n  let leftDepth = maxDepth(root.left);\n  // Recursively find depth of right subtree\n  let rightDepth = maxDepth(root.right);\n  \n}",
      "action": "continue",
      "next": "coding-return-js"
    },
    {
      "stepId": "coding-return-js",
      "mentorSays": "Return 1 (for current node) plus the maximum of left and right subtree depths.",
      "example": "function maxDepth(root) {\n  if (root === null) {\n    return 0;\n  }\n  \n  let leftDepth = maxDepth(root.left);\n  let rightDepth = maxDepth(root.right);\n  \n  // Current node contributes 1, plus max of children\n  return 1 + Math.max(leftDepth, rightDepth);\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** Tree:\n    3\n   / \\\n  9   20\n      / \\\n     15  7\nExpected: 3\n\n**Test 2:** Tree:\n    1\n     \\\n      2\nExpected: 2\n\n**Test 3:** Tree: null\nExpected: 0\n\n**Test 4:** Tree: 1 (single node)\nExpected: 1\n\n**Test 5:** Tree:\n    1\n   / \\\n  2   3\nExpected: 2\n\n**Test 6:** Tree:\n    1\n   /\n  2\n /\n3\nExpected: 3\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [3,9,20,null,null,15,7] â†’ 3\nTest 2: [1,null,2] â†’ 2\nTest 3: [] â†’ 0\nTest 4: [1] â†’ 1\nTest 5: [1,2,3] â†’ 2\nTest 6: [1,2,null,3] â†’ 3",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Python?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-python"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-python"
        }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'leftDepth' or 'rightDepth') and put data inside it.",
      "example": " leftDepth = 0;   // Depth of left subtree\n rightDepth = 0;  // Depth of right subtree",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Python?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-python"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-python"
        }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "def maxDepth(root) {\n  // Returns maximum depth\n  return 0;\n}",
      "action": "continue",
      "next": "parameter-check-python"
    },
    {
      "stepId": "parameter-check-python",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-python"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-python"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-python",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'def maxDepth(root)', the 'root' is a parameter that receives the root node of the tree.",
      "example": "def maxDepth(root) {\n  // Parameter receives root node\n}\n\n// Call: maxDepth(rootNode)",
      "action": "continue",
      "next": "tree-check-python"
    },
    {
      "stepId": "tree-check-python",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-python"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-python"
        }
      ]
    },
    {
      "stepId": "tree-explanation-python",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.\n\nFor example, a tree:\n    3\n   / \\\n  9   20\n\nNode 3 has value 3, left child 9, and right child 20.\nNode 9 has value 9, no left child (null), no right child (null).\nNode 20 has value 20, and may have children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// Example tree:\n//     3\n//    / \\\n//   9   20",
      "action": "continue",
      "next": "recursion-check-python"
    },
    {
      "stepId": "recursion-check-python",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in Python?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-python"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-python"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-python",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees\n\nFor example, to find max depth of a tree, we find max depth of left subtree and right subtree, then combine them.",
      "example": "function maxDepth(root) {\n  // Base case: empty tree\n  if (root === null) return 0;\n  \n  // Recursive case: solve for subtrees\n  let leftDepth = maxDepth(root.left);  // Recursive call!\n  let rightDepth = maxDepth(root.right); // Recursive call!\n  \n  return 1 + Math.max(leftDepth, rightDepth);\n}",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Perfect! Let's implement the solution in Python.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-base-case-python"
    },
    {
      "stepId": "coding-base-case-python",
      "mentorSays": "Handle base case (null root).",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-recursive-left-python"
    },
    {
      "stepId": "coding-recursive-left-python",
      "mentorSays": "Recursively find left subtree depth.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-recursive-right-python"
    },
    {
      "stepId": "coding-recursive-right-python",
      "mentorSays": "Recursively find right subtree depth.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-return-python"
    },
    {
      "stepId": "coding-return-python",
      "mentorSays": "Return 1 + max(left, right).",
      "example": "// Python implementation",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** Tree:\n    3\n   / \\\n  9   20\n      / \\\n     15  7\nExpected: 3\n\n**Test 2:** Tree:\n    1\n     \\\n      2\nExpected: 2\n\n**Test 3:** Tree: null\nExpected: 0\n\n**Test 4:** Tree: 1 (single node)\nExpected: 1\n\n**Test 5:** Tree:\n    1\n   / \\\n  2   3\nExpected: 2\n\n**Test 6:** Tree:\n    1\n   /\n  2\n /\n3\nExpected: 3\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [3,9,20,null,null,15,7] â†’ 3\nTest 2: [1,null,2] â†’ 2\nTest 3: [] â†’ 0\nTest 4: [1] â†’ 1\nTest 5: [1,2,3] â†’ 2\nTest 6: [1,2,null,3] â†’ 3",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Java?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-java"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-java"
        }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'leftDepth' or 'rightDepth') and put data inside it.",
      "example": "int leftDepth = 0;   // Depth of left subtree\nint rightDepth = 0;  // Depth of right subtree",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Java?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-java"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-java"
        }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "public int maxDepth(root) {\n  // Returns maximum depth\n  return 0;\n}",
      "action": "continue",
      "next": "parameter-check-java"
    },
    {
      "stepId": "parameter-check-java",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-java"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-java"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-java",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'public int maxDepth(root)', the 'root' is a parameter that receives the root node of the tree.",
      "example": "public int maxDepth(root) {\n  // Parameter receives root node\n}\n\n// Call: maxDepth(rootNode)",
      "action": "continue",
      "next": "tree-check-java"
    },
    {
      "stepId": "tree-check-java",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-java"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-java"
        }
      ]
    },
    {
      "stepId": "tree-explanation-java",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.\n\nFor example, a tree:\n    3\n   / \\\n  9   20\n\nNode 3 has value 3, left child 9, and right child 20.\nNode 9 has value 9, no left child (null), no right child (null).\nNode 20 has value 20, and may have children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// Example tree:\n//     3\n//    / \\\n//   9   20",
      "action": "continue",
      "next": "recursion-check-java"
    },
    {
      "stepId": "recursion-check-java",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in Java?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-java"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-java"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-java",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees\n\nFor example, to find max depth of a tree, we find max depth of left subtree and right subtree, then combine them.",
      "example": "function maxDepth(root) {\n  // Base case: empty tree\n  if (root === null) return 0;\n  \n  // Recursive case: solve for subtrees\n  let leftDepth = maxDepth(root.left);  // Recursive call!\n  let rightDepth = maxDepth(root.right); // Recursive call!\n  \n  return 1 + Math.max(leftDepth, rightDepth);\n}",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Perfect! Let's implement the solution in Java.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-base-case-java"
    },
    {
      "stepId": "coding-base-case-java",
      "mentorSays": "Handle base case (null root).",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-recursive-left-java"
    },
    {
      "stepId": "coding-recursive-left-java",
      "mentorSays": "Recursively find left subtree depth.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-recursive-right-java"
    },
    {
      "stepId": "coding-recursive-right-java",
      "mentorSays": "Recursively find right subtree depth.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-return-java"
    },
    {
      "stepId": "coding-return-java",
      "mentorSays": "Return 1 + max(left, right).",
      "example": "// Java implementation",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** Tree:\n    3\n   / \\\n  9   20\n      / \\\n     15  7\nExpected: 3\n\n**Test 2:** Tree:\n    1\n     \\\n      2\nExpected: 2\n\n**Test 3:** Tree: null\nExpected: 0\n\n**Test 4:** Tree: 1 (single node)\nExpected: 1\n\n**Test 5:** Tree:\n    1\n   / \\\n  2   3\nExpected: 2\n\n**Test 6:** Tree:\n    1\n   /\n  2\n /\n3\nExpected: 3\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [3,9,20,null,null,15,7] â†’ 3\nTest 2: [1,null,2] â†’ 2\nTest 3: [] â†’ 0\nTest 4: [1] â†’ 1\nTest 5: [1,2,3] â†’ 2\nTest 6: [1,2,null,3] â†’ 3",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in C++?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-cpp"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'leftDepth' or 'rightDepth') and put data inside it.",
      "example": "int leftDepth = 0;   // Depth of left subtree\nint rightDepth = 0;  // Depth of right subtree",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in C++?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-cpp"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "int maxDepth(root) {\n  // Returns maximum depth\n  return 0;\n}",
      "action": "continue",
      "next": "parameter-check-cpp"
    },
    {
      "stepId": "parameter-check-cpp",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-cpp"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-cpp",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'int maxDepth(root)', the 'root' is a parameter that receives the root node of the tree.",
      "example": "int maxDepth(root) {\n  // Parameter receives root node\n}\n\n// Call: maxDepth(rootNode)",
      "action": "continue",
      "next": "tree-check-cpp"
    },
    {
      "stepId": "tree-check-cpp",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-cpp"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "tree-explanation-cpp",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.\n\nFor example, a tree:\n    3\n   / \\\n  9   20\n\nNode 3 has value 3, left child 9, and right child 20.\nNode 9 has value 9, no left child (null), no right child (null).\nNode 20 has value 20, and may have children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// Example tree:\n//     3\n//    / \\\n//   9   20",
      "action": "continue",
      "next": "recursion-check-cpp"
    },
    {
      "stepId": "recursion-check-cpp",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in C++?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-cpp"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-cpp",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees\n\nFor example, to find max depth of a tree, we find max depth of left subtree and right subtree, then combine them.",
      "example": "function maxDepth(root) {\n  // Base case: empty tree\n  if (root === null) return 0;\n  \n  // Recursive case: solve for subtrees\n  let leftDepth = maxDepth(root.left);  // Recursive call!\n  let rightDepth = maxDepth(root.right); // Recursive call!\n  \n  return 1 + Math.max(leftDepth, rightDepth);\n}",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Perfect! Let's implement the solution in C++.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-base-case-cpp"
    },
    {
      "stepId": "coding-base-case-cpp",
      "mentorSays": "Handle base case (null root).",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-recursive-left-cpp"
    },
    {
      "stepId": "coding-recursive-left-cpp",
      "mentorSays": "Recursively find left subtree depth.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-recursive-right-cpp"
    },
    {
      "stepId": "coding-recursive-right-cpp",
      "mentorSays": "Recursively find right subtree depth.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-return-cpp"
    },
    {
      "stepId": "coding-return-cpp",
      "mentorSays": "Return 1 + max(left, right).",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** Tree:\n    3\n   / \\\n  9   20\n      / \\\n     15  7\nExpected: 3\n\n**Test 2:** Tree:\n    1\n     \\\n      2\nExpected: 2\n\n**Test 3:** Tree: null\nExpected: 0\n\n**Test 4:** Tree: 1 (single node)\nExpected: 1\n\n**Test 5:** Tree:\n    1\n   / \\\n  2   3\nExpected: 2\n\n**Test 6:** Tree:\n    1\n   /\n  2\n /\n3\nExpected: 3\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [3,9,20,null,null,15,7] â†’ 3\nTest 2: [1,null,2] â†’ 2\nTest 3: [] â†’ 0\nTest 4: [1] â†’ 1\nTest 5: [1,2,3] â†’ 2\nTest 6: [1,2,null,3] â†’ 3",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-ts"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-ts"
        }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'leftDepth' or 'rightDepth') and put data inside it.",
      "example": "let leftDepth = 0;   // Depth of left subtree\nlet rightDepth = 0;  // Depth of right subtree",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-ts"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-ts"
        }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function maxDepth(root) {\n  // Returns maximum depth\n  return 0;\n}",
      "action": "continue",
      "next": "parameter-check-ts"
    },
    {
      "stepId": "parameter-check-ts",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-ts"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-ts"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-ts",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function maxDepth(root)', the 'root' is a parameter that receives the root node of the tree.",
      "example": "function maxDepth(root) {\n  // Parameter receives root node\n}\n\n// Call: maxDepth(rootNode)",
      "action": "continue",
      "next": "tree-check-ts"
    },
    {
      "stepId": "tree-check-ts",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-ts"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-ts"
        }
      ]
    },
    {
      "stepId": "tree-explanation-ts",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.\n\nFor example, a tree:\n    3\n   / \\\n  9   20\n\nNode 3 has value 3, left child 9, and right child 20.\nNode 9 has value 9, no left child (null), no right child (null).\nNode 20 has value 20, and may have children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// Example tree:\n//     3\n//    / \\\n//   9   20",
      "action": "continue",
      "next": "recursion-check-ts"
    },
    {
      "stepId": "recursion-check-ts",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-ts"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-ts"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-ts",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees\n\nFor example, to find max depth of a tree, we find max depth of left subtree and right subtree, then combine them.",
      "example": "function maxDepth(root) {\n  // Base case: empty tree\n  if (root === null) return 0;\n  \n  // Recursive case: solve for subtrees\n  let leftDepth = maxDepth(root.left);  // Recursive call!\n  let rightDepth = maxDepth(root.right); // Recursive call!\n  \n  return 1 + Math.max(leftDepth, rightDepth);\n}",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Perfect! Let's implement the solution in TypeScript.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-base-case-ts"
    },
    {
      "stepId": "coding-base-case-ts",
      "mentorSays": "Handle base case (null root).",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-recursive-left-ts"
    },
    {
      "stepId": "coding-recursive-left-ts",
      "mentorSays": "Recursively find left subtree depth.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-recursive-right-ts"
    },
    {
      "stepId": "coding-recursive-right-ts",
      "mentorSays": "Recursively find right subtree depth.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-return-ts"
    },
    {
      "stepId": "coding-return-ts",
      "mentorSays": "Return 1 + max(left, right).",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** Tree:\n    3\n   / \\\n  9   20\n      / \\\n     15  7\nExpected: 3\n\n**Test 2:** Tree:\n    1\n     \\\n      2\nExpected: 2\n\n**Test 3:** Tree: null\nExpected: 0\n\n**Test 4:** Tree: 1 (single node)\nExpected: 1\n\n**Test 5:** Tree:\n    1\n   / \\\n  2   3\nExpected: 2\n\n**Test 6:** Tree:\n    1\n   /\n  2\n /\n3\nExpected: 3\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [3,9,20,null,null,15,7] â†’ 3\nTest 2: [1,null,2] â†’ 2\nTest 3: [] â†’ 0\nTest 4: [1] â†’ 1\nTest 5: [1,2,3] â†’ 2\nTest 6: [1,2,null,3] â†’ 3",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "final",
      "mentorSays": "ðŸŽ‰ Well done! You've successfully implemented the Maximum Depth of Binary Tree solution!\n\n**Time Complexity:** O(n)\n- We visit each node exactly once\n- n is the number of nodes in the tree\n\n**Space Complexity:** O(h)\n- The recursion stack uses space proportional to the height of the tree\n- In the worst case (skewed tree), h = n, so O(n)\n- In the best case (balanced tree), h = log n, so O(log n)\n\n**Key Takeaways:**\n1. **Recursive approach**: The depth of a node = 1 + max(depth of left subtree, depth of right subtree)\n2. **Base case**: Empty tree (null) has depth 0\n3. **Natural recursion**: Trees are naturally recursive structures, so recursion fits perfectly\n4. **Depth vs Height**: Depth is measured in nodes (we count the current node as 1)\n5. **Maximum of subtrees**: We take the maximum because we want the longest path\n\n**Related Practice Problems:**\n- Minimum Depth of Binary Tree (LeetCode #111) - find minimum instead of maximum\n- Balanced Binary Tree (LeetCode #110) - check if tree is balanced\n- Diameter of Binary Tree (LeetCode #543) - longest path between any two nodes\n\nKeep practicing tree problems - they're fundamental for interviews!",
      "action": "continue"
    }
  ]
}