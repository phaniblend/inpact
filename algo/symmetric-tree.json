{
  "id": "symmetric-tree",
  "title": "Symmetric Tree",
  "pattern": "tree",
  "difficulty": "easy",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what the Symmetric Tree problem asks for\n2. Use recursion to check if a tree is symmetric\n3. Compare left and right subtrees mirror-wise\n4. Handle base cases (null nodes)\n5. Implement the solution step by step in your chosen language",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Perfect! Now let's understand what the Symmetric Tree problem is asking.\n\n**Problem Definition:**\nGiven the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\n\n**Key Observations:**\n- A tree is symmetric if the left and right subtrees are mirror images\n- Corresponding nodes must have the same value\n- The structure must be mirrored (left child of left = right child of right)\n- An empty tree is considered symmetric\n\n**Example 1:**\nTree:\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\nThis tree is symmetric. The left subtree (2,3,4) is a mirror of the right subtree (2,4,3).\nAnswer: true\n\n**Example 2:**\nTree:\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n\nThis tree is NOT symmetric. The left subtree has a right child (3), but the right subtree has a right child (3) in the same position (not mirrored).\nAnswer: false\n\n**Example 3:**\nTree:\n    1\n   / \\\n  2   2\n /     \\\n3       3\n\nThis tree IS symmetric. The left child of left (3) mirrors the right child of right (3).\nAnswer: true\n\n**Step-by-step trace for Example 1 (Recursive approach):**\n\nTree:\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\nWe'll use a helper function to compare two subtrees mirror-wise:\n- **isSymmetric(1)**:\n  - Call helper: isMirror(left=2, right=2)\n  - Return result\n\n- **isMirror(left=2, right=2)**:\n  - Both not null âœ“\n  - Values equal (2 == 2) âœ“\n  - Check mirror: isMirror(left.left=3, right.right=3) = true\n  - Check mirror: isMirror(left.right=4, right.left=4) = true\n  - Return true && true = true âœ“\n\n- **isMirror(3, 3)**:\n  - Both not null âœ“\n  - Values equal âœ“\n  - Both children null, return true\n\n- **isMirror(4, 4)**:\n  - Both not null âœ“\n  - Values equal âœ“\n  - Both children null, return true\n\n**Key Insight:**\nA tree is symmetric if:\n1. The root's left and right subtrees are mirror images\n2. Two subtrees are mirrors if:\n   - Both roots have the same value\n   - Left subtree's left child mirrors right subtree's right child\n   - Left subtree's right child mirrors right subtree's left child\n\n**What makes this tricky:**\n1. Understanding mirror symmetry (left.left mirrors right.right)\n2. Recursive thinking: subtrees are symmetric if they mirror each other\n3. Handling null cases correctly\n4. The helper function compares two nodes mirror-wise\n\n**Common pitfalls:**\n- Not understanding mirror symmetry (comparing left.left with right.left instead of right.right)\n- Only checking values without checking structure\n- Not handling null cases correctly\n- Confusing symmetric with same (they're different!)",
      "example": "Example 1:\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\nSymmetric: true\n\nExample 2:\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n\nSymmetric: false\n\nExample 3:\n    1\n   / \\\n  2   2\n /     \\\n3       3\n\nSymmetric: true",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Now that you understand what the problem wants, here's the real question:\n\nHow would YOU check if a binary tree is symmetric?\n\nThink about it for a moment. What approach feels natural to you?",
      "choices": [
        {
          "label": "Use recursion with helper - compare left and right subtrees mirror-wise",
          "next": "explore-recursive"
        },
        {
          "label": "Use BFS to compare nodes level by level",
          "next": "explore-bfs"
        },
        {
          "label": "Convert tree to array and check if array is symmetric",
          "next": "explore-convert"
        }
      ]
    },
    {
      "stepId": "explore-bfs",
      "mentorSays": "That's a great approach! You're thinking: \"I'll use BFS (level-order traversal) to visit nodes level by level, and check if each level is symmetric.\"\n\nThis works perfectly! However, it requires a queue and uses O(n) space.\n\nThere's a more elegant recursive approach that uses O(h) space (where h is the height). Would you like to learn that?",
      "action": "continue",
      "next": "explore-recursive"
    },
    {
      "stepId": "explore-convert",
      "mentorSays": "That's a creative approach! You're thinking: \"I'll convert the tree to an array representation and check if the array is symmetric.\"\n\nThis works, but it uses extra space and is more complex than needed.\n\nThere's a simpler recursive approach that checks symmetry directly. Would you like to learn that?",
      "action": "continue",
      "next": "explore-recursive"
    },
    {
      "stepId": "explore-recursive",
      "mentorSays": "Excellent choice! Recursion is the most elegant solution for this problem. Here's the core idea:\n\n**The Algorithm:**\n1. **Base case**: If root is null, return true (empty tree is symmetric)\n2. **Helper function**: Create isMirror(left, right) to check if two subtrees are mirrors\n3. **isMirror logic**:\n   - If both are null, return true\n   - If one is null, return false\n   - If values don't match, return false\n   - Return isMirror(left.left, right.right) && isMirror(left.right, right.left)\n4. **Main function**: Return isMirror(root.left, root.right)\n\n**Why it works**:\n- A tree is symmetric if left and right subtrees are mirror images\n- Two subtrees are mirrors if:\n  - Their roots have the same value\n  - Left's left child mirrors right's right child\n  - Left's right child mirrors right's left child\n\n**Key insight**: For mirror symmetry, we compare left.left with right.right (not right.left)! This is the key difference from checking if trees are the same.\n\nLet's trace with tree:\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\n- **isSymmetric(1)**:\n  - Return isMirror(2, 2)\n\n- **isMirror(2, 2)**:\n  - Both not null âœ“\n  - Values equal (2 == 2) âœ“\n  - Check: isMirror(2.left=3, 2.right=3) = true\n  - Check: isMirror(2.right=4, 2.left=4) = true\n  - Return true && true = true âœ“\n\nThis is O(n) time (visit each node once) and O(h) space (recursion stack)! Now let's code it step by step.",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Great! Now let's code this solution. Which programming language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "variable-check-js"
        },
        {
          "label": "Python",
          "next": "variable-check-python"
        },
        {
          "label": "Java",
          "next": "variable-check-java"
        },
        {
          "label": "C++",
          "next": "variable-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "variable-check-ts"
        }
      ]
    },
    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-js"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-js"
        }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'left' or 'right') and put data inside it.",
      "example": "let left = root.left;   // Left subtree\nlet right = root.right; // Right subtree",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-js"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-js"
        }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function isSymmetric(root) {\n  // Returns true if tree is symmetric\n  return false;\n}",
      "action": "continue",
      "next": "parameter-check-js"
    },
    {
      "stepId": "parameter-check-js",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-js"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-js"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-js",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function isSymmetric(root)', the 'root' is a parameter that receives the root node.",
      "example": "function isSymmetric(root) {\n  // Parameter receives root node\n}\n\n// Call: isSymmetric(rootNode)",
      "action": "continue",
      "next": "tree-check-js"
    },
    {
      "stepId": "tree-check-js",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-js"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-js"
        }
      ]
    },
    {
      "stepId": "tree-explanation-js",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-js"
    },
    {
      "stepId": "recursion-check-js",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-js"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-js"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-js",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees",
      "example": "function isMirror(left, right) {\n  // Base cases\n  if (left === null && right === null) return true;\n  if (left === null || right === null) return false;\n  \n  // Recursive calls\n  return left.val === right.val &&\n         isMirror(left.left, right.right) &&  // Mirror comparison!\n         isMirror(left.right, right.left);     // Mirror comparison!\n}",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Perfect! Let's implement the symmetric tree solution in JavaScript. We'll create a function that takes the root and returns true if the tree is symmetric.",
      "example": "function isSymmetric(root) {\n  \n}",
      "action": "continue",
      "next": "coding-base-case-js"
    },
    {
      "stepId": "coding-base-case-js",
      "mentorSays": "First, handle the base case: if root is null, return true (empty tree is symmetric).",
      "example": "function isSymmetric(root) {\n  // Base case: empty tree is symmetric\n  if (root === null) {\n    return true;\n  }\n  \n}",
      "action": "continue",
      "next": "coding-helper-start-js"
    },
    {
      "stepId": "coding-helper-start-js",
      "mentorSays": "Create a helper function isMirror that checks if two subtrees are mirror images of each other.",
      "example": "function isSymmetric(root) {\n  if (root === null) {\n    return true;\n  }\n  \n  // Helper function to check if two subtrees are mirrors\n  function isMirror(left, right) {\n    // Mirror check logic here\n  }\n  \n}",
      "action": "continue",
      "next": "coding-helper-base-js"
    },
    {
      "stepId": "coding-helper-base-js",
      "mentorSays": "In the helper function, handle base cases: if both are null, return true; if one is null, return false.",
      "example": "function isSymmetric(root) {\n  if (root === null) {\n    return true;\n  }\n  \n  function isMirror(left, right) {\n    // Both null: mirrors\n    if (left === null && right === null) {\n      return true;\n    }\n    // One null: not mirrors\n    if (left === null || right === null) {\n      return false;\n    }\n    \n  }\n  \n}",
      "action": "continue",
      "next": "coding-helper-values-js"
    },
    {
      "stepId": "coding-helper-values-js",
      "mentorSays": "Check if the values of the two nodes match. If not, return false.",
      "example": "function isSymmetric(root) {\n  if (root === null) {\n    return true;\n  }\n  \n  function isMirror(left, right) {\n    if (left === null && right === null) {\n      return true;\n    }\n    if (left === null || right === null) {\n      return false;\n    }\n    \n    // Check if values match\n    if (left.val !== right.val) {\n      return false;\n    }\n    \n  }\n  \n}",
      "action": "continue",
      "next": "coding-helper-recursive-js"
    },
    {
      "stepId": "coding-helper-recursive-js",
      "mentorSays": "Recursively check mirror symmetry: left.left should mirror right.right, and left.right should mirror right.left.",
      "example": "function isSymmetric(root) {\n  if (root === null) {\n    return true;\n  }\n  \n  function isMirror(left, right) {\n    if (left === null && right === null) {\n      return true;\n    }\n    if (left === null || right === null) {\n      return false;\n    }\n    if (left.val !== right.val) {\n      return false;\n    }\n    \n    // Mirror comparison: left.left mirrors right.right, left.right mirrors right.left\n    return isMirror(left.left, right.right) && isMirror(left.right, right.left);\n  }\n  \n}",
      "action": "continue",
      "next": "coding-call-helper-js"
    },
    {
      "stepId": "coding-call-helper-js",
      "mentorSays": "In the main function, call the helper function with root.left and root.right.",
      "example": "function isSymmetric(root) {\n  if (root === null) {\n    return true;\n  }\n  \n  function isMirror(left, right) {\n    if (left === null && right === null) {\n      return true;\n    }\n    if (left === null || right === null) {\n      return false;\n    }\n    if (left.val !== right.val) {\n      return false;\n    }\n    return isMirror(left.left, right.right) && isMirror(left.right, right.left);\n  }\n  \n  // Check if left and right subtrees are mirrors\n  return isMirror(root.left, root.right);\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [1, 2, 2, 3, 4, 4, 3]\nExpected: true (symmetric)\n\n**Test 2:** root = [1, 2, 2, null, 3, null, 3]\nExpected: false (not symmetric)\n\n**Test 3:** root = [1, 2, 2, null, 3, 3, null]\nExpected: true (symmetric)\n\n**Test 4:** root = null\nExpected: true (empty tree is symmetric)\n\n**Test 5:** root = [1]\nExpected: true (single node is symmetric)\n\n**Test 6:** root = [1, 2, 2, 2, null, 2]\nExpected: false (not symmetric)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,2,2,3,4,4,3] â†’ true\nTest 2: [1,2,2,null,3,null,3] â†’ false\nTest 3: [1,2,2,null,3,3,null] â†’ true\nTest 4: null â†’ true\nTest 5: [1] â†’ true\nTest 6: [1,2,2,2,null,2] â†’ false",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Python?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-python"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-python"
        }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'left' or 'right') and put data inside it.",
      "example": " left = root.left;   // Left subtree\n right = root.right; // Right subtree",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Python?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-python"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-python"
        }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "def isSymmetric(root) {\n  // Returns true if tree is symmetric\n  return false;\n}",
      "action": "continue",
      "next": "parameter-check-python"
    },
    {
      "stepId": "parameter-check-python",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-python"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-python"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-python",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'def isSymmetric(root)', the 'root' is a parameter that receives the root node.",
      "example": "def isSymmetric(root) {\n  // Parameter receives root node\n}\n\n// Call: isSymmetric(rootNode)",
      "action": "continue",
      "next": "tree-check-python"
    },
    {
      "stepId": "tree-check-python",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-python"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-python"
        }
      ]
    },
    {
      "stepId": "tree-explanation-python",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-python"
    },
    {
      "stepId": "recursion-check-python",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in Python?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-python"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-python"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-python",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees",
      "example": "function isMirror(left, right) {\n  // Base cases\n  if (left === null && right === null) return true;\n  if (left === null || right === null) return false;\n  \n  // Recursive calls\n  return left.val === right.val &&\n         isMirror(left.left, right.right) &&  // Mirror comparison!\n         isMirror(left.right, right.left);     // Mirror comparison!\n}",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Perfect! Let's implement the solution in Python.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-base-case-python"
    },
    {
      "stepId": "coding-base-case-python",
      "mentorSays": "Handle base case (null root).",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-helper-start-python"
    },
    {
      "stepId": "coding-helper-start-python",
      "mentorSays": "Create helper function isMirror.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-helper-base-python"
    },
    {
      "stepId": "coding-helper-base-python",
      "mentorSays": "Handle base cases in helper.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-helper-values-python"
    },
    {
      "stepId": "coding-helper-values-python",
      "mentorSays": "Check if values match.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-helper-recursive-python"
    },
    {
      "stepId": "coding-helper-recursive-python",
      "mentorSays": "Recursively check mirror symmetry.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-call-helper-python"
    },
    {
      "stepId": "coding-call-helper-python",
      "mentorSays": "Call helper with root.left and root.right.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [1, 2, 2, 3, 4, 4, 3]\nExpected: true (symmetric)\n\n**Test 2:** root = [1, 2, 2, null, 3, null, 3]\nExpected: false (not symmetric)\n\n**Test 3:** root = [1, 2, 2, null, 3, 3, null]\nExpected: true (symmetric)\n\n**Test 4:** root = null\nExpected: true (empty tree is symmetric)\n\n**Test 5:** root = [1]\nExpected: true (single node is symmetric)\n\n**Test 6:** root = [1, 2, 2, 2, null, 2]\nExpected: false (not symmetric)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,2,2,3,4,4,3] â†’ true\nTest 2: [1,2,2,null,3,null,3] â†’ false\nTest 3: [1,2,2,null,3,3,null] â†’ true\nTest 4: null â†’ true\nTest 5: [1] â†’ true\nTest 6: [1,2,2,2,null,2] â†’ false",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Java?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-java"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-java"
        }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'left' or 'right') and put data inside it.",
      "example": "boolean left = root.left;   // Left subtree\nboolean right = root.right; // Right subtree",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Java?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-java"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-java"
        }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "public boolean isSymmetric(root) {\n  // Returns true if tree is symmetric\n  return false;\n}",
      "action": "continue",
      "next": "parameter-check-java"
    },
    {
      "stepId": "parameter-check-java",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-java"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-java"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-java",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'public boolean isSymmetric(root)', the 'root' is a parameter that receives the root node.",
      "example": "public boolean isSymmetric(root) {\n  // Parameter receives root node\n}\n\n// Call: isSymmetric(rootNode)",
      "action": "continue",
      "next": "tree-check-java"
    },
    {
      "stepId": "tree-check-java",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-java"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-java"
        }
      ]
    },
    {
      "stepId": "tree-explanation-java",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-java"
    },
    {
      "stepId": "recursion-check-java",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in Java?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-java"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-java"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-java",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees",
      "example": "function isMirror(left, right) {\n  // Base cases\n  if (left === null && right === null) return true;\n  if (left === null || right === null) return false;\n  \n  // Recursive calls\n  return left.val === right.val &&\n         isMirror(left.left, right.right) &&  // Mirror comparison!\n         isMirror(left.right, right.left);     // Mirror comparison!\n}",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Perfect! Let's implement the solution in Java.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-base-case-java"
    },
    {
      "stepId": "coding-base-case-java",
      "mentorSays": "Handle base case (null root).",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-helper-start-java"
    },
    {
      "stepId": "coding-helper-start-java",
      "mentorSays": "Create helper function isMirror.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-helper-base-java"
    },
    {
      "stepId": "coding-helper-base-java",
      "mentorSays": "Handle base cases in helper.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-helper-values-java"
    },
    {
      "stepId": "coding-helper-values-java",
      "mentorSays": "Check if values match.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-helper-recursive-java"
    },
    {
      "stepId": "coding-helper-recursive-java",
      "mentorSays": "Recursively check mirror symmetry.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-call-helper-java"
    },
    {
      "stepId": "coding-call-helper-java",
      "mentorSays": "Call helper with root.left and root.right.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [1, 2, 2, 3, 4, 4, 3]\nExpected: true (symmetric)\n\n**Test 2:** root = [1, 2, 2, null, 3, null, 3]\nExpected: false (not symmetric)\n\n**Test 3:** root = [1, 2, 2, null, 3, 3, null]\nExpected: true (symmetric)\n\n**Test 4:** root = null\nExpected: true (empty tree is symmetric)\n\n**Test 5:** root = [1]\nExpected: true (single node is symmetric)\n\n**Test 6:** root = [1, 2, 2, 2, null, 2]\nExpected: false (not symmetric)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,2,2,3,4,4,3] â†’ true\nTest 2: [1,2,2,null,3,null,3] â†’ false\nTest 3: [1,2,2,null,3,3,null] â†’ true\nTest 4: null â†’ true\nTest 5: [1] â†’ true\nTest 6: [1,2,2,2,null,2] â†’ false",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in C++?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-cpp"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'left' or 'right') and put data inside it.",
      "example": "bool left = root.left;   // Left subtree\nbool right = root.right; // Right subtree",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in C++?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-cpp"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "bool isSymmetric(root) {\n  // Returns true if tree is symmetric\n  return false;\n}",
      "action": "continue",
      "next": "parameter-check-cpp"
    },
    {
      "stepId": "parameter-check-cpp",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-cpp"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-cpp",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'bool isSymmetric(root)', the 'root' is a parameter that receives the root node.",
      "example": "bool isSymmetric(root) {\n  // Parameter receives root node\n}\n\n// Call: isSymmetric(rootNode)",
      "action": "continue",
      "next": "tree-check-cpp"
    },
    {
      "stepId": "tree-check-cpp",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-cpp"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "tree-explanation-cpp",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-cpp"
    },
    {
      "stepId": "recursion-check-cpp",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in C++?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-cpp"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-cpp",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees",
      "example": "function isMirror(left, right) {\n  // Base cases\n  if (left === null && right === null) return true;\n  if (left === null || right === null) return false;\n  \n  // Recursive calls\n  return left.val === right.val &&\n         isMirror(left.left, right.right) &&  // Mirror comparison!\n         isMirror(left.right, right.left);     // Mirror comparison!\n}",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Perfect! Let's implement the solution in C++.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-base-case-cpp"
    },
    {
      "stepId": "coding-base-case-cpp",
      "mentorSays": "Handle base case (null root).",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-helper-start-cpp"
    },
    {
      "stepId": "coding-helper-start-cpp",
      "mentorSays": "Create helper function isMirror.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-helper-base-cpp"
    },
    {
      "stepId": "coding-helper-base-cpp",
      "mentorSays": "Handle base cases in helper.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-helper-values-cpp"
    },
    {
      "stepId": "coding-helper-values-cpp",
      "mentorSays": "Check if values match.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-helper-recursive-cpp"
    },
    {
      "stepId": "coding-helper-recursive-cpp",
      "mentorSays": "Recursively check mirror symmetry.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-call-helper-cpp"
    },
    {
      "stepId": "coding-call-helper-cpp",
      "mentorSays": "Call helper with root.left and root.right.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [1, 2, 2, 3, 4, 4, 3]\nExpected: true (symmetric)\n\n**Test 2:** root = [1, 2, 2, null, 3, null, 3]\nExpected: false (not symmetric)\n\n**Test 3:** root = [1, 2, 2, null, 3, 3, null]\nExpected: true (symmetric)\n\n**Test 4:** root = null\nExpected: true (empty tree is symmetric)\n\n**Test 5:** root = [1]\nExpected: true (single node is symmetric)\n\n**Test 6:** root = [1, 2, 2, 2, null, 2]\nExpected: false (not symmetric)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,2,2,3,4,4,3] â†’ true\nTest 2: [1,2,2,null,3,null,3] â†’ false\nTest 3: [1,2,2,null,3,3,null] â†’ true\nTest 4: null â†’ true\nTest 5: [1] â†’ true\nTest 6: [1,2,2,2,null,2] â†’ false",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-ts"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-ts"
        }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'left' or 'right') and put data inside it.",
      "example": "let left = root.left;   // Left subtree\nlet right = root.right; // Right subtree",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-ts"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-ts"
        }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function isSymmetric(root) {\n  // Returns true if tree is symmetric\n  return false;\n}",
      "action": "continue",
      "next": "parameter-check-ts"
    },
    {
      "stepId": "parameter-check-ts",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-ts"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-ts"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-ts",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function isSymmetric(root)', the 'root' is a parameter that receives the root node.",
      "example": "function isSymmetric(root) {\n  // Parameter receives root node\n}\n\n// Call: isSymmetric(rootNode)",
      "action": "continue",
      "next": "tree-check-ts"
    },
    {
      "stepId": "tree-check-ts",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-ts"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-ts"
        }
      ]
    },
    {
      "stepId": "tree-explanation-ts",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-ts"
    },
    {
      "stepId": "recursion-check-ts",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-ts"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-ts"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-ts",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees",
      "example": "function isMirror(left, right) {\n  // Base cases\n  if (left === null && right === null) return true;\n  if (left === null || right === null) return false;\n  \n  // Recursive calls\n  return left.val === right.val &&\n         isMirror(left.left, right.right) &&  // Mirror comparison!\n         isMirror(left.right, right.left);     // Mirror comparison!\n}",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Perfect! Let's implement the solution in TypeScript.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-base-case-ts"
    },
    {
      "stepId": "coding-base-case-ts",
      "mentorSays": "Handle base case (null root).",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-helper-start-ts"
    },
    {
      "stepId": "coding-helper-start-ts",
      "mentorSays": "Create helper function isMirror.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-helper-base-ts"
    },
    {
      "stepId": "coding-helper-base-ts",
      "mentorSays": "Handle base cases in helper.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-helper-values-ts"
    },
    {
      "stepId": "coding-helper-values-ts",
      "mentorSays": "Check if values match.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-helper-recursive-ts"
    },
    {
      "stepId": "coding-helper-recursive-ts",
      "mentorSays": "Recursively check mirror symmetry.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-call-helper-ts"
    },
    {
      "stepId": "coding-call-helper-ts",
      "mentorSays": "Call helper with root.left and root.right.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [1, 2, 2, 3, 4, 4, 3]\nExpected: true (symmetric)\n\n**Test 2:** root = [1, 2, 2, null, 3, null, 3]\nExpected: false (not symmetric)\n\n**Test 3:** root = [1, 2, 2, null, 3, 3, null]\nExpected: true (symmetric)\n\n**Test 4:** root = null\nExpected: true (empty tree is symmetric)\n\n**Test 5:** root = [1]\nExpected: true (single node is symmetric)\n\n**Test 6:** root = [1, 2, 2, 2, null, 2]\nExpected: false (not symmetric)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,2,2,3,4,4,3] â†’ true\nTest 2: [1,2,2,null,3,null,3] â†’ false\nTest 3: [1,2,2,null,3,3,null] â†’ true\nTest 4: null â†’ true\nTest 5: [1] â†’ true\nTest 6: [1,2,2,2,null,2] â†’ false",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "final",
      "mentorSays": "ðŸŽ‰ Well done! You've successfully implemented the Symmetric Tree solution!\n\n**Time Complexity:** O(n)\n- We visit each node exactly once\n- n is the number of nodes in the tree\n\n**Space Complexity:** O(h)\n- The recursion stack uses space proportional to the height of the tree\n- In the worst case (skewed tree), h = n, so O(n)\n- In the best case (balanced tree), h = log n, so O(log n)\n\n**Key Takeaways:**\n1. **Recursive approach**: Check if left and right subtrees are mirror images\n2. **Helper function**: Use isMirror to compare two subtrees mirror-wise\n3. **Mirror comparison**: left.left mirrors right.right, left.right mirrors right.left\n4. **Base cases**: Both null = true, one null = false\n5. **Different from same tree**: Mirror symmetry is different from identical trees!\n\n**Related Practice Problems:**\n- Same Tree (LeetCode #100) - check if trees are identical\n- Invert Binary Tree (LeetCode #226) - invert the tree\n- Maximum Depth of Binary Tree (LeetCode #104) - similar recursive pattern\n\nKeep practicing tree problems - they're fundamental for interviews!",
      "action": "continue"
    }
  ]
}