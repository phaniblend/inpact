{
  "id": "permutation-in-string",
  "title": "Permutation in String",
  "pattern": "sliding-window",
  "difficulty": "medium",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what it means for a string to contain a permutation of another string\n2. Use a fixed-size sliding window to track character frequencies\n3. Explain why window expansion and contraction work for this problem\n4. Implement the solution step by step in multiple languages\n5. Analyze time and space complexity confidently",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "You are given two strings:\n- s1 (the pattern)\n- s2 (the text)\n\nYour task is to check whether s2 contains any permutation of s1.\n\nA permutation means:\n- Same characters\n- Same counts\n- Order does NOT matter\n\nExample 1:\ns1 = \"ab\"\ns2 = \"eidbaooo\"\n\nDoes s2 contain any permutation of \"ab\"?\nYes.\n\nWhy?\nBecause the substring \"ba\" exists inside s2:\n\ne i d [b a] o o o\n\n\"ba\" is a permutation of \"ab\".\n\nExample 2:\ns1 = \"ab\"\ns2 = \"eidboaoo\"\n\nHere, no substring of length 2 has both 'a' and 'b'.\nSo the answer is false.\n\nImportant observations:\n- The substring length must be exactly equal to s1.length\n- Character counts must match exactly\n- Order is irrelevant",
      "example": "Example Walkthrough:\n\ns1 = \"abc\"\ns2 = \"cbaebabacd\"\n\nWindow size = 3 (length of s1)\n\nCheck substrings:\n\"cba\" → counts match → permutation found → true\n\nWe do NOT need to check the rest once found.",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Pause for a moment and think:\n\nHow would YOU solve this problem?\n\n- Would you generate all permutations of s1?\n- Would you check every substring of s2?\n- Can you reuse work instead of recalculating every time?\n\nChoose an approach that feels natural to you.",
      "choices": [
        {
          "label": "Generate all permutations of s1 and check each one",
          "next": "explore-approach-bruteforce"
        },
        {
          "label": "Check every substring of s2 using sorting",
          "next": "explore-approach-sorting"
        },
        {
          "label": "Use sliding window with character frequency",
          "next": "explore-approach-sliding-window"
        }
      ]
    },
    {
      "stepId": "explore-approach-bruteforce",
      "mentorSays": "This approach sounds reasonable at first:\n\n- Generate all permutations of s1\n- Check if any permutation exists in s2\n\nBut there is a problem.\n\nIf s1 has length n, the number of permutations is n!.\nEven for n = 10, that is already too large.\n\nThis approach is not scalable and will timeout.\n\nWe need something more efficient.",
      "action": "continue",
      "next": "explore-approach-sorting"
    },
    {
      "stepId": "explore-approach-sorting",
      "mentorSays": "Another idea is:\n\n- Sort s1\n- For every substring of s2 with length = s1.length:\n  - Sort it\n  - Compare with sorted s1\n\nThis works logically.\n\nBut sorting every substring costs O(k log k), and there are O(n) substrings.\n\nOverall complexity becomes too slow.\n\nWe can do better by avoiding repeated sorting.",
      "action": "continue",
      "next": "explore-approach-sliding-window"
    },
    {
      "stepId": "explore-approach-sliding-window",
      "mentorSays": "This is the optimal and intended solution.\n\nKey idea:\n- A permutation is defined by character counts\n- If two strings have the same character frequency, they are permutations\n\nAlgorithm:\n1. Create a frequency map for s1\n2. Use a sliding window of size s1.length over s2\n3. Maintain a frequency map for the current window\n4. If both maps match → permutation found\n\nWhy sliding window works:\n- Window size is fixed\n- When the window moves:\n  - One character enters\n  - One character leaves\n- We update counts incrementally instead of recomputing\n\nThis gives O(n) time complexity.",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Great choice.\n\nNow let's implement the solution step by step.\nWhich language would you like to use?",
      "choices": [
        { "label": "JavaScript", "next": "variable-check-js" },
        { "label": "Python", "next": "variable-check-python" },
        { "label": "Java", "next": "variable-check-java" },
        { "label": "C++", "next": "variable-check-cpp" },
        { "label": "TypeScript", "next": "variable-check-ts" }
      ]
    },

    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding in JavaScript: do you know what a variable is?",
      "choices": [
        { "label": "Yes", "next": "function-check-js" },
        { "label": "No", "next": "variable-explanation-js" }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable stores a value so we can reuse it later.\n\nIn this problem, we'll store:\n- frequency maps\n- window pointers\n- counts\n\nVariables allow us to track state as the window moves.",
      "example": "let need = {};\nlet window = {};\nlet left = 0;\nlet matched = 0;",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Do you understand what a function is in JavaScript?",
      "choices": [
        { "label": "Yes", "next": "parameter-check-js" },
        { "label": "No", "next": "function-explanation-js" }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function groups logic into a reusable unit.\n\nWe'll write a function that:\n- Takes s1 and s2 as input\n- Returns true or false",
      "example": "function checkInclusion(s1, s2) {\n  return true;\n}",
      "action": "continue",
      "next": "parameter-check-js"
    },
    {
      "stepId": "parameter-check-js",
      "mentorSays": "Do you know what function parameters are?",
      "choices": [
        { "label": "Yes", "next": "array-check-js" },
        { "label": "No", "next": "parameter-explanation-js" }
      ]
    },
    {
      "stepId": "parameter-explanation-js",
      "mentorSays": "Parameters are inputs to a function.\n\nHere:\n- s1 is the pattern string\n- s2 is the text string",
      "example": "checkInclusion(\"ab\", \"eidbaooo\");",
      "action": "continue",
      "next": "array-check-js"
    },
    {
      "stepId": "array-check-js",
      "mentorSays": "Do you know how arrays and objects are used to store collections?",
      "choices": [
        { "label": "Yes", "next": "loop-check-js" },
        { "label": "No", "next": "array-explanation-js" }
      ]
    },
    {
      "stepId": "array-explanation-js",
      "mentorSays": "We use objects as frequency maps.\n\nEach key is a character.\nEach value is how many times it appears.",
      "example": "let need = { a: 1, b: 1 };\nlet window = { e: 1, i: 1 };",
      "action": "continue",
      "next": "loop-check-js"
    },
    {
      "stepId": "loop-check-js",
      "mentorSays": "Are you comfortable using loops?",
      "choices": [
        { "label": "Yes", "next": "coding-start-js" },
        { "label": "No", "next": "loop-explanation-js" }
      ]
    },
    {
      "stepId": "loop-explanation-js",
      "mentorSays": "Loops let us process each character step by step.\n\nWe'll loop over s2 once while sliding the window.",
      "example": "for (let i = 0; i < s2.length; i++) {\n  // process s2[i]\n}",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Let's start coding.\n\nWe define the function and handle a quick edge case.",
      "example": "function checkInclusion(s1, s2) {\n  if (s1.length > s2.length) return false;\n\n  // we'll fill the rest next\n}",
      "action": "continue",
      "next": "coding-build-s1-freq-js"
    },
    {
      "stepId": "coding-build-s1-freq-js",
      "mentorSays": "First, build the frequency map for s1.\n\nThis defines what a valid permutation looks like.",
      "example": "function checkInclusion(s1, s2) {\n  if (s1.length > s2.length) return false;\n\n  let need = {};\n  for (let ch of s1) {\n    need[ch] = (need[ch] || 0) + 1;\n  }\n\n  // next: build window state\n}",
      "action": "continue",
      "next": "coding-init-window-js"
    },
    {
      "stepId": "coding-init-window-js",
      "mentorSays": "Now initialize the sliding window state.",
      "example": "function checkInclusion(s1, s2) {\n  if (s1.length > s2.length) return false;\n\n  let need = {};\n  for (let ch of s1) {\n    need[ch] = (need[ch] || 0) + 1;\n  }\n\n  let window = {};\n  let left = 0;\n  let matched = 0;\n\n  // next: expand with right pointer\n}",
      "action": "continue",
      "next": "coding-expand-window-js"
    },
    {
      "stepId": "coding-expand-window-js",
      "mentorSays": "We expand the window by moving the right pointer.\n\nEach new character updates the window frequency.",
      "example": "function checkInclusion(s1, s2) {\n  if (s1.length > s2.length) return false;\n\n  let need = {};\n  for (let ch of s1) {\n    need[ch] = (need[ch] || 0) + 1;\n  }\n\n  let window = {};\n  let left = 0;\n  let matched = 0;\n\n  for (let right = 0; right < s2.length; right++) {\n    let ch = s2[right];\n    window[ch] = (window[ch] || 0) + 1;\n\n    // next: update matched for this character\n  }\n\n  return false;\n}",
      "action": "continue",
      "next": "coding-check-match-js"
    },
    {
      "stepId": "coding-check-match-js",
      "mentorSays": "After adding a character, check if it satisfies the needed frequency.",
      "example": "function checkInclusion(s1, s2) {\n  if (s1.length > s2.length) return false;\n\n  let need = {};\n  for (let ch of s1) {\n    need[ch] = (need[ch] || 0) + 1;\n  }\n\n  let window = {};\n  let left = 0;\n  let matched = 0;\n\n  for (let right = 0; right < s2.length; right++) {\n    let ch = s2[right];\n    window[ch] = (window[ch] || 0) + 1;\n\n    if (need[ch] && window[ch] === need[ch]) {\n      matched++;\n    }\n\n    // next: shrink when window is too big\n  }\n\n  return false;\n}",
      "action": "continue",
      "next": "coding-shrink-window-js"
    },
    {
      "stepId": "coding-shrink-window-js",
      "mentorSays": "If window size exceeds s1 length, shrink from the left.",
      "example": "function checkInclusion(s1, s2) {\n  if (s1.length > s2.length) return false;\n\n  let need = {};\n  for (let ch of s1) {\n    need[ch] = (need[ch] || 0) + 1;\n  }\n\n  let window = {};\n  let left = 0;\n  let matched = 0;\n\n  for (let right = 0; right < s2.length; right++) {\n    let ch = s2[right];\n    window[ch] = (window[ch] || 0) + 1;\n\n    if (need[ch] && window[ch] === need[ch]) {\n      matched++;\n    }\n\n    while (right - left + 1 > s1.length) {\n      let leftChar = s2[left];\n      if (need[leftChar] && window[leftChar] === need[leftChar]) {\n        matched--;\n      }\n      window[leftChar]--;\n      left++;\n    }\n\n    // next: if all matched, return true\n  }\n\n  return false;\n}",
      "action": "continue",
      "next": "coding-found-permutation-js"
    },
    {
      "stepId": "coding-found-permutation-js",
      "mentorSays": "If all characters match, we found a permutation.",
      "example": "function checkInclusion(s1, s2) {\n  if (s1.length > s2.length) return false;\n\n  let need = {};\n  for (let ch of s1) {\n    need[ch] = (need[ch] || 0) + 1;\n  }\n\n  let window = {};\n  let left = 0;\n  let matched = 0;\n\n  for (let right = 0; right < s2.length; right++) {\n    let ch = s2[right];\n    window[ch] = (window[ch] || 0) + 1;\n\n    if (need[ch] && window[ch] === need[ch]) {\n      matched++;\n    }\n\n    while (right - left + 1 > s1.length) {\n      let leftChar = s2[left];\n      if (need[leftChar] && window[leftChar] === need[leftChar]) {\n        matched--;\n      }\n      window[leftChar]--;\n      left++;\n    }\n\n    if (matched === Object.keys(need).length) {\n      return true;\n    }\n  }\n\n  return false;\n}",
      "action": "continue",
      "next": "coding-return-js"
    },
    {
      "stepId": "coding-return-js",
      "mentorSays": "If the loop finishes without a match, return false.",
      "example": "function checkInclusion(s1, s2) {\n  if (s1.length > s2.length) return false;\n\n  let need = {};\n  for (let ch of s1) {\n    need[ch] = (need[ch] || 0) + 1;\n  }\n\n  let window = {};\n  let left = 0;\n  let matched = 0;\n\n  for (let right = 0; right < s2.length; right++) {\n    let ch = s2[right];\n    window[ch] = (window[ch] || 0) + 1;\n\n    if (need[ch] && window[ch] === need[ch]) {\n      matched++;\n    }\n\n    while (right - left + 1 > s1.length) {\n      let leftChar = s2[left];\n      if (need[leftChar] && window[leftChar] === need[leftChar]) {\n        matched--;\n      }\n      window[leftChar]--;\n      left++;\n    }\n\n    if (matched === Object.keys(need).length) {\n      return true;\n    }\n  }\n\n  return false;\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Test your implementation with edge cases:\n\n1. s1=\"ab\", s2=\"eidbaooo\" → true\n2. s1=\"ab\", s2=\"eidboaoo\" → false\n3. s1=\"a\", s2=\"a\" → true\n4. s1=\"abc\", s2=\"bbbca\" → true\n5. s1=\"abcd\", s2=\"abc\" → false",
      "example": "console.log(checkInclusion(\"ab\", \"eidbaooo\")); // true\nconsole.log(checkInclusion(\"ab\", \"eidboaoo\")); // false\nconsole.log(checkInclusion(\"a\", \"a\")); // true\nconsole.log(checkInclusion(\"abc\", \"bbbca\")); // true\nconsole.log(checkInclusion(\"abcd\", \"abc\")); // false",
      "action": "continue",
      "next": "final"
    },

    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding in Python: do you know what a variable is?",
      "choices": [
        { "label": "Yes", "next": "function-check-python" },
        { "label": "No", "next": "variable-explanation-python" }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable stores a value so we can reuse it later.\n\nIn this problem, we'll store:\n- frequency maps\n- window pointers\n- counts\n\nVariables allow us to track state as the window moves.",
      "example": "need = {}\nwindow = {}\nleft = 0\nmatched = 0",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Do you understand what a function is in Python?",
      "choices": [
        { "label": "Yes", "next": "parameter-check-python" },
        { "label": "No", "next": "function-explanation-python" }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function groups logic into a reusable unit.\n\nWe'll write a function that:\n- Takes s1 and s2 as input\n- Returns true or false",
      "example": "def check_inclusion(s1, s2):\n    return True",
      "action": "continue",
      "next": "parameter-check-python"
    },
    {
      "stepId": "parameter-check-python",
      "mentorSays": "Do you know what function parameters are?",
      "choices": [
        { "label": "Yes", "next": "array-check-python" },
        { "label": "No", "next": "parameter-explanation-python" }
      ]
    },
    {
      "stepId": "parameter-explanation-python",
      "mentorSays": "Parameters are inputs to a function.\n\nHere:\n- s1 is the pattern string\n- s2 is the text string",
      "example": "check_inclusion(\"ab\", \"eidbaooo\")",
      "action": "continue",
      "next": "array-check-python"
    },
    {
      "stepId": "array-check-python",
      "mentorSays": "Do you know how arrays and objects are used to store collections?",
      "choices": [
        { "label": "Yes", "next": "loop-check-python" },
        { "label": "No", "next": "array-explanation-python" }
      ]
    },
    {
      "stepId": "array-explanation-python",
      "mentorSays": "We use dictionaries as frequency maps.\n\nEach key is a character.\nEach value is how many times it appears.",
      "example": "need = {\"a\": 1, \"b\": 1}\nwindow = {\"e\": 1, \"i\": 1}",
      "action": "continue",
      "next": "loop-check-python"
    },
    {
      "stepId": "loop-check-python",
      "mentorSays": "Are you comfortable using loops?",
      "choices": [
        { "label": "Yes", "next": "coding-start-python" },
        { "label": "No", "next": "loop-explanation-python" }
      ]
    },
    {
      "stepId": "loop-explanation-python",
      "mentorSays": "Loops let us process each character step by step.\n\nWe'll loop over s2 once while sliding the window.",
      "example": "for i in range(len(s2)):\n    # process s2[i]\n    pass",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Let's start coding.\n\nWe define the function and handle a quick edge case.",
      "example": "def checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n\n    # we'll fill the rest next",
      "action": "continue",
      "next": "coding-build-s1-freq-python"
    },
    {
      "stepId": "coding-build-s1-freq-python",
      "mentorSays": "First, build the frequency map for s1.\n\nThis defines what a valid permutation looks like.",
      "example": "def checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n\n    need = {}\n    for ch in s1:\n        need[ch] = need.get(ch, 0) + 1\n\n    # next: build window state",
      "action": "continue",
      "next": "coding-init-window-python"
    },
    {
      "stepId": "coding-init-window-python",
      "mentorSays": "Now initialize the sliding window state.",
      "example": "def checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n\n    need = {}\n    for ch in s1:\n        need[ch] = need.get(ch, 0) + 1\n\n    window = {}\n    left = 0\n    matched = 0\n\n    # next: expand with right pointer",
      "action": "continue",
      "next": "coding-expand-window-python"
    },
    {
      "stepId": "coding-expand-window-python",
      "mentorSays": "We expand the window by moving the right pointer.\n\nEach new character updates the window frequency.",
      "example": "def checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n\n    need = {}\n    for ch in s1:\n        need[ch] = need.get(ch, 0) + 1\n\n    window = {}\n    left = 0\n    matched = 0\n\n    for right in range(len(s2)):\n        ch = s2[right]\n        window[ch] = window.get(ch, 0) + 1\n\n        # next: update matched for this character\n\n    return False",
      "action": "continue",
      "next": "coding-check-match-python"
    },
    {
      "stepId": "coding-check-match-python",
      "mentorSays": "After adding a character, check if it satisfies the needed frequency.",
      "example": "def checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n\n    need = {}\n    for ch in s1:\n        need[ch] = need.get(ch, 0) + 1\n\n    window = {}\n    left = 0\n    matched = 0\n\n    for right in range(len(s2)):\n        ch = s2[right]\n        window[ch] = window.get(ch, 0) + 1\n\n        if ch in need and window[ch] == need[ch]:\n            matched += 1\n\n        # next: shrink when window is too big\n\n    return False",
      "action": "continue",
      "next": "coding-shrink-window-python"
    },
    {
      "stepId": "coding-shrink-window-python",
      "mentorSays": "If window size exceeds s1 length, shrink from the left.",
      "example": "def checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n\n    need = {}\n    for ch in s1:\n        need[ch] = need.get(ch, 0) + 1\n\n    window = {}\n    left = 0\n    matched = 0\n\n    for right in range(len(s2)):\n        ch = s2[right]\n        window[ch] = window.get(ch, 0) + 1\n\n        if ch in need and window[ch] == need[ch]:\n            matched += 1\n\n        while right - left + 1 > len(s1):\n            left_char = s2[left]\n            if left_char in need and window.get(left_char, 0) == need[left_char]:\n                matched -= 1\n            window[left_char] = window.get(left_char, 0) - 1\n            left += 1\n\n        # next: if all matched, return true\n\n    return False",
      "action": "continue",
      "next": "coding-found-permutation-python"
    },
    {
      "stepId": "coding-found-permutation-python",
      "mentorSays": "If all characters match, we found a permutation.",
      "example": "def checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n\n    need = {}\n    for ch in s1:\n        need[ch] = need.get(ch, 0) + 1\n\n    window = {}\n    left = 0\n    matched = 0\n\n    for right in range(len(s2)):\n        ch = s2[right]\n        window[ch] = window.get(ch, 0) + 1\n\n        if ch in need and window[ch] == need[ch]:\n            matched += 1\n\n        while right - left + 1 > len(s1):\n            left_char = s2[left]\n            if left_char in need and window.get(left_char, 0) == need[left_char]:\n                matched -= 1\n            window[left_char] = window.get(left_char, 0) - 1\n            left += 1\n\n        if matched == len(need):\n            return True\n\n    return False",
      "action": "continue",
      "next": "coding-return-python"
    },
    {
      "stepId": "coding-return-python",
      "mentorSays": "If the loop finishes without a match, return false.",
      "example": "def checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n\n    need = {}\n    for ch in s1:\n        need[ch] = need.get(ch, 0) + 1\n\n    window = {}\n    left = 0\n    matched = 0\n\n    for right in range(len(s2)):\n        ch = s2[right]\n        window[ch] = window.get(ch, 0) + 1\n\n        if ch in need and window[ch] == need[ch]:\n            matched += 1\n\n        while right - left + 1 > len(s1):\n            left_char = s2[left]\n            if left_char in need and window.get(left_char, 0) == need[left_char]:\n                matched -= 1\n            window[left_char] = window.get(left_char, 0) - 1\n            left += 1\n\n        if matched == len(need):\n            return True\n\n    return False",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Test your implementation with edge cases:\n\n1. s1=\"ab\", s2=\"eidbaooo\" → true\n2. s1=\"ab\", s2=\"eidboaoo\" → false\n3. s1=\"a\", s2=\"a\" → true\n4. s1=\"abc\", s2=\"bbbca\" → true\n5. s1=\"abcd\", s2=\"abc\" → false",
      "example": "print(checkInclusion(\"ab\", \"eidbaooo\"))  # True\nprint(checkInclusion(\"ab\", \"eidboaoo\"))  # False\nprint(checkInclusion(\"a\", \"a\"))          # True\nprint(checkInclusion(\"abc\", \"bbbca\"))     # True\nprint(checkInclusion(\"abcd\", \"abc\"))      # False",
      "action": "continue",
      "next": "final"
    },

    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding in Java: do you know what a variable is?",
      "choices": [
        { "label": "Yes", "next": "function-check-java" },
        { "label": "No", "next": "variable-explanation-java" }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable stores a value so we can reuse it later.\n\nIn this problem, we'll store:\n- frequency maps\n- window pointers\n- counts\n\nVariables allow us to track state as the window moves.",
      "example": "Map<Character, Integer> need = new HashMap<>();\nMap<Character, Integer> window = new HashMap<>();\nint left = 0;\nint matched = 0;",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Do you understand what a function is in Java?",
      "choices": [
        { "label": "Yes", "next": "parameter-check-java" },
        { "label": "No", "next": "function-explanation-java" }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A function groups logic into a reusable unit.\n\nWe'll write a function that:\n- Takes s1 and s2 as input\n- Returns true or false",
      "example": "public boolean checkInclusion(String s1, String s2) {\n    return true;\n}",
      "action": "continue",
      "next": "parameter-check-java"
    },
    {
      "stepId": "parameter-check-java",
      "mentorSays": "Do you know what function parameters are?",
      "choices": [
        { "label": "Yes", "next": "array-check-java" },
        { "label": "No", "next": "parameter-explanation-java" }
      ]
    },
    {
      "stepId": "parameter-explanation-java",
      "mentorSays": "Parameters are inputs to a function.\n\nHere:\n- s1 is the pattern string\n- s2 is the text string",
      "example": "checkInclusion(\"ab\", \"eidbaooo\");",
      "action": "continue",
      "next": "array-check-java"
    },
    {
      "stepId": "array-check-java",
      "mentorSays": "Do you know how arrays and objects are used to store collections?",
      "choices": [
        { "label": "Yes", "next": "loop-check-java" },
        { "label": "No", "next": "array-explanation-java" }
      ]
    },
    {
      "stepId": "array-explanation-java",
      "mentorSays": "We use maps as frequency maps.\n\nEach key is a character.\nEach value is how many times it appears.",
      "example": "Map<Character, Integer> need = new HashMap<>();\nneed.put('a', 1);\nneed.put('b', 1);",
      "action": "continue",
      "next": "loop-check-java"
    },
    {
      "stepId": "loop-check-java",
      "mentorSays": "Are you comfortable using loops?",
      "choices": [
        { "label": "Yes", "next": "coding-start-java" },
        { "label": "No", "next": "loop-explanation-java" }
      ]
    },
    {
      "stepId": "loop-explanation-java",
      "mentorSays": "Loops let us process each character step by step.\n\nWe'll loop over s2 once while sliding the window.",
      "example": "for (int i = 0; i < s2.length(); i++) {\n    // process s2.charAt(i)\n}",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Let's start coding.\n\nWe define the function and handle a quick edge case.",
      "example": "public boolean checkInclusion(String s1, String s2) {\n    if (s1.length() > s2.length()) return false;\n\n    // we'll fill the rest next\n}",
      "action": "continue",
      "next": "coding-build-s1-freq-java"
    },
    {
      "stepId": "coding-build-s1-freq-java",
      "mentorSays": "First, build the frequency map for s1.\n\nThis defines what a valid permutation looks like.",
      "example": "public boolean checkInclusion(String s1, String s2) {\n    if (s1.length() > s2.length()) return false;\n\n    Map<Character, Integer> need = new HashMap<>();\n    for (char ch : s1.toCharArray()) {\n        need.put(ch, need.getOrDefault(ch, 0) + 1);\n    }\n\n    // next: build window state\n}",
      "action": "continue",
      "next": "coding-init-window-java"
    },
    {
      "stepId": "coding-init-window-java",
      "mentorSays": "Now initialize the sliding window state.",
      "example": "public boolean checkInclusion(String s1, String s2) {\n    if (s1.length() > s2.length()) return false;\n\n    Map<Character, Integer> need = new HashMap<>();\n    for (char ch : s1.toCharArray()) {\n        need.put(ch, need.getOrDefault(ch, 0) + 1);\n    }\n\n    Map<Character, Integer> window = new HashMap<>();\n    int left = 0;\n    int matched = 0;\n\n    // next: expand with right pointer\n}",
      "action": "continue",
      "next": "coding-expand-window-java"
    },
    {
      "stepId": "coding-expand-window-java",
      "mentorSays": "We expand the window by moving the right pointer.\n\nEach new character updates the window frequency.",
      "example": "public boolean checkInclusion(String s1, String s2) {\n    if (s1.length() > s2.length()) return false;\n\n    Map<Character, Integer> need = new HashMap<>();\n    for (char ch : s1.toCharArray()) {\n        need.put(ch, need.getOrDefault(ch, 0) + 1);\n    }\n\n    Map<Character, Integer> window = new HashMap<>();\n    int left = 0;\n    int matched = 0;\n\n    for (int right = 0; right < s2.length(); right++) {\n        char ch = s2.charAt(right);\n        window.put(ch, window.getOrDefault(ch, 0) + 1);\n\n        // next: update matched for this character\n    }\n\n    return false;\n}",
      "action": "continue",
      "next": "coding-check-match-java"
    },
    {
      "stepId": "coding-check-match-java",
      "mentorSays": "After adding a character, check if it satisfies the needed frequency.",
      "example": "public boolean checkInclusion(String s1, String s2) {\n    if (s1.length() > s2.length()) return false;\n\n    Map<Character, Integer> need = new HashMap<>();\n    for (char ch : s1.toCharArray()) {\n        need.put(ch, need.getOrDefault(ch, 0) + 1);\n    }\n\n    Map<Character, Integer> window = new HashMap<>();\n    int left = 0;\n    int matched = 0;\n\n    for (int right = 0; right < s2.length(); right++) {\n        char ch = s2.charAt(right);\n        window.put(ch, window.getOrDefault(ch, 0) + 1);\n\n        if (need.containsKey(ch) && window.get(ch).equals(need.get(ch))) {\n            matched++;\n        }\n\n        // next: shrink when window is too big\n    }\n\n    return false;\n}",
      "action": "continue",
      "next": "coding-shrink-window-java"
    },
    {
      "stepId": "coding-shrink-window-java",
      "mentorSays": "If window size exceeds s1 length, shrink from the left.",
      "example": "public boolean checkInclusion(String s1, String s2) {\n    if (s1.length() > s2.length()) return false;\n\n    Map<Character, Integer> need = new HashMap<>();\n    for (char ch : s1.toCharArray()) {\n        need.put(ch, need.getOrDefault(ch, 0) + 1);\n    }\n\n    Map<Character, Integer> window = new HashMap<>();\n    int left = 0;\n    int matched = 0;\n\n    for (int right = 0; right < s2.length(); right++) {\n        char ch = s2.charAt(right);\n        window.put(ch, window.getOrDefault(ch, 0) + 1);\n\n        if (need.containsKey(ch) && window.get(ch).equals(need.get(ch))) {\n            matched++;\n        }\n\n        while (right - left + 1 > s1.length()) {\n            char leftChar = s2.charAt(left);\n            if (need.containsKey(leftChar) && window.get(leftChar).equals(need.get(leftChar))) {\n                matched--;\n            }\n            window.put(leftChar, window.get(leftChar) - 1);\n            left++;\n        }\n\n        // next: if all matched, return true\n    }\n\n    return false;\n}",
      "action": "continue",
      "next": "coding-found-permutation-java"
    },
    {
      "stepId": "coding-found-permutation-java",
      "mentorSays": "If all characters match, we found a permutation.",
      "example": "public boolean checkInclusion(String s1, String s2) {\n    if (s1.length() > s2.length()) return false;\n\n    Map<Character, Integer> need = new HashMap<>();\n    for (char ch : s1.toCharArray()) {\n        need.put(ch, need.getOrDefault(ch, 0) + 1);\n    }\n\n    Map<Character, Integer> window = new HashMap<>();\n    int left = 0;\n    int matched = 0;\n\n    for (int right = 0; right < s2.length(); right++) {\n        char ch = s2.charAt(right);\n        window.put(ch, window.getOrDefault(ch, 0) + 1);\n\n        if (need.containsKey(ch) && window.get(ch).equals(need.get(ch))) {\n            matched++;\n        }\n\n        while (right - left + 1 > s1.length()) {\n            char leftChar = s2.charAt(left);\n            if (need.containsKey(leftChar) && window.get(leftChar).equals(need.get(leftChar))) {\n                matched--;\n            }\n            window.put(leftChar, window.get(leftChar) - 1);\n            left++;\n        }\n\n        if (matched == need.size()) {\n            return true;\n        }\n    }\n\n    return false;\n}",
      "action": "continue",
      "next": "coding-return-java"
    },
    {
      "stepId": "coding-return-java",
      "mentorSays": "If the loop finishes without a match, return false.",
      "example": "public boolean checkInclusion(String s1, String s2) {\n    if (s1.length() > s2.length()) return false;\n\n    Map<Character, Integer> need = new HashMap<>();\n    for (char ch : s1.toCharArray()) {\n        need.put(ch, need.getOrDefault(ch, 0) + 1);\n    }\n\n    Map<Character, Integer> window = new HashMap<>();\n    int left = 0;\n    int matched = 0;\n\n    for (int right = 0; right < s2.length(); right++) {\n        char ch = s2.charAt(right);\n        window.put(ch, window.getOrDefault(ch, 0) + 1);\n\n        if (need.containsKey(ch) && window.get(ch).equals(need.get(ch))) {\n            matched++;\n        }\n\n        while (right - left + 1 > s1.length()) {\n            char leftChar = s2.charAt(left);\n            if (need.containsKey(leftChar) && window.get(leftChar).equals(need.get(leftChar))) {\n                matched--;\n            }\n            window.put(leftChar, window.get(leftChar) - 1);\n            left++;\n        }\n\n        if (matched == need.size()) {\n            return true;\n        }\n    }\n\n    return false;\n}",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Test your implementation with edge cases:\n\n1. s1=\"ab\", s2=\"eidbaooo\" → true\n2. s1=\"ab\", s2=\"eidboaoo\" → false\n3. s1=\"a\", s2=\"a\" → true\n4. s1=\"abc\", s2=\"bbbca\" → true\n5. s1=\"abcd\", s2=\"abc\" → false",
      "example": "System.out.println(checkInclusion(\"ab\", \"eidbaooo\")); // true\nSystem.out.println(checkInclusion(\"ab\", \"eidboaoo\")); // false\nSystem.out.println(checkInclusion(\"a\", \"a\"));         // true\nSystem.out.println(checkInclusion(\"abc\", \"bbbca\"));    // true\nSystem.out.println(checkInclusion(\"abcd\", \"abc\"));     // false",
      "action": "continue",
      "next": "final"
    },

    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding in C++: do you know what a variable is?",
      "choices": [
        { "label": "Yes", "next": "function-check-cpp" },
        { "label": "No", "next": "variable-explanation-cpp" }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable stores a value so we can reuse it later.\n\nIn this problem, we'll store:\n- frequency maps\n- window pointers\n- counts\n\nVariables allow us to track state as the window moves.",
      "example": "unordered_map<char, int> need;\nunordered_map<char, int> window;\nint left = 0;\nint matched = 0;",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Do you understand what a function is in C++?",
      "choices": [
        { "label": "Yes", "next": "parameter-check-cpp" },
        { "label": "No", "next": "function-explanation-cpp" }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function groups logic into a reusable unit.\n\nWe'll write a function that:\n- Takes s1 and s2 as input\n- Returns true or false",
      "example": "bool checkInclusion(string s1, string s2) {\n    return true;\n}",
      "action": "continue",
      "next": "parameter-check-cpp"
    },
    {
      "stepId": "parameter-check-cpp",
      "mentorSays": "Do you know what function parameters are?",
      "choices": [
        { "label": "Yes", "next": "array-check-cpp" },
        { "label": "No", "next": "parameter-explanation-cpp" }
      ]
    },
    {
      "stepId": "parameter-explanation-cpp",
      "mentorSays": "Parameters are inputs to a function.\n\nHere:\n- s1 is the pattern string\n- s2 is the text string",
      "example": "checkInclusion(\"ab\", \"eidbaooo\");",
      "action": "continue",
      "next": "array-check-cpp"
    },
    {
      "stepId": "array-check-cpp",
      "mentorSays": "Do you know how arrays and objects are used to store collections?",
      "choices": [
        { "label": "Yes", "next": "loop-check-cpp" },
        { "label": "No", "next": "array-explanation-cpp" }
      ]
    },
    {
      "stepId": "array-explanation-cpp",
      "mentorSays": "We use hash maps as frequency maps.\n\nEach key is a character.\nEach value is how many times it appears.",
      "example": "unordered_map<char,int> need;\nneed['a'] = 1;\nneed['b'] = 1;",
      "action": "continue",
      "next": "loop-check-cpp"
    },
    {
      "stepId": "loop-check-cpp",
      "mentorSays": "Are you comfortable using loops?",
      "choices": [
        { "label": "Yes", "next": "coding-start-cpp" },
        { "label": "No", "next": "loop-explanation-cpp" }
      ]
    },
    {
      "stepId": "loop-explanation-cpp",
      "mentorSays": "Loops let us process each character step by step.\n\nWe'll loop over s2 once while sliding the window.",
      "example": "for (int i = 0; i < (int)s2.size(); i++) {\n    // process s2[i]\n}",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Let's start coding.\n\nWe define the function and handle a quick edge case.",
      "example": "bool checkInclusion(string s1, string s2) {\n    if (s1.size() > s2.size()) return false;\n\n    // we'll fill the rest next\n}",
      "action": "continue",
      "next": "coding-build-s1-freq-cpp"
    },
    {
      "stepId": "coding-build-s1-freq-cpp",
      "mentorSays": "First, build the frequency map for s1.\n\nThis defines what a valid permutation looks like.",
      "example": "bool checkInclusion(string s1, string s2) {\n    if (s1.size() > s2.size()) return false;\n\n    unordered_map<char, int> need;\n    for (char ch : s1) {\n        need[ch]++;\n    }\n\n    // next: build window state\n}",
      "action": "continue",
      "next": "coding-init-window-cpp"
    },
    {
      "stepId": "coding-init-window-cpp",
      "mentorSays": "Now initialize the sliding window state.",
      "example": "bool checkInclusion(string s1, string s2) {\n    if (s1.size() > s2.size()) return false;\n\n    unordered_map<char, int> need;\n    for (char ch : s1) {\n        need[ch]++;\n    }\n\n    unordered_map<char, int> window;\n    int left = 0;\n    int matched = 0;\n\n    // next: expand with right pointer\n}",
      "action": "continue",
      "next": "coding-expand-window-cpp"
    },
    {
      "stepId": "coding-expand-window-cpp",
      "mentorSays": "We expand the window by moving the right pointer.\n\nEach new character updates the window frequency.",
      "example": "bool checkInclusion(string s1, string s2) {\n    if (s1.size() > s2.size()) return false;\n\n    unordered_map<char, int> need;\n    for (char ch : s1) {\n        need[ch]++;\n    }\n\n    unordered_map<char, int> window;\n    int left = 0;\n    int matched = 0;\n\n    for (int right = 0; right < (int)s2.size(); right++) {\n        char ch = s2[right];\n        window[ch]++;\n\n        // next: update matched for this character\n    }\n\n    return false;\n}",
      "action": "continue",
      "next": "coding-check-match-cpp"
    },
    {
      "stepId": "coding-check-match-cpp",
      "mentorSays": "After adding a character, check if it satisfies the needed frequency.",
      "example": "bool checkInclusion(string s1, string s2) {\n    if (s1.size() > s2.size()) return false;\n\n    unordered_map<char, int> need;\n    for (char ch : s1) {\n        need[ch]++;\n    }\n\n    unordered_map<char, int> window;\n    int left = 0;\n    int matched = 0;\n\n    for (int right = 0; right < (int)s2.size(); right++) {\n        char ch = s2[right];\n        window[ch]++;\n\n        if (need.count(ch) && window[ch] == need[ch]) {\n            matched++;\n        }\n\n        // next: shrink when window is too big\n    }\n\n    return false;\n}",
      "action": "continue",
      "next": "coding-shrink-window-cpp"
    },
    {
      "stepId": "coding-shrink-window-cpp",
      "mentorSays": "If window size exceeds s1 length, shrink from the left.",
      "example": "bool checkInclusion(string s1, string s2) {\n    if (s1.size() > s2.size()) return false;\n\n    unordered_map<char, int> need;\n    for (char ch : s1) {\n        need[ch]++;\n    }\n\n    unordered_map<char, int> window;\n    int left = 0;\n    int matched = 0;\n\n    for (int right = 0; right < (int)s2.size(); right++) {\n        char ch = s2[right];\n        window[ch]++;\n\n        if (need.count(ch) && window[ch] == need[ch]) {\n            matched++;\n        }\n\n        while (right - left + 1 > (int)s1.size()) {\n            char leftChar = s2[left];\n            if (need.count(leftChar) && window[leftChar] == need[leftChar]) {\n                matched--;\n            }\n            window[leftChar]--;\n            left++;\n        }\n\n        // next: if all matched, return true\n    }\n\n    return false;\n}",
      "action": "continue",
      "next": "coding-found-permutation-cpp"
    },
    {
      "stepId": "coding-found-permutation-cpp",
      "mentorSays": "If all characters match, we found a permutation.",
      "example": "bool checkInclusion(string s1, string s2) {\n    if (s1.size() > s2.size()) return false;\n\n    unordered_map<char, int> need;\n    for (char ch : s1) {\n        need[ch]++;\n    }\n\n    unordered_map<char, int> window;\n    int left = 0;\n    int matched = 0;\n\n    for (int right = 0; right < (int)s2.size(); right++) {\n        char ch = s2[right];\n        window[ch]++;\n\n        if (need.count(ch) && window[ch] == need[ch]) {\n            matched++;\n        }\n\n        while (right - left + 1 > (int)s1.size()) {\n            char leftChar = s2[left];\n            if (need.count(leftChar) && window[leftChar] == need[leftChar]) {\n                matched--;\n            }\n            window[leftChar]--;\n            left++;\n        }\n\n        if (matched == (int)need.size()) {\n            return true;\n        }\n    }\n\n    return false;\n}",
      "action": "continue",
      "next": "coding-return-cpp"
    },
    {
      "stepId": "coding-return-cpp",
      "mentorSays": "If the loop finishes without a match, return false.",
      "example": "bool checkInclusion(string s1, string s2) {\n    if (s1.size() > s2.size()) return false;\n\n    unordered_map<char, int> need;\n    for (char ch : s1) {\n        need[ch]++;\n    }\n\n    unordered_map<char, int> window;\n    int left = 0;\n    int matched = 0;\n\n    for (int right = 0; right < (int)s2.size(); right++) {\n        char ch = s2[right];\n        window[ch]++;\n\n        if (need.count(ch) && window[ch] == need[ch]) {\n            matched++;\n        }\n\n        while (right - left + 1 > (int)s1.size()) {\n            char leftChar = s2[left];\n            if (need.count(leftChar) && window[leftChar] == need[leftChar]) {\n                matched--;\n            }\n            window[leftChar]--;\n            left++;\n        }\n\n        if (matched == (int)need.size()) {\n            return true;\n        }\n    }\n\n    return false;\n}",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Test your implementation with edge cases:\n\n1. s1=\"ab\", s2=\"eidbaooo\" → true\n2. s1=\"ab\", s2=\"eidboaoo\" → false\n3. s1=\"a\", s2=\"a\" → true\n4. s1=\"abc\", s2=\"bbbca\" → true\n5. s1=\"abcd\", s2=\"abc\" → false",
      "example": "cout << checkInclusion(\"ab\", \"eidbaooo\") << endl; // 1\ncout << checkInclusion(\"ab\", \"eidboaoo\") << endl; // 0\ncout << checkInclusion(\"a\", \"a\") << endl;         // 1\ncout << checkInclusion(\"abc\", \"bbbca\") << endl;    // 1\ncout << checkInclusion(\"abcd\", \"abc\") << endl;     // 0",
      "action": "continue",
      "next": "final"
    },

    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding in TypeScript: do you know what a variable is?",
      "choices": [
        { "label": "Yes", "next": "function-check-ts" },
        { "label": "No", "next": "variable-explanation-ts" }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable stores a value so we can reuse it later.\n\nIn this problem, we'll store:\n- frequency maps\n- window pointers\n- counts\n\nVariables allow us to track state as the window moves.",
      "example": "const need: Record<string, number> = {};\nconst window: Record<string, number> = {};\nlet left: number = 0;\nlet matched: number = 0;",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Do you understand what a function is in TypeScript?",
      "choices": [
        { "label": "Yes", "next": "parameter-check-ts" },
        { "label": "No", "next": "function-explanation-ts" }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function groups logic into a reusable unit.\n\nWe'll write a function that:\n- Takes s1 and s2 as input\n- Returns true or false",
      "example": "function checkInclusion(s1: string, s2: string): boolean {\n  return true;\n}",
      "action": "continue",
      "next": "parameter-check-ts"
    },
    {
      "stepId": "parameter-check-ts",
      "mentorSays": "Do you know what function parameters are?",
      "choices": [
        { "label": "Yes", "next": "array-check-ts" },
        { "label": "No", "next": "parameter-explanation-ts" }
      ]
    },
    {
      "stepId": "parameter-explanation-ts",
      "mentorSays": "Parameters are inputs to a function.\n\nHere:\n- s1 is the pattern string\n- s2 is the text string",
      "example": "checkInclusion(\"ab\", \"eidbaooo\");",
      "action": "continue",
      "next": "array-check-ts"
    },
    {
      "stepId": "array-check-ts",
      "mentorSays": "Do you know how arrays and objects are used to store collections?",
      "choices": [
        { "label": "Yes", "next": "loop-check-ts" },
        { "label": "No", "next": "array-explanation-ts" }
      ]
    },
    {
      "stepId": "array-explanation-ts",
      "mentorSays": "We use objects as frequency maps.\n\nEach key is a character.\nEach value is how many times it appears.",
      "example": "const need: Record<string, number> = { a: 1, b: 1 };\nconst window: Record<string, number> = { e: 1, i: 1 };",
      "action": "continue",
      "next": "loop-check-ts"
    },
    {
      "stepId": "loop-check-ts",
      "mentorSays": "Are you comfortable using loops?",
      "choices": [
        { "label": "Yes", "next": "coding-start-ts" },
        { "label": "No", "next": "loop-explanation-ts" }
      ]
    },
    {
      "stepId": "loop-explanation-ts",
      "mentorSays": "Loops let us process each character step by step.\n\nWe'll loop over s2 once while sliding the window.",
      "example": "for (let i = 0; i < s2.length; i++) {\n  // process s2[i]\n}",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Let's start coding.\n\nWe define the function and handle a quick edge case.",
      "example": "function checkInclusion(s1: string, s2: string): boolean {\n  if (s1.length > s2.length) return false;\n\n  // we'll fill the rest next\n}",
      "action": "continue",
      "next": "coding-build-s1-freq-ts"
    },
    {
      "stepId": "coding-build-s1-freq-ts",
      "mentorSays": "First, build the frequency map for s1.\n\nThis defines what a valid permutation looks like.",
      "example": "function checkInclusion(s1: string, s2: string): boolean {\n  if (s1.length > s2.length) return false;\n\n  const need: Record<string, number> = {};\n  for (const ch of s1) {\n    need[ch] = (need[ch] || 0) + 1;\n  }\n\n  // next: build window state\n  return false;\n}",
      "action": "continue",
      "next": "coding-init-window-ts"
    },
    {
      "stepId": "coding-init-window-ts",
      "mentorSays": "Now initialize the sliding window state.",
      "example": "function checkInclusion(s1: string, s2: string): boolean {\n  if (s1.length > s2.length) return false;\n\n  const need: Record<string, number> = {};\n  for (const ch of s1) {\n    need[ch] = (need[ch] || 0) + 1;\n  }\n\n  const window: Record<string, number> = {};\n  let left: number = 0;\n  let matched: number = 0;\n\n  // next: expand with right pointer\n  return false;\n}",
      "action": "continue",
      "next": "coding-expand-window-ts"
    },
    {
      "stepId": "coding-expand-window-ts",
      "mentorSays": "We expand the window by moving the right pointer.\n\nEach new character updates the window frequency.",
      "example": "function checkInclusion(s1: string, s2: string): boolean {\n  if (s1.length > s2.length) return false;\n\n  const need: Record<string, number> = {};\n  for (const ch of s1) {\n    need[ch] = (need[ch] || 0) + 1;\n  }\n\n  const window: Record<string, number> = {};\n  let left: number = 0;\n  let matched: number = 0;\n\n  for (let right = 0; right < s2.length; right++) {\n    const ch = s2[right];\n    window[ch] = (window[ch] || 0) + 1;\n\n    // next: update matched for this character\n  }\n\n  return false;\n}",
      "action": "continue",
      "next": "coding-check-match-ts"
    },
    {
      "stepId": "coding-check-match-ts",
      "mentorSays": "After adding a character, check if it satisfies the needed frequency.",
      "example": "function checkInclusion(s1: string, s2: string): boolean {\n  if (s1.length > s2.length) return false;\n\n  const need: Record<string, number> = {};\n  for (const ch of s1) {\n    need[ch] = (need[ch] || 0) + 1;\n  }\n\n  const window: Record<string, number> = {};\n  let left: number = 0;\n  let matched: number = 0;\n\n  for (let right = 0; right < s2.length; right++) {\n    const ch = s2[right];\n    window[ch] = (window[ch] || 0) + 1;\n\n    if (need[ch] && window[ch] === need[ch]) {\n      matched++;\n    }\n\n    // next: shrink when window is too big\n  }\n\n  return false;\n}",
      "action": "continue",
      "next": "coding-shrink-window-ts"
    },
    {
      "stepId": "coding-shrink-window-ts",
      "mentorSays": "If window size exceeds s1 length, shrink from the left.",
      "example": "function checkInclusion(s1: string, s2: string): boolean {\n  if (s1.length > s2.length) return false;\n\n  const need: Record<string, number> = {};\n  for (const ch of s1) {\n    need[ch] = (need[ch] || 0) + 1;\n  }\n\n  const window: Record<string, number> = {};\n  let left: number = 0;\n  let matched: number = 0;\n\n  for (let right = 0; right < s2.length; right++) {\n    const ch = s2[right];\n    window[ch] = (window[ch] || 0) + 1;\n\n    if (need[ch] && window[ch] === need[ch]) {\n      matched++;\n    }\n\n    while (right - left + 1 > s1.length) {\n      const leftChar = s2[left];\n      if (need[leftChar] && window[leftChar] === need[leftChar]) {\n        matched--;\n      }\n      window[leftChar]--;\n      left++;\n    }\n\n    // next: if all matched, return true\n  }\n\n  return false;\n}",
      "action": "continue",
      "next": "coding-found-permutation-ts"
    },
    {
      "stepId": "coding-found-permutation-ts",
      "mentorSays": "If all characters match, we found a permutation.",
      "example": "function checkInclusion(s1: string, s2: string): boolean {\n  if (s1.length > s2.length) return false;\n\n  const need: Record<string, number> = {};\n  for (const ch of s1) {\n    need[ch] = (need[ch] || 0) + 1;\n  }\n\n  const window: Record<string, number> = {};\n  let left: number = 0;\n  let matched: number = 0;\n\n  for (let right = 0; right < s2.length; right++) {\n    const ch = s2[right];\n    window[ch] = (window[ch] || 0) + 1;\n\n    if (need[ch] && window[ch] === need[ch]) {\n      matched++;\n    }\n\n    while (right - left + 1 > s1.length) {\n      const leftChar = s2[left];\n      if (need[leftChar] && window[leftChar] === need[leftChar]) {\n        matched--;\n      }\n      window[leftChar]--;\n      left++;\n    }\n\n    if (matched === Object.keys(need).length) {\n      return true;\n    }\n  }\n\n  return false;\n}",
      "action": "continue",
      "next": "coding-return-ts"
    },
    {
      "stepId": "coding-return-ts",
      "mentorSays": "If the loop finishes without a match, return false.",
      "example": "function checkInclusion(s1: string, s2: string): boolean {\n  if (s1.length > s2.length) return false;\n\n  const need: Record<string, number> = {};\n  for (const ch of s1) {\n    need[ch] = (need[ch] || 0) + 1;\n  }\n\n  const window: Record<string, number> = {};\n  let left: number = 0;\n  let matched: number = 0;\n\n  for (let right = 0; right < s2.length; right++) {\n    const ch = s2[right];\n    window[ch] = (window[ch] || 0) + 1;\n\n    if (need[ch] && window[ch] === need[ch]) {\n      matched++;\n    }\n\n    while (right - left + 1 > s1.length) {\n      const leftChar = s2[left];\n      if (need[leftChar] && window[leftChar] === need[leftChar]) {\n        matched--;\n      }\n      window[leftChar]--;\n      left++;\n    }\n\n    if (matched === Object.keys(need).length) {\n      return true;\n    }\n  }\n\n  return false;\n}",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Test your implementation with edge cases:\n\n1. s1=\"ab\", s2=\"eidbaooo\" → true\n2. s1=\"ab\", s2=\"eidboaoo\" → false\n3. s1=\"a\", s2=\"a\" → true\n4. s1=\"abc\", s2=\"bbbca\" → true\n5. s1=\"abcd\", s2=\"abc\" → false",
      "example": "console.log(checkInclusion(\"ab\", \"eidbaooo\")); // true\nconsole.log(checkInclusion(\"ab\", \"eidboaoo\")); // false\nconsole.log(checkInclusion(\"a\", \"a\"));         // true\nconsole.log(checkInclusion(\"abc\", \"bbbca\"));    // true\nconsole.log(checkInclusion(\"abcd\", \"abc\"));     // false",
      "action": "continue",
      "next": "final"
    },

    {
      "stepId": "final",
      "mentorSays": "Excellent work!\n\nTime Complexity: O(n)\nSpace Complexity: O(1) (since alphabet size is fixed)\n\nKey Takeaways:\n- Permutations depend on frequency, not order\n- Fixed-size sliding windows are powerful\n- Incremental updates avoid recomputation\n\nRelated Problems:\n- Find All Anagrams in a String\n- Longest Substring with At Most K Distinct Characters",
      "action": "continue"
    }
  ]
}
