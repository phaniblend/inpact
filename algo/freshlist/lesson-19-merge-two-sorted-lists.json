{
  "id": "merge-two-sorted-lists",
  "title": "Merge Two Sorted Lists",
  "pattern": "merge pattern",
  "difficulty": "easy",
  "language": "javascript",
  "status": "PERFECT",
  "standardsVersion": "lessonStandards.v1",
  "curriculum": {
    "lessonNumber": 19,
    "tier": "FOUNDATION",
    "lessonOrderTag": "FOUNDATION-19",
    "introduces": [
      "dummy-head-technique",
      "tail-pointer",
      "list-comparison"
    ],
    "assumesAlreadyTaught": [
      "linked-list-concept",
      "comparison-operators"
    ],
    "prerequisiteCheckRequired": false,
    "nextRecommended": [
      "palindrome-linked-list"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Create a dummy node and set current pointer to dummy"
    },
    {
      "id": "ps2",
      "text": "While both list1 and list2 are not null"
    },
    {
      "id": "ps3",
      "text": "Compare values at current nodes of list1 and list2"
    },
    {
      "id": "ps4",
      "text": "Attach the smaller node to current.next and advance that list's pointer"
    },
    {
      "id": "ps5",
      "text": "Move current pointer to the newly attached node"
    },
    {
      "id": "ps6",
      "text": "Attach any remaining nodes from the non-empty list to current.next"
    },
    {
      "id": "ps7",
      "text": "Return dummy.next as the head of merged list"
    }
  ],
  "flow": [
    {
      "stepId": "lesson-start",
      "mentorSays": "Now that you've mastered manipulating linked list pointers by reversing their direction, let's explore another fundamental pointer technique: the merge pattern, where we'll learn to elegantly combine two sorted linked lists into one. This skill will teach you how to coordinate multiple pointers simultaneously while maintaining sorted order—a powerful technique that forms the backbone of many advanced algorithms.",
      "action": "next",
      "next": "problem-statement"
    },
    {
      "stepId": "problem-statement",
      "mentorSays": "You are given the heads of two sorted linked lists. Merge the two lists into one sorted linked list by splicing together the nodes of the original lists, and return the head of the merged linked list.\n\n**Example:**\n```text\nInput: l1: 1→2→4, l2: 1→3→4\nOutput: 1→1→2→3→4→4\n```\nThe merged list maintains sorted order by comparing values from both input lists and connecting nodes in ascending order.",
      "action": "next",
      "next": "tiny-examples"
    },
    {
      "stepId": "tiny-examples",
      "mentorSays": "**Tiny examples:**\n```text\n1) l1: 1→3→5, l2: 2→4→6 → 1→2→3→4→5→6\n2) l1: [], l2: 1→2→3 → 1→2→3\n3) l1: 5→7, l2: 1→2→8→9 → 1→2→5→7→8→9\n4) l1: 3→3, l2: 3→3→3 → 3→3→3→3→3\n```",
      "action": "next",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "What is the most efficient approach to merge two sorted linked lists while maintaining sorted order?",
      "action": "choice",
      "choices": [
        {
          "label": "Convert both lists to arrays, merge arrays, then rebuild the linked list",
          "next": "wrong-choice"
        },
        {
          "label": "Use a dummy node and two pointers to compare heads, attach the smaller node, and advance the corresponding pointer",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-choice",
      "mentorSays": "This approach works but uses O(n+m) extra space and requires additional overhead of array operations and list reconstruction, making it less efficient than the optimal pointer-based solution.",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "The **key insight** is to use a **dummy node** as a placeholder to eliminate edge case handling when the result list is empty. Compare the current heads of both lists, **attach the smaller node** to your result chain, and **advance the pointer** of the list you took from. Continue this process until one list is exhausted, then **append the remaining nodes** from the non-empty list. This approach maintains the sorted order while building a single merged list in O(m+n) time.",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "Let's trace through `l1: 1→2→4, l2: 1→3→4`:\n- Step 1: Create dummy node, compare 1 vs 1 (equal), attach l1's 1, advance l1 to 2\n- Step 2: Compare 2 vs 1, attach l2's 1, advance l2 to 3 → current: dummy→1→1\n- Step 3: Compare 2 vs 3, attach l1's 2, advance l1 to 4 → current: dummy→1→1→2\n- Step 4: Compare 4 vs 3, attach l2's 3, advance l2 to 4 → current: dummy→1→1→2→3\n- Step 5: Compare 4 vs 4 (equal), attach l1's 4, advance l1 to null, then attach remaining l2's 4\n- Final answer: **1→1→2→3→4→4**",
      "action": "next",
      "next": "pseudocode-step",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7"
      ]
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "Here's our plan written as pseudocode:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now let's translate this into JavaScript, building it step by step.",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Create a dummy node to simplify edge cases and initialize pointers for traversal.\n\n```javascript\nfunction mergeTwoLists(list1, list2) {\n    const dummy = { val: 0, next: null };\n    let current = dummy;\n}\n```",
      "action": "next",
      "next": "code-02",
      "pseudocodeLineIds": [
        "ps1"
      ],
      "example": "function mergeTwoLists(list1, list2) {\n    const dummy = { val: 0, next: null };\n    let current = dummy;\n}"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Add the main loop to compare node values and attach the smaller node to the result.\n\n```javascript\nfunction mergeTwoLists(list1, list2) {\n    const dummy = { val: 0, next: null };\n    let current = dummy;\n    \n    while (list1 && list2) {\n        if (list1.val <= list2.val) {\n            current.next = list1;\n            list1 = list1.next;\n        } else {\n            current.next = list2;\n            list2 = list2.next;\n        }\n        current = current.next;\n    }\n}\n```",
      "action": "next",
      "next": "code-03",
      "pseudocodeLineIds": [
        "ps2"
      ],
      "example": "    while (list1 && list2) {\n        if (list1.val <= list2.val) {\n            current.next = list1;\n            list1 = list1.next;\n        } else {\n            current.next = list2;\n            list2 = list2.next;\n        }\n        current = current.next;\n    }"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Handle remaining nodes by attaching any leftover list to the result.\n\n```javascript\nfunction mergeTwoLists(list1, list2) {\n    const dummy = { val: 0, next: null };\n    let current = dummy;\n    \n    while (list1 && list2) {\n        if (list1.val <= list2.val) {\n            current.next = list1;\n            list1 = list1.next;\n        } else {\n            current.next = list2;\n            list2 = list2.next;\n        }\n        current = current.next;\n    }\n    \n    if (list1) {\n        current.next = list1;\n    } else if (list2) {\n        current.next = list2;\n    }\n}\n```",
      "action": "next",
      "next": "code-04",
      "pseudocodeLineIds": [
        "ps3",
        "ps4",
        "ps5"
      ],
      "example": "    if (list1) {\n        current.next = list1;\n    } else if (list2) {\n        current.next = list2;\n    }"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Return the merged list by skipping the dummy node and returning the actual head.\n\n```javascript\nfunction mergeTwoLists(list1, list2) {\n    const dummy = { val: 0, next: null };\n    let current = dummy;\n    \n    while (list1 && list2) {\n        if (list1.val <= list2.val) {\n            current.next = list1;\n            list1 = list1.next;\n        } else {\n            current.next = list2;\n            list2 = list2.next;\n        }\n        current = current.next;\n    }\n    \n    if (list1) {\n        current.next = list1;\n    } else if (list2) {\n        current.next = list2;\n    }\n    \n    return dummy.next;\n}\n```",
      "action": "next",
      "next": "wrap-up",
      "pseudocodeLineIds": [
        "ps6",
        "ps7"
      ],
      "example": "    return dummy.next;"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "Great work mastering the merge pattern and the powerful dummy-head technique! You've learned how to efficiently combine two sorted linked lists using a tail pointer for clean traversal and systematic list comparison. Next, we'll tackle the palindrome linked list problem, where you'll apply your growing linked list skills to detect symmetrical patterns in data structures.",
      "action": "complete"
    }
  ]
}