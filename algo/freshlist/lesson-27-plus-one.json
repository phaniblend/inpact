{
  "id": "plus-one",
  "title": "Plus One",
  "pattern": "array math",
  "difficulty": "easy",
  "language": "javascript",
  "status": "PERFECT",
  "standardsVersion": "lessonStandards.v1",
  "curriculum": {
    "lessonNumber": 27,
    "tier": "FOUNDATION",
    "lessonOrderTag": "FOUNDATION-27",
    "introduces": [
      "carry-propagation",
      "right-to-left-processing",
      "array-unshift"
    ],
    "assumesAlreadyTaught": [
      "arrays",
      "loops"
    ],
    "prerequisiteCheckRequired": false,
    "nextRecommended": [
      "sqrt-x"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Start from the rightmost digit (last index) of the array"
    },
    {
      "id": "ps2",
      "text": "Add 1 to the current digit"
    },
    {
      "id": "ps3",
      "text": "If the digit is less than 10, return the array (no carry needed)"
    },
    {
      "id": "ps4",
      "text": "If the digit equals 10, set it to 0 and move to the next left digit"
    },
    {
      "id": "ps5",
      "text": "Repeat steps 2-4 for each digit moving leftward"
    },
    {
      "id": "ps6",
      "text": "If all digits were 9 (carry propagated through entire array), create new array with 1 followed by all zeros"
    }
  ],
  "flow": [
    {
      "stepId": "lesson-start",
      "mentorSays": "Great work mastering the single-number problem using bit manipulation! Now we're going to build on that foundation by exploring how to handle mathematical operations directly on arrays, starting with the classic \"plus one\" challenge where we'll learn to simulate arithmetic when numbers are represented as digit arrays.",
      "action": "next",
      "next": "problem-statement"
    },
    {
      "stepId": "problem-statement",
      "mentorSays": "You are given a large integer represented as an array of digits, where each element in the array represents a single digit of the number. The digits are stored in order from most significant to least significant digit (left to right). Your task is to add 1 to this number and return the resulting array of digits.\n\n**Example:**\n```text\nInput: [1,2,9]\nOutput: [1,3,0]\n```\nThe input represents the number 129, and adding 1 gives us 130, which is represented as [1,3,0].",
      "action": "next",
      "next": "tiny-examples"
    },
    {
      "stepId": "tiny-examples",
      "mentorSays": "**Tiny examples:**\n```text\n1) [1,2,3] → [1,2,4]\n2) [9,9,9] → [1,0,0,0]\n3) [1,0,9] → [1,1,0]\n4) [9] → [1,0]\n```",
      "action": "next",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "What is the most efficient approach to add 1 to a number represented as an array of digits?",
      "action": "choice",
      "choices": [
        {
          "label": "Convert the entire array to an integer, add 1, then convert back to array",
          "next": "wrong-choice"
        },
        {
          "label": "Start from the rightmost digit, add 1, and propagate carries leftward only when needed",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-choice",
      "mentorSays": "This seems straightforward but fails for very large numbers that exceed integer limits and is unnecessarily complex for what should be a simple digit manipulation.",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "The key insight is to simulate **manual addition** by processing digits from **right to left**, handling carries as they propagate. Start by adding 1 to the rightmost digit - if it becomes 10, set it to 0 and carry 1 to the next position. Continue this **carry propagation** until you find a digit that doesn't overflow (< 10), then you're done. If all digits overflow (like 999 → 1000), you need to **extend the array** with a leading 1.",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "Let's trace through `[1,2,9]`:\n- Step 1: Start from rightmost digit (9), add 1 → 9 + 1 = 10\n- Step 2: Since 10 ≥ 10, set current digit to 0, carry 1 to next position → [1,2,0]\n- Step 3: Move to digit 2, add carry 1 → 2 + 1 = 3\n- Step 4: Since 3 < 10, no more carry needed, we're done\n- Final answer: **[1,3,0]**",
      "action": "next",
      "next": "pseudocode-step",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6"
      ]
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "Here's our plan written as pseudocode:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now let's translate this into JavaScript, building it step by step.",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Set up the function structure and start from the rightmost digit.\n\n```javascript\nfunction plusOne(digits) {\n    for (let i = digits.length - 1; i >= 0; i--) {\n        \n    }\n}\n```",
      "action": "next",
      "next": "code-02",
      "pseudocodeLineIds": [
        "ps1"
      ],
      "example": "function plusOne(digits) {\n    for (let i = digits.length - 1; i >= 0; i--) {\n        \n    }\n}"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Add 1 to the current digit and check if it's less than 10.\n\n```javascript\nfunction plusOne(digits) {\n    for (let i = digits.length - 1; i >= 0; i--) {\n        digits[i]++;\n        if (digits[i] < 10) {\n            return digits;\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-03",
      "pseudocodeLineIds": [
        "ps2"
      ],
      "example": "        digits[i]++;\n        if (digits[i] < 10) {\n            return digits;\n        }"
    },
    {
      "stepId": "code-03",
      "mentorSays": "If the digit becomes 10, set it to 0 and continue to carry left.\n\n```javascript\nfunction plusOne(digits) {\n    for (let i = digits.length - 1; i >= 0; i--) {\n        digits[i]++;\n        if (digits[i] < 10) {\n            return digits;\n        }\n        digits[i] = 0;\n    }\n}\n```",
      "action": "next",
      "next": "code-04",
      "pseudocodeLineIds": [
        "ps3"
      ],
      "example": "        digits[i] = 0;"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Handle the edge case where all digits are 9 by creating a new array with 1 followed by zeros.\n\n```javascript\nfunction plusOne(digits) {\n    for (let i = digits.length - 1; i >= 0; i--) {\n        digits[i]++;\n        if (digits[i] < 10) {\n            return digits;\n        }\n        digits[i] = 0;\n    }\n    return [1, ...new Array(digits.length).fill(0)];\n}\n```",
      "action": "next",
      "next": "wrap-up",
      "pseudocodeLineIds": [
        "ps4"
      ],
      "example": "    return [1, ...new Array(digits.length).fill(0)];"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "Great work mastering the Plus One problem! You've learned how to handle array math operations by processing digits from right-to-left and managing carry propagation, plus the useful array-unshift technique for adding elements to the beginning of an array. Next up, we'll tackle the Sqrt(x) problem where you'll explore binary search techniques for mathematical computations—keep up the excellent progress!",
      "action": "complete"
    }
  ]
}