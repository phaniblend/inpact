{
  "id": "find-first-last-position",
  "title": "Find First and Last Position",
  "pattern": "binary-search",
  "difficulty": "medium",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what the Find First and Last Position problem asks for\n2. Use two binary searches to find the first and last occurrence\n3. Modify binary search to find leftmost and rightmost positions\n4. Handle edge cases like target not found or single occurrence\n5. Implement the solution step by step in your chosen language",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Perfect! Now let's understand what the Find First and Last Position problem is asking.\n\n**Problem Definition:**\nGiven a sorted array of integers `nums` and a target value `target`, find the starting and ending position of `target` in the array. If `target` is not found, return `[-1, -1]`.\n\n**Key Insight:**\nSince the array is sorted, we can use binary search! But we need TWO binary searches:\n1. Find the **first** occurrence (leftmost position)\n2. Find the **last** occurrence (rightmost position)\n\n**Example 1:** nums = [5, 7, 7, 8, 8, 10], target = 8\n\nTarget 8 appears at indices 3 and 4.\n- First position: 3\n- Last position: 4\n- Return: [3, 4] ✓\n\n**Example 2:** nums = [5, 7, 7, 8, 8, 10], target = 6\n\nTarget 6 doesn't exist in the array.\n- Return: [-1, -1] ✓\n\n**Example 3:** nums = [5, 7, 7, 8, 8, 10], target = 7\n\nTarget 7 appears at indices 1 and 2.\n- First position: 1\n- Last position: 2\n- Return: [1, 2] ✓\n\n**Step-by-step trace for Example 1:**\n\nnums = [5, 7, 7, 8, 8, 10], target = 8\n\n**Finding First Position (leftmost):**\nWe modify binary search to keep searching left even when we find the target!\n\n- **Iteration 1**: left=0, right=5, mid=2, nums[2]=7\n  - 7 < 8, search right: left = 3\n- **Iteration 2**: left=3, right=5, mid=4, nums[4]=8\n  - 8 == 8, but we want FIRST occurrence, so search left: right = 3\n- **Iteration 3**: left=3, right=3, mid=3, nums[3]=8\n  - 8 == 8, search left: right = 2\n- **Loop ends**: left=3, right=2\n- **First position = 3** ✓\n\n**Finding Last Position (rightmost):**\nWe modify binary search to keep searching right even when we find the target!\n\n- **Iteration 1**: left=0, right=5, mid=2, nums[2]=7\n  - 7 < 8, search right: left = 3\n- **Iteration 2**: left=3, right=5, mid=4, nums[4]=8\n  - 8 == 8, but we want LAST occurrence, so search right: left = 5\n- **Iteration 3**: left=5, right=5, mid=5, nums[5]=10\n  - 10 > 8, search left: right = 4\n- **Loop ends**: left=5, right=4\n- **Last position = 4** ✓\n\nReturn: [3, 4]\n\n**What makes this tricky:**\n1. We need TWO modified binary searches (one for first, one for last)\n2. When we find the target, we don't stop—we keep searching in the appropriate direction\n3. The \"first\" search moves left when target is found, the \"last\" search moves right\n4. Handling the case where target doesn't exist\n\n**Common pitfalls:**\n- Using regular binary search (stops at first match, doesn't find boundaries)\n- Forgetting to check if target exists before returning positions\n- Off-by-one errors in the modified binary search logic\n- Not understanding when to move left vs right when target is found",
      "example": "Example 1:\nnums = [5, 7, 7, 8, 8, 10], target = 8\n\nFirst position: 3 (leftmost 8)\nLast position: 4 (rightmost 8)\nReturn: [3, 4]\n\nExample 2:\nnums = [5, 7, 7, 8, 8, 10], target = 6\n\nTarget not found\nReturn: [-1, -1]\n\nExample 3:\nnums = [5, 7, 7, 8, 8, 10], target = 7\n\nFirst position: 1\nLast position: 2\nReturn: [1, 2]",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Now that you understand what the problem wants, here's the real question:\n\nHow would YOU find the first and last position of a target in a sorted array?\n\nThink about it for a moment. What approach feels natural to you?",
      "choices": [
        {
          "label": "Use two modified binary searches: one for first, one for last",
          "next": "explore-two-binary-searches"
        },
        {
          "label": "Use linear search to find first and last occurrence",
          "next": "explore-linear"
        },
        {
          "label": "Use one binary search, then expand left and right",
          "next": "explore-expand"
        }
      ]
    },
    {
      "stepId": "explore-linear",
      "mentorSays": "That's a straightforward approach! You're thinking: \"I'll scan from the beginning to find the first occurrence, then scan from the end to find the last.\"\n\nFor nums = [5, 7, 7, 8, 8, 10], target = 8:\n- Scan forward: find 8 at index 3 (first)\n- Scan backward: find 8 at index 4 (last)\n- Return [3, 4] ✓\n\nThis works! However, it takes O(n) time in the worst case.\n\nThere's a more efficient O(log n) approach using two modified binary searches. Would you like to learn that?",
      "action": "continue",
      "next": "explore-two-binary-searches"
    },
    {
      "stepId": "explore-expand",
      "mentorSays": "That's a creative approach! You're thinking: \"I'll use binary search to find any occurrence, then expand left and right to find boundaries.\"\n\nThis works! However, if the target appears many times, expanding can take O(n) time in the worst case.\n\nThere's a more efficient O(log n) approach using two modified binary searches that directly find the boundaries. Would you like to learn that?",
      "action": "continue",
      "next": "explore-two-binary-searches"
    },
    {
      "stepId": "explore-two-binary-searches",
      "mentorSays": "Excellent choice! Two modified binary searches is the optimal approach. Here's the core idea:\n\n**The Algorithm:**\n1. **Find First Position (leftmost)**:\n   - Use binary search, but when we find target, don't stop—keep searching LEFT\n   - When nums[mid] == target, set right = mid - 1 (search left)\n   - When loop ends, left points to the first occurrence (or beyond if not found)\n\n2. **Find Last Position (rightmost)**:\n   - Use binary search, but when we find target, don't stop—keep searching RIGHT\n   - When nums[mid] == target, set left = mid + 1 (search right)\n   - When loop ends, right points to the last occurrence (or before if not found)\n\n3. **Validate**: Check if target actually exists at the found positions\n4. **Return**: [first, last] or [-1, -1] if not found\n\n**Why it works**:\n- For first position: We keep moving left when we find target, ensuring we find the leftmost occurrence\n- For last position: We keep moving right when we find target, ensuring we find the rightmost occurrence\n- Both searches are O(log n), so total is O(log n)\n\n**Key modification**: Instead of returning immediately when we find target, we continue searching in the direction that will find the boundary!\n\nLet's trace finding first position with nums = [5, 7, 7, 8, 8, 10], target = 8:\n\n- **Iteration 1**: left=0, right=5, mid=2, nums[2]=7\n  - 7 < 8, search right: left = 3\n- **Iteration 2**: left=3, right=5, mid=4, nums[4]=8\n  - 8 == 8, but we want FIRST, so search left: right = 3\n- **Iteration 3**: left=3, right=3, mid=3, nums[3]=8\n  - 8 == 8, search left: right = 2\n- **Loop ends**: left=3, right=2\n- **First = 3** ✓\n\nNow finding last position:\n\n- **Iteration 1**: left=0, right=5, mid=2, nums[2]=7\n  - 7 < 8, search right: left = 3\n- **Iteration 2**: left=3, right=5, mid=4, nums[4]=8\n  - 8 == 8, but we want LAST, so search right: left = 5\n- **Iteration 3**: left=5, right=5, mid=5, nums[5]=10\n  - 10 > 8, search left: right = 4\n- **Loop ends**: left=5, right=4\n- **Last = 4** ✓\n\nThis is O(log n) time and O(1) space! Now let's code it step by step.",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Great! Now let's code this solution. Which programming language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "variable-check-js"
        },
        {
          "label": "Python",
          "next": "variable-check-python"
        },
        {
          "label": "Java",
          "next": "variable-check-java"
        },
        {
          "label": "C++",
          "next": "variable-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "variable-check-ts"
        }
      ]
    },
    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-js"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-js"
        }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'left' or 'first') and put data inside it.\n\nFor example, 'let left = 0;' creates a variable that stores the number 0. Later, you can use that variable name to refer to it.",
      "example": "let left = 0;\nlet right = 5;\nlet first = -1;\n\nNow these variables store numbers\nWe can use them to track our search boundaries and results",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-js"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-js"
        }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the function does the work, and gives you a result (return value).",
      "example": "function add(a, b) {\n  return a + b;\n}\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-js"
    },
    {
      "stepId": "parameter-check-js",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "array-check-js"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-js"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-js",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function searchRange(nums, target)', the 'nums' and 'target' are parameters - they're placeholders that will receive actual values when you call the function.\n\nWhen you call 'searchRange([5, 7, 7, 8, 8, 10], 8)', the array goes into 'nums' and 8 goes into 'target'.",
      "example": "function searchRange(nums, target) {\n  // 'nums' and 'target' are parameters\n}\n\n// When we call it:\nsearchRange([5, 7, 7, 8, 8, 10], 8);\n// The array goes into 'nums', 8 goes into 'target'",
      "action": "continue",
      "next": "array-check-js"
    },
    {
      "stepId": "array-check-js",
      "mentorSays": "To solve this problem, we'll need to work with arrays. Do you know what an array is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know arrays",
          "next": "loop-check-js"
        },
        {
          "label": "No, explain arrays",
          "next": "array-explanation-js"
        }
      ]
    },
    {
      "stepId": "array-explanation-js",
      "mentorSays": "An array is like a list of items that keeps them in order. Each item has a position number called an 'index'. Array indices start counting from 0, not 1.\n\nFor example, nums = [5, 7, 7, 8, 8, 10] means:\n- nums[0] = 5 (first element, index 0)\n- nums[1] = 7 (second element, index 1)\n- nums[2] = 7 (third element, index 2)\n- nums[3] = 8 (fourth element, index 3)\n- nums[4] = 8 (fifth element, index 4)\n- nums[5] = 10 (sixth element, index 5)",
      "example": "let nums = [5, 7, 7, 8, 8, 10];\n\nnums[0] = 5\nnums[1] = 7\nnums[2] = 7\nnums[3] = 8\nnums[4] = 8\nnums[5] = 10",
      "action": "continue",
      "next": "loop-check-js"
    },
    {
      "stepId": "loop-check-js",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "coding-start-js"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-js"
        }
      ]
    },
    {
      "stepId": "loop-explanation-js",
      "mentorSays": "A loop lets you repeat code multiple times. A 'while' loop runs code while a condition is true.\n\nFor example, 'while (left <= right)' means: keep going while left is less than or equal to right.",
      "example": "while (left <= right) {\n    // This code runs while the condition is true\n    // We'll do binary search here\n}",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Perfect! Let's implement the find first and last position solution in JavaScript. We'll create a function that takes a sorted array and target, and returns [first, last] positions.",
      "example": "function searchRange(nums, target) {\n  \n}",
      "action": "continue",
      "next": "coding-find-first-init-js"
    },
    {
      "stepId": "coding-find-first-init-js",
      "mentorSays": "Create a helper function to find the first position. Initialize the binary search variables: left at 0, right at the end, and first at -1 (meaning not found yet).",
      "example": "function searchRange(nums, target) {\n  // Helper to find first (leftmost) position\n  function findFirst() {\n    let left = 0;\n    let right = nums.length - 1;\n    let first = -1;  // -1 means not found\n    \n    // Binary search will go here\n  }\n}",
      "action": "continue",
      "next": "coding-find-first-loop-js"
    },
    {
      "stepId": "coding-find-first-loop-js",
      "mentorSays": "Add the binary search while loop. While left and right don't cross, calculate the middle index.",
      "example": "function searchRange(nums, target) {\n  function findFirst() {\n    let left = 0;\n    let right = nums.length - 1;\n    let first = -1;\n    \n    while (left <= right) {\n      let mid = Math.floor((left + right) / 2);\n      \n      // Comparison logic will go here\n    }\n    \n    return first;\n  }\n}",
      "action": "continue",
      "next": "coding-find-first-compare-js"
    },
    {
      "stepId": "coding-find-first-compare-js",
      "mentorSays": "Add the comparison logic. When we find the target, save the position but continue searching LEFT to find the FIRST occurrence.",
      "example": "function searchRange(nums, target) {\n  function findFirst() {\n    let left = 0;\n    let right = nums.length - 1;\n    let first = -1;\n    \n    while (left <= right) {\n      let mid = Math.floor((left + right) / 2);\n      \n      if (nums[mid] === target) {\n        first = mid;  // Found it!\n        right = mid - 1;  // Keep searching LEFT for first occurrence\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    \n    return first;\n  }\n}",
      "action": "continue",
      "next": "coding-find-last-init-js"
    },
    {
      "stepId": "coding-find-last-init-js",
      "mentorSays": "Now create a second helper function to find the last position. Initialize the same binary search variables.",
      "example": "function searchRange(nums, target) {\n  function findFirst() {\n    let left = 0;\n    let right = nums.length - 1;\n    let first = -1;\n    \n    while (left <= right) {\n      let mid = Math.floor((left + right) / 2);\n      if (nums[mid] === target) {\n        first = mid;\n        right = mid - 1;\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    return first;\n  }\n  \n  // Helper to find last (rightmost) position\n  function findLast() {\n    let left = 0;\n    let right = nums.length - 1;\n    let last = -1;\n    \n    // Binary search will go here\n  }\n}",
      "action": "continue",
      "next": "coding-find-last-loop-js"
    },
    {
      "stepId": "coding-find-last-loop-js",
      "mentorSays": "Add the binary search while loop for finding the last position.",
      "example": "function searchRange(nums, target) {\n  function findFirst() {\n    let left = 0;\n    let right = nums.length - 1;\n    let first = -1;\n    while (left <= right) {\n      let mid = Math.floor((left + right) / 2);\n      if (nums[mid] === target) {\n        first = mid;\n        right = mid - 1;\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    return first;\n  }\n  \n  function findLast() {\n    let left = 0;\n    let right = nums.length - 1;\n    let last = -1;\n    \n    while (left <= right) {\n      let mid = Math.floor((left + right) / 2);\n      \n      // Comparison logic will go here\n    }\n    \n    return last;\n  }\n}",
      "action": "continue",
      "next": "coding-find-last-compare-js"
    },
    {
      "stepId": "coding-find-last-compare-js",
      "mentorSays": "Add the comparison logic for finding last. When we find the target, continue searching RIGHT to find the LAST occurrence.",
      "example": "function searchRange(nums, target) {\n  function findFirst() {\n    let left = 0;\n    let right = nums.length - 1;\n    let first = -1;\n    while (left <= right) {\n      let mid = Math.floor((left + right) / 2);\n      if (nums[mid] === target) {\n        first = mid;\n        right = mid - 1;\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    return first;\n  }\n  \n  function findLast() {\n    let left = 0;\n    let right = nums.length - 1;\n    let last = -1;\n    \n    while (left <= right) {\n      let mid = Math.floor((left + right) / 2);\n      \n      if (nums[mid] === target) {\n        last = mid;  // Found it!\n        left = mid + 1;  // Keep searching RIGHT for last occurrence\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    \n    return last;\n  }\n}",
      "action": "continue",
      "next": "coding-call-helpers-js"
    },
    {
      "stepId": "coding-call-helpers-js",
      "mentorSays": "Finally, call both helper functions to get the first and last positions, then return them as an array. If the target wasn't found (first is -1), return [-1, -1].",
      "example": "function searchRange(nums, target) {\n  function findFirst() {\n    let left = 0;\n    let right = nums.length - 1;\n    let first = -1;\n    while (left <= right) {\n      let mid = Math.floor((left + right) / 2);\n      if (nums[mid] === target) {\n        first = mid;\n        right = mid - 1;\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    return first;\n  }\n  \n  function findLast() {\n    let left = 0;\n    let right = nums.length - 1;\n    let last = -1;\n    while (left <= right) {\n      let mid = Math.floor((left + right) / 2);\n      if (nums[mid] === target) {\n        last = mid;\n        left = mid + 1;\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    return last;\n  }\n  \n  // Find both positions\n  let first = findFirst();\n  let last = findLast();\n  \n  // If target not found, return [-1, -1]\n  if (first === -1) {\n    return [-1, -1];\n  }\n  \n  return [first, last];\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** nums = [5, 7, 7, 8, 8, 10], target = 8\nExpected: [3, 4]\n\n**Test 2:** nums = [5, 7, 7, 8, 8, 10], target = 6\nExpected: [-1, -1] (target not found)\n\n**Test 3:** nums = [5, 7, 7, 8, 8, 10], target = 7\nExpected: [1, 2]\n\n**Test 4:** nums = [], target = 0\nExpected: [-1, -1] (empty array)\n\n**Test 5:** nums = [1], target = 1\nExpected: [0, 0] (single occurrence)\n\n**Test 6:** nums = [1, 1, 1, 1, 1], target = 1\nExpected: [0, 4] (all elements are target)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [5,7,7,8,8,10], target=8 → [3,4]\nTest 2: [5,7,7,8,8,10], target=6 → [-1,-1]\nTest 3: [5,7,7,8,8,10], target=7 → [1,2]\nTest 4: [], target=0 → [-1,-1]\nTest 5: [1], target=1 → [0,0]\nTest 6: [1,1,1,1,1], target=1 → [0,4]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Python?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-python"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-python"
        }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'left' or 'first') and put data inside it.\n\nFor example, 'left = 0' creates a variable that stores the number 0. Later, you can use that variable name to refer to it.",
      "example": "left = 0\nright = 5\nfirst = -1\n\nNow these variables store numbers\nWe can use them to track our search boundaries and results",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Python?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-python"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-python"
        }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the function does the work, and gives you a result (return value).",
      "example": "def add(a, b):\n    return a + b\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-python"
    },
    {
      "stepId": "parameter-check-python",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "array-check-python"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-python"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-python",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'def searchRange(nums, target):', the 'nums' and 'target' are parameters - they're placeholders that will receive actual values when you call the function.\n\nWhen you call 'searchRange([5, 7, 7, 8, 8, 10], 8)', the array goes into 'nums' and 8 goes into 'target'.",
      "example": "def searchRange(nums, target):\n  # 'nums' and 'target' are parameters\n\n# When we call it:\nsearchRange([5, 7, 7, 8, 8, 10], 8)\n# The array goes into 'nums', 8 goes into 'target'",
      "action": "continue",
      "next": "array-check-python"
    },
    {
      "stepId": "array-check-python",
      "mentorSays": "To solve this problem, we'll need to work with arrays (lists in Python). Do you know what a list is in Python?",
      "choices": [
        {
          "label": "Yes, I know lists",
          "next": "loop-check-python"
        },
        {
          "label": "No, explain lists",
          "next": "array-explanation-python"
        }
      ]
    },
    {
      "stepId": "array-explanation-python",
      "mentorSays": "A list is like a list of items that keeps them in order. Each item has a position number called an 'index'. List indices start counting from 0, not 1.\n\nFor example, nums = [5, 7, 7, 8, 8, 10] means:\n- nums[0] = 5 (first element, index 0)\n- nums[1] = 7 (second element, index 1)\n- nums[2] = 7 (third element, index 2)\n- nums[3] = 8 (fourth element, index 3)\n- nums[4] = 8 (fifth element, index 4)\n- nums[5] = 10 (sixth element, index 5)",
      "example": "nums = [5, 7, 7, 8, 8, 10]\n\nnums[0] = 5\nnums[1] = 7\nnums[2] = 7\nnums[3] = 8\nnums[4] = 8\nnums[5] = 10",
      "action": "continue",
      "next": "loop-check-python"
    },
    {
      "stepId": "loop-check-python",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in Python?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "coding-start-python"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-python"
        }
      ]
    },
    {
      "stepId": "loop-explanation-python",
      "mentorSays": "A loop lets you repeat code multiple times. A 'while' loop runs code while a condition is true.\n\nFor example, 'while left <= right:' means: keep going while left is less than or equal to right.",
      "example": "while left <= right:\n    # This code runs while the condition is true\n    # We'll do binary search here",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Perfect! Let's implement the find first and last position solution in Python. We'll create a function that takes a sorted array and target, and returns [first, last] positions.",
      "example": "def searchRange(nums, target):\n    \n    pass",
      "action": "continue",
      "next": "coding-find-first-init-python"
    },
    {
      "stepId": "coding-find-first-init-python",
      "mentorSays": "Create a helper function to find the first position. Initialize the binary search variables: left at 0, right at the end, and first at -1 (meaning not found yet).",
      "example": "def searchRange(nums, target):\n    # Helper to find first (leftmost) position\n    def findFirst():\n        left = 0\n        right = len(nums) - 1\n        first = -1  # -1 means not found\n        \n        # Binary search will go here\n        \n        pass",
      "action": "continue",
      "next": "coding-find-first-loop-python"
    },
    {
      "stepId": "coding-find-first-loop-python",
      "mentorSays": "Add the binary search while loop. While left and right don't cross, calculate the middle index.",
      "example": "def searchRange(nums, target):\n    def findFirst():\n        left = 0\n        right = len(nums) - 1\n        first = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            # Comparison logic will go here\n            \n        return first\n        \n        pass",
      "action": "continue",
      "next": "coding-find-first-compare-python"
    },
    {
      "stepId": "coding-find-first-compare-python",
      "mentorSays": "Add the comparison logic. When we find the target, save the position but continue searching LEFT to find the FIRST occurrence.",
      "example": "def searchRange(nums, target):\n    def findFirst():\n        left = 0\n        right = len(nums) - 1\n        first = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                first = mid  # Found it!\n                right = mid - 1  # Keep searching LEFT for first occurrence\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return first\n        \n        pass",
      "action": "continue",
      "next": "coding-find-last-init-python"
    },
    {
      "stepId": "coding-find-last-init-python",
      "mentorSays": "Now create a second helper function to find the last position. Initialize the same binary search variables.",
      "example": "def searchRange(nums, target):\n    def findFirst():\n        left = 0\n        right = len(nums) - 1\n        first = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                first = mid\n                right = mid - 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return first\n    \n    # Helper to find last (rightmost) position\n    def findLast():\n        left = 0\n        right = len(nums) - 1\n        last = -1\n        \n        # Binary search will go here\n        \n        pass",
      "action": "continue",
      "next": "coding-find-last-loop-python"
    },
    {
      "stepId": "coding-find-last-loop-python",
      "mentorSays": "Add the binary search while loop for finding the last position.",
      "example": "def searchRange(nums, target):\n    def findFirst():\n        left = 0\n        right = len(nums) - 1\n        first = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                first = mid\n                right = mid - 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return first\n    \n    def findLast():\n        left = 0\n        right = len(nums) - 1\n        last = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            # Comparison logic will go here\n            \n        return last\n        \n        pass",
      "action": "continue",
      "next": "coding-find-last-compare-python"
    },
    {
      "stepId": "coding-find-last-compare-python",
      "mentorSays": "Add the comparison logic for finding last. When we find the target, continue searching RIGHT to find the LAST occurrence.",
      "example": "def searchRange(nums, target):\n    def findFirst():\n        left = 0\n        right = len(nums) - 1\n        first = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                first = mid\n                right = mid - 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return first\n    \n    def findLast():\n        left = 0\n        right = len(nums) - 1\n        last = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                last = mid  # Found it!\n                left = mid + 1  # Keep searching RIGHT for last occurrence\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return last\n        \n        pass",
      "action": "continue",
      "next": "coding-call-helpers-python"
    },
    {
      "stepId": "coding-call-helpers-python",
      "mentorSays": "Finally, call both helper functions to get the first and last positions, then return them as a list. If the target wasn't found (first is -1), return [-1, -1].",
      "example": "def searchRange(nums, target):\n    def findFirst():\n        left = 0\n        right = len(nums) - 1\n        first = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                first = mid\n                right = mid - 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return first\n    \n    def findLast():\n        left = 0\n        right = len(nums) - 1\n        last = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                last = mid\n                left = mid + 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return last\n    \n    # Find both positions\n    first = findFirst()\n    last = findLast()\n    \n    # If target not found, return [-1, -1]\n    if first == -1:\n        return [-1, -1]\n    \n    return [first, last]",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** nums = [5, 7, 7, 8, 8, 10], target = 8\nExpected: [3, 4]\n\n**Test 2:** nums = [5, 7, 7, 8, 8, 10], target = 6\nExpected: [-1, -1] (target not found)\n\n**Test 3:** nums = [5, 7, 7, 8, 8, 10], target = 7\nExpected: [1, 2]\n\n**Test 4:** nums = [], target = 0\nExpected: [-1, -1] (empty array)\n\n**Test 5:** nums = [1], target = 1\nExpected: [0, 0] (single occurrence)\n\n**Test 6:** nums = [1, 1, 1, 1, 1], target = 1\nExpected: [0, 4] (all elements are target)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [5,7,7,8,8,10], target=8 → [3,4]\nTest 2: [5,7,7,8,8,10], target=6 → [-1,-1]\nTest 3: [5,7,7,8,8,10], target=7 → [1,2]\nTest 4: [], target=0 → [-1,-1]\nTest 5: [1], target=1 → [0,0]\nTest 6: [1,1,1,1,1], target=1 → [0,4]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Java?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-java"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-java"
        }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'left' or 'first') and put data inside it.\n\nFor example, 'int left = 0;' creates a variable that stores the number 0. Later, you can use that variable name to refer to it.",
      "example": "int left = 0;\nint right = 5;\nint first = -1;\n\nNow these variables store numbers\nWe can use them to track our search boundaries and results",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a method is in Java?",
      "choices": [
        {
          "label": "Yes, I know methods",
          "next": "parameter-check-java"
        },
        {
          "label": "No, explain methods",
          "next": "function-explanation-java"
        }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A method (Java's version of a function) is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the method does the work, and gives you a result (return value).",
      "example": "public int add(int a, int b) {\n    return a + b;\n}\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-java"
    },
    {
      "stepId": "parameter-check-java",
      "mentorSays": "When we write a method, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "array-check-java"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-java"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-java",
      "mentorSays": "Parameters are like variables that receive values when you call the method. When you write 'public int[] searchRange(int[] nums, int target)', the 'nums' and 'target' are parameters - they're placeholders that will receive actual values when you call the method.",
      "example": "public int[] searchRange(int[] nums, int target) {\n  // 'nums' and 'target' are parameters\n}\n\n// When we call it:\nsearchRange(new int[]{5, 7, 7, 8, 8, 10}, 8);\n// The array goes into 'nums', 8 goes into 'target'",
      "action": "continue",
      "next": "array-check-java"
    },
    {
      "stepId": "array-check-java",
      "mentorSays": "To solve this problem, we'll need to work with arrays. Do you know what an array is in Java?",
      "choices": [
        {
          "label": "Yes, I know arrays",
          "next": "loop-check-java"
        },
        {
          "label": "No, explain arrays",
          "next": "array-explanation-java"
        }
      ]
    },
    {
      "stepId": "array-explanation-java",
      "mentorSays": "An array is like a list of items that keeps them in order. Each item has a position number called an 'index'. Array indices start counting from 0, not 1.\n\nFor example, int[] nums = {5, 7, 7, 8, 8, 10} means:\n- nums[0] = 5 (first element, index 0)\n- nums[1] = 7 (second element, index 1)\n- nums[2] = 7 (third element, index 2)\n- nums[3] = 8 (fourth element, index 3)\n- nums[4] = 8 (fifth element, index 4)\n- nums[5] = 10 (sixth element, index 5)",
      "example": "int[] nums = {5, 7, 7, 8, 8, 10};\n\nnums[0] = 5\nnums[1] = 7\nnums[2] = 7\nnums[3] = 8\nnums[4] = 8\nnums[5] = 10",
      "action": "continue",
      "next": "loop-check-java"
    },
    {
      "stepId": "loop-check-java",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in Java?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "coding-start-java"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-java"
        }
      ]
    },
    {
      "stepId": "loop-explanation-java",
      "mentorSays": "A loop lets you repeat code multiple times. A 'while' loop runs code while a condition is true.\n\nFor example, 'while (left <= right)' means: keep going while left is less than or equal to right.",
      "example": "while (left <= right) {\n    // This code runs while the condition is true\n    // We'll do binary search here\n}",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Perfect! Let's implement the find first and last position solution in Java. We'll create a method that takes a sorted array and target, and returns [first, last] positions.",
      "example": "public int[] searchRange(int[] nums, int target) {\n    \n}",
      "action": "continue",
      "next": "coding-find-first-init-java"
    },
    {
      "stepId": "coding-find-first-init-java",
      "mentorSays": "Create a helper method to find the first position. Initialize the binary search variables: left at 0, right at the end, and first at -1 (meaning not found yet).",
      "example": "public int[] searchRange(int[] nums, int target) {\n    // Helper to find first (leftmost) position\n    private int findFirst(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        int first = -1;  // -1 means not found\n        \n        // Binary search will go here\n        \n        return first;\n    }\n}",
      "action": "continue",
      "next": "coding-find-first-loop-java"
    },
    {
      "stepId": "coding-find-first-loop-java",
      "mentorSays": "Add the binary search while loop. While left and right don't cross, calculate the middle index.",
      "example": "public int[] searchRange(int[] nums, int target) {\n    private int findFirst(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        int first = -1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            // Comparison logic will go here\n        }\n        \n        return first;\n    }\n}",
      "action": "continue",
      "next": "coding-find-first-compare-java"
    },
    {
      "stepId": "coding-find-first-compare-java",
      "mentorSays": "Add the comparison logic. When we find the target, save the position but continue searching LEFT to find the FIRST occurrence.",
      "example": "public int[] searchRange(int[] nums, int target) {\n    private int findFirst(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        int first = -1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                first = mid;  // Found it!\n                right = mid - 1;  // Keep searching LEFT for first occurrence\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return first;\n    }\n}",
      "action": "continue",
      "next": "coding-find-last-init-java"
    },
    {
      "stepId": "coding-find-last-init-java",
      "mentorSays": "Now create a second helper method to find the last position. Initialize the same binary search variables.",
      "example": "public int[] searchRange(int[] nums, int target) {\n    private int findFirst(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        int first = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                first = mid;\n                right = mid - 1;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return first;\n    }\n    \n    // Helper to find last (rightmost) position\n    private int findLast(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        int last = -1;\n        \n        // Binary search will go here\n        \n        return last;\n    }\n}",
      "action": "continue",
      "next": "coding-find-last-loop-java"
    },
    {
      "stepId": "coding-find-last-loop-java",
      "mentorSays": "Add the binary search while loop for finding the last position.",
      "example": "public int[] searchRange(int[] nums, int target) {\n    private int findFirst(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        int first = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                first = mid;\n                right = mid - 1;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return first;\n    }\n    \n    private int findLast(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        int last = -1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            // Comparison logic will go here\n        }\n        \n        return last;\n    }\n}",
      "action": "continue",
      "next": "coding-find-last-compare-java"
    },
    {
      "stepId": "coding-find-last-compare-java",
      "mentorSays": "Add the comparison logic for finding last. When we find the target, continue searching RIGHT to find the LAST occurrence.",
      "example": "public int[] searchRange(int[] nums, int target) {\n    private int findFirst(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        int first = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                first = mid;\n                right = mid - 1;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return first;\n    }\n    \n    private int findLast(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        int last = -1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                last = mid;  // Found it!\n                left = mid + 1;  // Keep searching RIGHT for last occurrence\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return last;\n    }\n}",
      "action": "continue",
      "next": "coding-call-helpers-java"
    },
    {
      "stepId": "coding-call-helpers-java",
      "mentorSays": "Finally, call both helper methods to get the first and last positions, then return them as an array. If the target wasn't found (first is -1), return [-1, -1].",
      "example": "public int[] searchRange(int[] nums, int target) {\n    private int findFirst(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        int first = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                first = mid;\n                right = mid - 1;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return first;\n    }\n    \n    private int findLast(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        int last = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                last = mid;\n                left = mid + 1;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return last;\n    }\n    \n    // Find both positions\n    int first = findFirst(nums, target);\n    int last = findLast(nums, target);\n    \n    // If target not found, return [-1, -1]\n    if (first == -1) {\n        return new int[]{-1, -1};\n    }\n    \n    return new int[]{first, last};\n}",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** nums = [5, 7, 7, 8, 8, 10], target = 8\nExpected: [3, 4]\n\n**Test 2:** nums = [5, 7, 7, 8, 8, 10], target = 6\nExpected: [-1, -1] (target not found)\n\n**Test 3:** nums = [5, 7, 7, 8, 8, 10], target = 7\nExpected: [1, 2]\n\n**Test 4:** nums = [], target = 0\nExpected: [-1, -1] (empty array)\n\n**Test 5:** nums = [1], target = 1\nExpected: [0, 0] (single occurrence)\n\n**Test 6:** nums = [1, 1, 1, 1, 1], target = 1\nExpected: [0, 4] (all elements are target)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [5,7,7,8,8,10], target=8 → [3,4]\nTest 2: [5,7,7,8,8,10], target=6 → [-1,-1]\nTest 3: [5,7,7,8,8,10], target=7 → [1,2]\nTest 4: [], target=0 → [-1,-1]\nTest 5: [1], target=1 → [0,0]\nTest 6: [1,1,1,1,1], target=1 → [0,4]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in C++?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-cpp"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'left' or 'first') and put data inside it.\n\nFor example, 'int left = 0;' creates a variable that stores the number 0. Later, you can use that variable name to refer to it.",
      "example": "int left = 0;\nint right = 5;\nint first = -1;\n\nNow these variables store numbers\nWe can use them to track our search boundaries and results",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in C++?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-cpp"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the function does the work, and gives you a result (return value).",
      "example": "int add(int a, int b) {\n    return a + b;\n}\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-cpp"
    },
    {
      "stepId": "parameter-check-cpp",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "array-check-cpp"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-cpp",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'vector<int> searchRange(vector<int>& nums, int target)', the 'nums' and 'target' are parameters - they're placeholders that will receive actual values when you call the function.",
      "example": "vector<int> searchRange(vector<int>& nums, int target) {\n  // 'nums' and 'target' are parameters\n}\n\n// When we call it:\nsearchRange(numsArray, 8);\n// The array goes into 'nums', 8 goes into 'target'",
      "action": "continue",
      "next": "array-check-cpp"
    },
    {
      "stepId": "array-check-cpp",
      "mentorSays": "To solve this problem, we'll need to work with arrays (vectors in C++). Do you know what a vector is in C++?",
      "choices": [
        {
          "label": "Yes, I know vectors",
          "next": "loop-check-cpp"
        },
        {
          "label": "No, explain vectors",
          "next": "array-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "array-explanation-cpp",
      "mentorSays": "A vector is like a list of items that keeps them in order. Each item has a position number called an 'index'. Vector indices start counting from 0, not 1.\n\nFor example, vector<int> nums = {5, 7, 7, 8, 8, 10} means:\n- nums[0] = 5 (first element, index 0)\n- nums[1] = 7 (second element, index 1)\n- nums[2] = 7 (third element, index 2)\n- nums[3] = 8 (fourth element, index 3)\n- nums[4] = 8 (fifth element, index 4)\n- nums[5] = 10 (sixth element, index 5)",
      "example": "vector<int> nums = {5, 7, 7, 8, 8, 10};\n\nnums[0] = 5\nnums[1] = 7\nnums[2] = 7\nnums[3] = 8\nnums[4] = 8\nnums[5] = 10",
      "action": "continue",
      "next": "loop-check-cpp"
    },
    {
      "stepId": "loop-check-cpp",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in C++?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "coding-start-cpp"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "loop-explanation-cpp",
      "mentorSays": "A loop lets you repeat code multiple times. A 'while' loop runs code while a condition is true.\n\nFor example, 'while (left <= right)' means: keep going while left is less than or equal to right.",
      "example": "while (left <= right) {\n    // This code runs while the condition is true\n    // We'll do binary search here\n}",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Perfect! Let's implement the find first and last position solution in C++. We'll create a function that takes a sorted array and target, and returns [first, last] positions.",
      "example": "vector<int> searchRange(vector<int>& nums, int target) {\n    \n}",
      "action": "continue",
      "next": "coding-find-first-init-cpp"
    },
    {
      "stepId": "coding-find-first-init-cpp",
      "mentorSays": "Create a helper lambda function to find the first position. Initialize the binary search variables: left at 0, right at the end, and first at -1 (meaning not found yet).",
      "example": "vector<int> searchRange(vector<int>& nums, int target) {\n    // Helper to find first (leftmost) position\n    auto findFirst = [&]() -> int {\n        int left = 0;\n        int right = nums.size() - 1;\n        int first = -1;  // -1 means not found\n        \n        // Binary search will go here\n        \n        return first;\n    };\n}",
      "action": "continue",
      "next": "coding-find-first-loop-cpp"
    },
    {
      "stepId": "coding-find-first-loop-cpp",
      "mentorSays": "Add the binary search while loop. While left and right don't cross, calculate the middle index.",
      "example": "vector<int> searchRange(vector<int>& nums, int target) {\n    auto findFirst = [&]() -> int {\n        int left = 0;\n        int right = nums.size() - 1;\n        int first = -1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            // Comparison logic will go here\n        }\n        \n        return first;\n    };\n}",
      "action": "continue",
      "next": "coding-find-first-compare-cpp"
    },
    {
      "stepId": "coding-find-first-compare-cpp",
      "mentorSays": "Add the comparison logic. When we find the target, save the position but continue searching LEFT to find the FIRST occurrence.",
      "example": "vector<int> searchRange(vector<int>& nums, int target) {\n    auto findFirst = [&]() -> int {\n        int left = 0;\n        int right = nums.size() - 1;\n        int first = -1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                first = mid;  // Found it!\n                right = mid - 1;  // Keep searching LEFT for first occurrence\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return first;\n    };\n}",
      "action": "continue",
      "next": "coding-find-last-init-cpp"
    },
    {
      "stepId": "coding-find-last-init-cpp",
      "mentorSays": "Now create a second helper lambda function to find the last position. Initialize the same binary search variables.",
      "example": "vector<int> searchRange(vector<int>& nums, int target) {\n    auto findFirst = [&]() -> int {\n        int left = 0;\n        int right = nums.size() - 1;\n        int first = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                first = mid;\n                right = mid - 1;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return first;\n    };\n    \n    // Helper to find last (rightmost) position\n    auto findLast = [&]() -> int {\n        int left = 0;\n        int right = nums.size() - 1;\n        int last = -1;\n        \n        // Binary search will go here\n        \n        return last;\n    };\n}",
      "action": "continue",
      "next": "coding-find-last-loop-cpp"
    },
    {
      "stepId": "coding-find-last-loop-cpp",
      "mentorSays": "Add the binary search while loop for finding the last position.",
      "example": "vector<int> searchRange(vector<int>& nums, int target) {\n    auto findFirst = [&]() -> int {\n        int left = 0;\n        int right = nums.size() - 1;\n        int first = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                first = mid;\n                right = mid - 1;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return first;\n    };\n    \n    auto findLast = [&]() -> int {\n        int left = 0;\n        int right = nums.size() - 1;\n        int last = -1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            // Comparison logic will go here\n        }\n        \n        return last;\n    };\n}",
      "action": "continue",
      "next": "coding-find-last-compare-cpp"
    },
    {
      "stepId": "coding-find-last-compare-cpp",
      "mentorSays": "Add the comparison logic for finding last. When we find the target, continue searching RIGHT to find the LAST occurrence.",
      "example": "vector<int> searchRange(vector<int>& nums, int target) {\n    auto findFirst = [&]() -> int {\n        int left = 0;\n        int right = nums.size() - 1;\n        int first = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                first = mid;\n                right = mid - 1;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return first;\n    };\n    \n    auto findLast = [&]() -> int {\n        int left = 0;\n        int right = nums.size() - 1;\n        int last = -1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                last = mid;  // Found it!\n                left = mid + 1;  // Keep searching RIGHT for last occurrence\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return last;\n    };\n}",
      "action": "continue",
      "next": "coding-call-helpers-cpp"
    },
    {
      "stepId": "coding-call-helpers-cpp",
      "mentorSays": "Finally, call both helper lambda functions to get the first and last positions, then return them as a vector. If the target wasn't found (first is -1), return {-1, -1}.",
      "example": "vector<int> searchRange(vector<int>& nums, int target) {\n    auto findFirst = [&]() -> int {\n        int left = 0;\n        int right = nums.size() - 1;\n        int first = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                first = mid;\n                right = mid - 1;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return first;\n    };\n    \n    auto findLast = [&]() -> int {\n        int left = 0;\n        int right = nums.size() - 1;\n        int last = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                last = mid;\n                left = mid + 1;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return last;\n    };\n    \n    // Find both positions\n    int first = findFirst();\n    int last = findLast();\n    \n    // If target not found, return {-1, -1}\n    if (first == -1) {\n        return {-1, -1};\n    }\n    \n    return {first, last};\n}",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** nums = [5, 7, 7, 8, 8, 10], target = 8\nExpected: [3, 4]\n\n**Test 2:** nums = [5, 7, 7, 8, 8, 10], target = 6\nExpected: [-1, -1] (target not found)\n\n**Test 3:** nums = [5, 7, 7, 8, 8, 10], target = 7\nExpected: [1, 2]\n\n**Test 4:** nums = [], target = 0\nExpected: [-1, -1] (empty array)\n\n**Test 5:** nums = [1], target = 1\nExpected: [0, 0] (single occurrence)\n\n**Test 6:** nums = [1, 1, 1, 1, 1], target = 1\nExpected: [0, 4] (all elements are target)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [5,7,7,8,8,10], target=8 → [3,4]\nTest 2: [5,7,7,8,8,10], target=6 → [-1,-1]\nTest 3: [5,7,7,8,8,10], target=7 → [1,2]\nTest 4: [], target=0 → [-1,-1]\nTest 5: [1], target=1 → [0,0]\nTest 6: [1,1,1,1,1], target=1 → [0,4]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-ts"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-ts"
        }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'left' or 'first') and put data inside it.\n\nFor example, 'let left: number = 0;' creates a variable that stores the number 0. Later, you can use that variable name to refer to it.",
      "example": "let left: number = 0;\nlet right: number = 5;\nlet first: number = -1;\n\nNow these variables store numbers\nWe can use them to track our search boundaries and results",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-ts"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-ts"
        }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the function does the work, and gives you a result (return value).",
      "example": "function add(a: number, b: number): number {\n  return a + b;\n}\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-ts"
    },
    {
      "stepId": "parameter-check-ts",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "array-check-ts"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-ts"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-ts",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function searchRange(nums: number[], target: number): number[]', the 'nums' and 'target' are parameters - they're placeholders that will receive actual values when you call the function.",
      "example": "function searchRange(nums: number[], target: number): number[] {\n  // 'nums' and 'target' are parameters\n}\n\n// When we call it:\nsearchRange([5, 7, 7, 8, 8, 10], 8);\n// The array goes into 'nums', 8 goes into 'target'",
      "action": "continue",
      "next": "array-check-ts"
    },
    {
      "stepId": "array-check-ts",
      "mentorSays": "To solve this problem, we'll need to work with arrays. Do you know what an array is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know arrays",
          "next": "loop-check-ts"
        },
        {
          "label": "No, explain arrays",
          "next": "array-explanation-ts"
        }
      ]
    },
    {
      "stepId": "array-explanation-ts",
      "mentorSays": "An array is like a list of items that keeps them in order. Each item has a position number called an 'index'. Array indices start counting from 0, not 1.\n\nFor example, let nums: number[] = [5, 7, 7, 8, 8, 10] means:\n- nums[0] = 5 (first element, index 0)\n- nums[1] = 7 (second element, index 1)\n- nums[2] = 7 (third element, index 2)\n- nums[3] = 8 (fourth element, index 3)\n- nums[4] = 8 (fifth element, index 4)\n- nums[5] = 10 (sixth element, index 5)",
      "example": "let nums: number[] = [5, 7, 7, 8, 8, 10];\n\nnums[0] = 5\nnums[1] = 7\nnums[2] = 7\nnums[3] = 8\nnums[4] = 8\nnums[5] = 10",
      "action": "continue",
      "next": "loop-check-ts"
    },
    {
      "stepId": "loop-check-ts",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "coding-start-ts"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-ts"
        }
      ]
    },
    {
      "stepId": "loop-explanation-ts",
      "mentorSays": "A loop lets you repeat code multiple times. A 'while' loop runs code while a condition is true.\n\nFor example, 'while (left <= right)' means: keep going while left is less than or equal to right.",
      "example": "while (left <= right) {\n    // This code runs while the condition is true\n    // We'll do binary search here\n}",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Perfect! Let's implement the find first and last position solution in TypeScript. We'll create a function that takes a sorted array and target, and returns [first, last] positions.",
      "example": "function searchRange(nums: number[], target: number): number[] {\n  \n}",
      "action": "continue",
      "next": "coding-find-first-init-ts"
    },
    {
      "stepId": "coding-find-first-init-ts",
      "mentorSays": "Create a helper function to find the first position. Initialize the binary search variables: left at 0, right at the end, and first at -1 (meaning not found yet).",
      "example": "function searchRange(nums: number[], target: number): number[] {\n  // Helper to find first (leftmost) position\n  function findFirst(): number {\n    let left: number = 0;\n    let right: number = nums.length - 1;\n    let first: number = -1;  // -1 means not found\n    \n    // Binary search will go here\n    \n    return first;\n  }\n}",
      "action": "continue",
      "next": "coding-find-first-loop-ts"
    },
    {
      "stepId": "coding-find-first-loop-ts",
      "mentorSays": "Add the binary search while loop. While left and right don't cross, calculate the middle index.",
      "example": "function searchRange(nums: number[], target: number): number[] {\n  function findFirst(): number {\n    let left: number = 0;\n    let right: number = nums.length - 1;\n    let first: number = -1;\n    \n    while (left <= right) {\n      let mid: number = Math.floor((left + right) / 2);\n      \n      // Comparison logic will go here\n    }\n    \n    return first;\n  }\n}",
      "action": "continue",
      "next": "coding-find-first-compare-ts"
    },
    {
      "stepId": "coding-find-first-compare-ts",
      "mentorSays": "Add the comparison logic. When we find the target, save the position but continue searching LEFT to find the FIRST occurrence.",
      "example": "function searchRange(nums: number[], target: number): number[] {\n  function findFirst(): number {\n    let left: number = 0;\n    let right: number = nums.length - 1;\n    let first: number = -1;\n    \n    while (left <= right) {\n      let mid: number = Math.floor((left + right) / 2);\n      \n      if (nums[mid] === target) {\n        first = mid;  // Found it!\n        right = mid - 1;  // Keep searching LEFT for first occurrence\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    \n    return first;\n  }\n}",
      "action": "continue",
      "next": "coding-find-last-init-ts"
    },
    {
      "stepId": "coding-find-last-init-ts",
      "mentorSays": "Now create a second helper function to find the last position. Initialize the same binary search variables.",
      "example": "function searchRange(nums: number[], target: number): number[] {\n  function findFirst(): number {\n    let left: number = 0;\n    let right: number = nums.length - 1;\n    let first: number = -1;\n    while (left <= right) {\n      let mid: number = Math.floor((left + right) / 2);\n      if (nums[mid] === target) {\n        first = mid;\n        right = mid - 1;\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    return first;\n  }\n  \n  // Helper to find last (rightmost) position\n  function findLast(): number {\n    let left: number = 0;\n    let right: number = nums.length - 1;\n    let last: number = -1;\n    \n    // Binary search will go here\n    \n    return last;\n  }\n}",
      "action": "continue",
      "next": "coding-find-last-loop-ts"
    },
    {
      "stepId": "coding-find-last-loop-ts",
      "mentorSays": "Add the binary search while loop for finding the last position.",
      "example": "function searchRange(nums: number[], target: number): number[] {\n  function findFirst(): number {\n    let left: number = 0;\n    let right: number = nums.length - 1;\n    let first: number = -1;\n    while (left <= right) {\n      let mid: number = Math.floor((left + right) / 2);\n      if (nums[mid] === target) {\n        first = mid;\n        right = mid - 1;\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    return first;\n  }\n  \n  function findLast(): number {\n    let left: number = 0;\n    let right: number = nums.length - 1;\n    let last: number = -1;\n    \n    while (left <= right) {\n      let mid: number = Math.floor((left + right) / 2);\n      \n      // Comparison logic will go here\n    }\n    \n    return last;\n  }\n}",
      "action": "continue",
      "next": "coding-find-last-compare-ts"
    },
    {
      "stepId": "coding-find-last-compare-ts",
      "mentorSays": "Add the comparison logic for finding last. When we find the target, continue searching RIGHT to find the LAST occurrence.",
      "example": "function searchRange(nums: number[], target: number): number[] {\n  function findFirst(): number {\n    let left: number = 0;\n    let right: number = nums.length - 1;\n    let first: number = -1;\n    while (left <= right) {\n      let mid: number = Math.floor((left + right) / 2);\n      if (nums[mid] === target) {\n        first = mid;\n        right = mid - 1;\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    return first;\n  }\n  \n  function findLast(): number {\n    let left: number = 0;\n    let right: number = nums.length - 1;\n    let last: number = -1;\n    \n    while (left <= right) {\n      let mid: number = Math.floor((left + right) / 2);\n      \n      if (nums[mid] === target) {\n        last = mid;  // Found it!\n        left = mid + 1;  // Keep searching RIGHT for last occurrence\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    \n    return last;\n  }\n}",
      "action": "continue",
      "next": "coding-call-helpers-ts"
    },
    {
      "stepId": "coding-call-helpers-ts",
      "mentorSays": "Finally, call both helper functions to get the first and last positions, then return them as an array. If the target wasn't found (first is -1), return [-1, -1].",
      "example": "function searchRange(nums: number[], target: number): number[] {\n  function findFirst(): number {\n    let left: number = 0;\n    let right: number = nums.length - 1;\n    let first: number = -1;\n    while (left <= right) {\n      let mid: number = Math.floor((left + right) / 2);\n      if (nums[mid] === target) {\n        first = mid;\n        right = mid - 1;\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    return first;\n  }\n  \n  function findLast(): number {\n    let left: number = 0;\n    let right: number = nums.length - 1;\n    let last: number = -1;\n    while (left <= right) {\n      let mid: number = Math.floor((left + right) / 2);\n      if (nums[mid] === target) {\n        last = mid;\n        left = mid + 1;\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    return last;\n  }\n  \n  // Find both positions\n  let first: number = findFirst();\n  let last: number = findLast();\n  \n  // If target not found, return [-1, -1]\n  if (first === -1) {\n    return [-1, -1];\n  }\n  \n  return [first, last];\n}",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** nums = [5, 7, 7, 8, 8, 10], target = 8\nExpected: [3, 4]\n\n**Test 2:** nums = [5, 7, 7, 8, 8, 10], target = 6\nExpected: [-1, -1] (target not found)\n\n**Test 3:** nums = [5, 7, 7, 8, 8, 10], target = 7\nExpected: [1, 2]\n\n**Test 4:** nums = [], target = 0\nExpected: [-1, -1] (empty array)\n\n**Test 5:** nums = [1], target = 1\nExpected: [0, 0] (single occurrence)\n\n**Test 6:** nums = [1, 1, 1, 1, 1], target = 1\nExpected: [0, 4] (all elements are target)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [5,7,7,8,8,10], target=8 → [3,4]\nTest 2: [5,7,7,8,8,10], target=6 → [-1,-1]\nTest 3: [5,7,7,8,8,10], target=7 → [1,2]\nTest 4: [], target=0 → [-1,-1]\nTest 5: [1], target=1 → [0,0]\nTest 6: [1,1,1,1,1], target=1 → [0,4]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "final",
      "mentorSays": "🎉 Well done! You've learned to think through the Find First and Last Position problem. You understand what the problem asks for, how to use two modified binary searches to find boundaries, and how to handle edge cases.\n\n**Key Takeaways:**\n1. **Two Binary Searches**: We need one search for the first (leftmost) occurrence and one for the last (rightmost) occurrence\n2. **Modified Binary Search**: When we find the target, we don't stop—we keep searching in the direction that finds the boundary\n3. **First Search**: Moves left when target is found (right = mid - 1)\n4. **Last Search**: Moves right when target is found (left = mid + 1)\n5. **Validation**: Check if target actually exists before returning positions\n\n**Time Complexity**: O(log n) - we perform two binary searches, each O(log n)\n**Space Complexity**: O(1) - we only use a constant amount of extra space\n\n**What to practice next:**\n- Search Insert Position (similar binary search pattern)\n- Search in Rotated Sorted Array (more complex binary search)\n- Find Peak Element (binary search on unsorted array)\n\nThis kind of thinking—modifying binary search to find boundaries—is essential for solving many search problems. Keep practicing!",
      "action": "continue"
    }
  ]
}

