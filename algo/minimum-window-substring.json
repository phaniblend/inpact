{
  "id": "minimum-window-substring",
  "title": "Minimum window substring",
  "pattern": "hash-map",
  "difficulty": "hard",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "Hey! Welcome to the Minimum window substring lesson.\n\nIn this lesson, you'll learn a problem-solving pattern that shows up in coding interviews.\n\nAfter this, you'll be able to:\n- Understand the Minimum window substring problem\n- Recognize the hash-map pattern\n- Build a complete solution step-by-step\n\nLet's dive in!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Before we dive into the problem, which programming language would you like to use?\n\nThis will help me make sure you have the right building blocks.",
      "choices": [
        {
          "label": "JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "Python",
          "next": "prereq-check-python"
        },
        {
          "label": "Java",
          "next": "prereq-check-java"
        },
        {
          "label": "C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "Great choice! Before we start, let me make sure you have the building blocks.\n\nTo solve this problem in JavaScript, you'll need to know:\n- **Arrays** - How to store and access lists of values\n- **Loops** - How to iterate through data\n- **Conditionals** - How to make decisions in code\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I know them all",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-js"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "Great choice! Before we start, let me make sure you have the building blocks.\n\nTo solve this problem in Python, you'll need to know:\n- **Arrays** - How to store and access lists of values\n- **Loops** - How to iterate through data\n- **Conditionals** - How to make decisions in code\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I know them all",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-python"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "Great choice! Before we start, let me make sure you have the building blocks.\n\nTo solve this problem in Java, you'll need to know:\n- **Arrays** - How to store and access lists of values\n- **Loops** - How to iterate through data\n- **Conditionals** - How to make decisions in code\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I know them all",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-java"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "Great choice! Before we start, let me make sure you have the building blocks.\n\nTo solve this problem in C++, you'll need to know:\n- **Arrays** - How to store and access lists of values\n- **Loops** - How to iterate through data\n- **Conditionals** - How to make decisions in code\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I know them all",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "Great choice! Before we start, let me make sure you have the building blocks.\n\nTo solve this problem in TypeScript, you'll need to know:\n- **Arrays** - How to store and access lists of values\n- **Loops** - How to iterate through data\n- **Conditionals** - How to make decisions in code\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I know them all",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-all-prereqs-js",
      "mentorSays": "Great! Let me teach you the JavaScript concepts you'll need.",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in JavaScript?",
      "example": "",
      "action": "continue",
      "next": "completion"
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function add(a, b) {\n  return a + b;\n}\n\nadd(3, 5) returns 8",
      "action": "continue",
      "next": "completion"
    },
    {
      "stepId": "teach-all-prereqs-python",
      "mentorSays": "Let me explain the Python concepts you'll need.\n\n[Prerequisite teaching will be expanded in Phase 2]\n\nFor now, let's continue to the problem!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-all-prereqs-java",
      "mentorSays": "Let me explain the Java concepts you'll need.\n\n[Prerequisite teaching will be expanded in Phase 2]\n\nFor now, let's continue to the problem!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-all-prereqs-cpp",
      "mentorSays": "Let me explain the C++ concepts you'll need.\n\n[Prerequisite teaching will be expanded in Phase 2]\n\nFor now, let's continue to the problem!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-all-prereqs-ts",
      "mentorSays": "Let me explain the TypeScript concepts you'll need.\n\n[Prerequisite teaching will be expanded in Phase 2]\n\nFor now, let's continue to the problem!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what the Minimum Window Substring problem asks for\n2. Use a sliding window with a hash map to track required characters\n3. Expand and shrink the window to find the minimum valid window\n4. Implement the solution step by step in your chosen language",
      "example": null,
      "action": "continue",
      "next": "approach-exploration"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Now that you understand the problem, how would YOU approach solving it?\n\nThink about it for a moment.",
      "choices": [
        {
          "label": "Check every possibility",
          "next": "explore-brute-force"
        },
        {
          "label": "Use a smarter approach",
          "next": "explore-optimal"
        },
        {
          "label": "I'm not sure, show me",
          "next": "explore-optimal"
        }
      ]
    },
    {
      "stepId": "explore-solution",
      "mentorSays": "Let me show you the optimal approach for this problem. [Strategy will be extracted from original lesson]",
      "action": "continue",
      "next": "solution-finalized"
    },
    {
      "stepId": "approach-exploration",
      "mentorSays": "Now that you understand the problem, let's think about how to solve it.\n\nWhat approach feels natural to you?",
      "choices": [
        {
          "label": "Try the straightforward approach first",
          "next": "explore-solution"
        },
        {
          "label": "Show me the optimal solution",
          "next": "explore-solution"
        }
      ]
    },
    {
      "stepId": "explore-brute-force",
      "mentorSays": "The brute force approach would check every possibility.\n\nThis works but is usually slow (O(n squared) or worse).\n\nLet's look at a smarter approach!",
      "action": "continue",
      "next": "explore-optimal"
    },
    {
      "stepId": "explore-optimal",
      "mentorSays": "The optimal approach uses a smarter strategy to avoid unnecessary work.\n\n[Strategy details will be added in Phase 2]",
      "action": "continue",
      "next": "solution-finalized"
    },
    {
      "stepId": "solution-finalized",
      "mentorSays": "Perfect! We've explored the approach. Now let's code the optimal solution.\n\nReady to write some code?",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Perfect! Let's implement minimum window substring in JavaScript. We'll use a sliding window with hash maps.",
      "example": "function minWindow(s, t) {\n  // Your code here\n}",
      "action": "continue",
      "next": "coding-build-need-js"
    },
    {
      "stepId": "coding-build-need-js",
      "mentorSays": "First, build a hash map `need` that counts how many of each character we need from string t.",
      "example": "function minWindow(s, t) {\n  if (s.length === 0 || t.length === 0) return '';\n  \n  // Build need map\n  const need = {};\n  for (let char of t) {\n    need[char] = (need[char] || 0) + 1;\n  }\n  \n  const needCount = Object.keys(need).length;",
      "action": "continue",
      "next": "coding-initialize-js"
    },
    {
      "stepId": "coding-initialize-js",
      "mentorSays": "Initialize variables: left and right pointers, window map to track current window, formed count to track how many required characters we've found, and variables to track the minimum window.",
      "example": "function minWindow(s, t) {\n  if (s.length === 0 || t.length === 0) return '';\n  \n  const need = {};\n  for (let char of t) {\n    need[char] = (need[char] || 0) + 1;\n  }\n  const needCount = Object.keys(need).length;\n  \n  // Initialize\n  let left = 0, right = 0;\n  const window = {};\n  let formed = 0;  // How many required characters we've found\n  let minLen = Infinity;\n  let minStart = 0;",
      "action": "continue",
      "next": "coding-expand-js"
    },
    {
      "stepId": "coding-expand-js",
      "mentorSays": "Expand the window by moving the right pointer. For each character, add it to the window map and check if we've found enough of that required character.",
      "example": "function minWindow(s, t) {\n  if (s.length === 0 || t.length === 0) return '';\n  \n  const need = {};\n  for (let char of t) {\n    need[char] = (need[char] || 0) + 1;\n  }\n  const needCount = Object.keys(need).length;\n  \n  let left = 0, right = 0;\n  const window = {};\n  let formed = 0;\n  let minLen = Infinity;\n  let minStart = 0;\n  \n  // Expand window\n  while (right < s.length) {\n    const char = s[right];\n    \n    // Add character to window\n    window[char] = (window[char] || 0) + 1;\n    \n    // Check if we've found enough of this required character\n    if (need[char] && window[char] === need[char]) {\n      formed++;\n    }",
      "action": "continue",
      "next": "coding-shrink-js"
    },
    {
      "stepId": "coding-shrink-js",
      "mentorSays": "When all required characters are found (formed === needCount), try to shrink the window from the left to find the minimum valid window. Update the minimum window if we find a smaller one.",
      "example": "function minWindow(s, t) {\n  if (s.length === 0 || t.length === 0) return '';\n  \n  const need = {};\n  for (let char of t) {\n    need[char] = (need[char] || 0) + 1;\n  }\n  const needCount = Object.keys(need).length;\n  \n  let left = 0, right = 0;\n  const window = {};\n  let formed = 0;\n  let minLen = Infinity;\n  let minStart = 0;\n  \n  while (right < s.length) {\n    const char = s[right];\n    window[char] = (window[char] || 0) + 1;\n    \n    if (need[char] && window[char] === need[char]) {\n      formed++;\n    }\n    \n    // Try to shrink window when all characters found\n    while (formed === needCount && left <= right) {\n      // Update minimum window\n      const currentLen = right - left + 1;\n      if (currentLen < minLen) {\n        minLen = currentLen;\n        minStart = left;\n      }\n      \n      // Remove leftmost character\n      const leftChar = s[left];\n      window[leftChar]--;\n      \n      // Check if we lost a required character\n      if (need[leftChar] && window[leftChar] < need[leftChar]) {\n        formed--;\n      }\n      \n      left++;\n    }\n    \n    right++;\n  }",
      "action": "continue",
      "next": "coding-window-validation-js"
    },
    {
      "stepId": "coding-window-validation-js",
      "mentorSays": "Let's add logic to check if current window is valid.\n\nA window is valid when it contains ALL characters from t:\n- Count each character in the window\n- Compare with required counts from t\n- If window has enough of each character â†’ VALID\n\nWe track this with a 'formed' counter!",
      "example": "let formed = 0;\nlet required = Object.keys(need).length;\n\n// Check if window is valid\nif (windowCount[char] === need[char]) {\n  formed++;\n}\n\n// Window is valid when formed === required",
      "action": "continue",
      "next": "coding-window-validation-js"
    },
    {
      "stepId": "coding-return-js",
      "mentorSays": "Finally, return the minimum window substring. If no valid window was found, return an empty string.",
      "example": "function minWindow(s, t) {\n  if (s.length === 0 || t.length === 0) return '';\n  \n  const need = {};\n  for (let char of t) {\n    need[char] = (need[char] || 0) + 1;\n  }\n  const needCount = Object.keys(need).length;\n  \n  let left = 0, right = 0;\n  const window = {};\n  let formed = 0;\n  let minLen = Infinity;\n  let minStart = 0;\n  \n  while (right < s.length) {\n    const char = s[right];\n    window[char] = (window[char] || 0) + 1;\n    \n    if (need[char] && window[char] === need[char]) {\n      formed++;\n    }\n    \n    while (formed === needCount && left <= right) {\n      const currentLen = right - left + 1;\n      if (currentLen < minLen) {\n        minLen = currentLen;\n        minStart = left;\n      }\n      \n      const leftChar = s[left];\n      window[leftChar]--;\n      \n      if (need[leftChar] && window[leftChar] < need[leftChar]) {\n        formed--;\n      }\n      \n      left++;\n    }\n    \n    right++;\n  }\n  \n  // Return result\n  return minLen === Infinity ? '' : s.substring(minStart, minStart + minLen);\n}",
      "action": "continue",
      "next": "completion"
    },
    {
      "stepId": "completion",
      "mentorSays": "ðŸŽ‰ **Congratulations!** You just solved Minimum window substring!\n\n**What you've mastered:**\nâœ“ Understanding the problem requirements\nâœ“ Choosing an efficient approach\nâœ“ Building a complete solution from scratch\n\nYou're now ready to tackle more algorithms. Keep going! ðŸš€",
      "action": "complete"
    }
  ],
  "migrated": true,
  "migration_version": "5.0-light-touch",
  "migration_date": "2025-12-30"
}