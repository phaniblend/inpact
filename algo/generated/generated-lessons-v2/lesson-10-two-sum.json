{
  "id": "two-sum",
  "title": "Two Sum",
  "pattern": "hash map (complement lookup)",
  "difficulty": "easy",
  "language": "javascript",
  "status": "AI-GENERATED-V2-BATCH",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 10,
    "tier": "FOUNDATION",
    "lessonOrderTag": "FOUNDATION-10",
    "introduces": [
      "complement-calculation",
      "one-pass-hash-map",
      "index-storage"
    ],
    "assumesAlreadyTaught": [
      "arrays",
      "loops",
      "objects",
      "hash-map-concept"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "best-time-buy-sell-stock"
    ]
  },
  "problemStatement": {
    "description": "Find two numbers in an array that add up to a target value. Return the indices of these two numbers.",
    "inputs": [
      "nums: array of integers (length 2 to 10^4)",
      "target: integer sum to find"
    ],
    "outputs": [
      "Array of two indices [i, j] where nums[i] + nums[j] == target. Exactly one solution exists."
    ],
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "nums[0] + nums[1] = 2 + 7 = 9. At i=1, complement = 9-7=2, found in map at index 0, return [0,1]."
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]",
        "explanation": "nums[1] + nums[2] = 2 + 4 = 6. At i=2, complement = 6-4=2, found in map at index 1, return [1,2]."
      },
      {
        "input": "nums = [3,3], target = 6",
        "output": "[0,1]",
        "explanation": "nums[0] + nums[1] = 3 + 3 = 6. At i=1, complement = 6-3=3, found in map at index 0, return [0,1]."
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists"
    ],
    "realWorldUse": [
      "Finding pairs that sum to target (e.g., two products that cost target amount)",
      "Complement lookup in databases",
      "Pair matching algorithms",
      "Financial calculations (finding two transactions that sum to target)"
    ]
  },
  "patternRecognition": {
    "whyThisPattern": "Brute force checking all pairs is O(n¬≤). Using a hash map to store seen numbers allows O(1) complement lookup, reducing time to O(n). We trade O(n) space for O(n) time instead of O(n¬≤).",
    "signalsToRecognize": [
      "SIGNAL 1: Problem asks to find two elements that sum to target ‚Üí think complement lookup",
      "SIGNAL 2: Need to avoid O(n¬≤) nested loops ‚Üí hash map for O(1) lookups",
      "SIGNAL 3: Looking for pairs or complements ‚Üí hash map stores what we've seen"
    ],
    "patternRules": [
      "If problem involves finding pairs that sum to target ‚Üí use complement lookup with hash map",
      "When you see 'two sum', 'pair', or 'complement' ‚Üí consider hash map approach",
      "If O(n) time needed (better than O(n¬≤)) ‚Üí hash map trades space for time"
    ],
    "whyNotOtherApproaches": {
      "greedy": "Greedy doesn't apply - we need to check all possible pairs, not make local optimal choices.",
      "bruteForce": "Nested loops checking all pairs is O(n¬≤). Hash map approach is O(n) with O(1) complement lookup.",
      "alternative": "Sorting then using two pointers works but is O(n log n). Hash map is O(n) and doesn't require sorting."
    }
  },
  "coreInvariant": {
    "statement": "At index i, the map contains all numbers from indices [0..i-1] with their indices. If complement (target - nums[i]) exists in the map, we've found the pair.",
    "explanation": "This invariant holds because we store each number with its index as we iterate. When we check if complement exists, we're checking if we've seen the number that pairs with current number to sum to target. The map always contains numbers we've already processed.",
    "whyItMatters": "This invariant guarantees correctness: by the time we check for complement at index i, all previous numbers are in the map. If complement exists, we have both indices needed for the solution."
  },
  "stateDefinition": {
    "states": [
      {
        "name": "map",
        "meaning": "Hash map storing number ‚Üí index mappings for numbers seen so far",
        "indexing": "Number as key, index as value"
      },
      {
        "name": "nums",
        "meaning": "Array of numbers",
        "indexing": "0-indexed array"
      },
      {
        "name": "target",
        "meaning": "Target sum to find",
        "indexing": "Integer value"
      },
      {
        "name": "complement",
        "meaning": "Target - nums[i] (the number we're looking for to complete the pair)",
        "indexing": "Calculated value: target - current number"
      }
    ],
    "baseCases": [
      "If array has exactly 2 elements: check if they sum to target, return [0,1] if yes",
      "Solution guaranteed to exist (constraint states exactly one solution)"
    ]
  },
  "transitionLogic": {
    "rules": [
      {
        "condition": "For each index i, calculate complement = target - nums[i]",
        "transition": "If complement exists in map: return [map[complement], i]",
        "explanation": "We found the pair! The complement was seen earlier at map[complement], current number is at i.",
        "example": "nums=[2,7,11,15], target=9, i=1: complement=9-7=2, map[2]=0 exists, return [0,1]"
      },
      {
        "condition": "If complement not in map:",
        "transition": "map[nums[i]] = i (store current number and index for future lookups)",
        "explanation": "Current number might be the complement for a future number. Store it in map.",
        "example": "nums=[2,7,11,15], target=9, i=0: complement=9-2=7 not in map, store map[2]=0"
      }
    ],
    "decisionTree": {
      "root": "For each index i, calculate complement and check if it exists in map",
      "branches": [
        "If complement in map: return [map[complement], i] (pair found)",
        "If complement not in map: store nums[i] ‚Üí i in map, continue",
        "Continue until pair is found (guaranteed to exist)"
      ]
    }
  },
  "walkthrough": {
    "example": "nums = [2,7,11,15], target = 9",
    "steps": [
      {
        "step": 1,
        "description": "Initialize: map = {}, i = 0",
        "state": "map = {}, i = 0, nums[0] = 2, target = 9",
        "logic": "Start with empty map, ready to store seen numbers",
        "result": "Begin processing"
      },
      {
        "step": 2,
        "description": "i=0: complement = 9 - 2 = 7, not in map, store map[2] = 0",
        "state": "map = {2: 0}, i = 0, complement = 7",
        "logic": "Complement 7 not found, store current number 2 for future lookups",
        "result": "map = {2: 0}"
      },
      {
        "step": 3,
        "description": "i=1: complement = 9 - 7 = 2, found in map at index 0!",
        "state": "map = {2: 0}, i = 1, nums[1] = 7, complement = 2",
        "logic": "Complement 2 exists in map at index 0. Pair found: nums[0]=2 and nums[1]=7 sum to 9.",
        "result": "Return [0, 1]"
      }
    ],
    "keyInsight": "Hash map enables O(1) complement lookup. Instead of checking all previous numbers (O(n) per element), we instantly check if complement exists. This transforms O(n¬≤) brute force into O(n) solution by trading space for time."
  },
  "commonMistakes": [
    {
      "mistake": "Looking for current number in map instead of complement",
      "symptom": "Wrong logic - checking if nums[i] exists instead of checking if (target - nums[i]) exists",
      "fix": "Always calculate complement = target - nums[i] and check if complement is in map",
      "example": "At i=1 with nums[i]=7, don't check if 7 is in map. Check if complement 9-7=2 is in map."
    },
    {
      "mistake": "Storing complement in map instead of current number",
      "symptom": "Wrong values stored, won't find pairs correctly",
      "fix": "Store current number: map[nums[i]] = i, not map[complement] = i",
      "example": "Store map[7] = 1, not map[2] = 1 (when at index 1 with value 7)"
    },
    {
      "mistake": "Checking map before storing (may miss pairs with same value)",
      "symptom": "Works but less efficient - storing then checking is fine too",
      "fix": "Either order works, but checking before storing is slightly more efficient",
      "example": "Can check complement first, then store. Or store first, then check (but may store unnecessarily)"
    },
    {
      "mistake": "Returning numbers instead of indices",
      "symptom": "Wrong return type - problem asks for indices, not values",
      "fix": "Return [map[complement], i] which are indices, not [complement, nums[i]]",
      "example": "Return [0, 1] not [2, 7]"
    },
    {
      "mistake": "Using nested loops (brute force) instead of hash map",
      "symptom": "O(n¬≤) time complexity instead of O(n)",
      "fix": "Use hash map for O(1) complement lookup, achieving O(n) time",
      "example": "Nested loops check all pairs: for i in range(n): for j in range(i+1, n). Hash map avoids this."
    }
  ],
  "interviewTalkTrack": {
    "script": [
      "This is a complement lookup problem using hash maps.",
      "",
      "I'll use a hash map to store seen numbers:",
      "- Initialize empty map",
      "- For each index i:",
      "  - Calculate complement = target - nums[i]",
      "  - If complement exists in map: return [map[complement], i]",
      "  - Else: store nums[i] ‚Üí i in map",
      "- Continue until pair is found",
      "",
      "Time complexity: O(n) - single pass through array, O(1) map operations",
      "Space complexity: O(n) - map may store all elements in worst case",
      "",
      "Edge cases:",
      "- Exactly one solution guaranteed (constraint)",
      "- Same number twice (e.g., [3,3], target=6): handled correctly",
      "- Negative numbers: handled (complement calculation works for negatives)"
    ]
  },
  "variants": {
    "easier": {
      "problem": "Two Sum (sorted array)",
      "approachChange": "Array is sorted, can use two pointers instead of hash map",
      "solution": "Two pointers from both ends. If sum < target, move left pointer right. If sum > target, move right pointer left. O(n) time, O(1) space."
    },
    "harder": {
      "problem": "Three Sum",
      "approachChange": "Find three numbers that sum to target. Fix one number, then solve two sum for remaining two.",
      "solution": "Sort array first. For each number, use two pointers to find two other numbers that sum to (target - current). O(n¬≤) time."
    }
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Initialize map = {} (hash map: number ‚Üí index)"
    },
    {
      "id": "ps2",
      "text": "For each index i from 0 to nums.length - 1:"
    },
    {
      "id": "ps3",
      "text": "  Calculate complement = target - nums[i]"
    },
    {
      "id": "ps4",
      "text": "  If complement is in map: return [map[complement], i]"
    },
    {
      "id": "ps5",
      "text":  "  Else: store map[nums[i]] = i"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "Hey! Ready to level up your problem-solving skills? We just conquered Contains Duplicate, and now we're tackling the classic Two Sum problem! This is where things get really exciting because we're introducing a super powerful pattern: the **hash map complement lookup**. Instead of checking every pair of numbers (which is slow), we'll use a hash map to instantly find the \"complement\" - the missing piece that adds up to our target. It's like having a perfect memory that remembers exactly what we need!\n\nHere are the 3 key skills you'll master:\n‚Ä¢ **Complement thinking** - quickly identify what value you need to complete a pair\n‚Ä¢ **Hash map optimization** - transform slow nested loops into lightning-fast lookups\n‚Ä¢ **One-pass efficiency** - solve problems while scanning through data just once\n\nThis pattern is absolutely fundamental and shows up everywhere in coding interviews and real-world applications. You're building some serious algorithmic muscle here! Let's dive in!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Before we dive into the problem, which programming language would you like to use?\n\nThis will help me make sure you have the right building blocks.",
      "choices": [
        {
          "label": "üíõ JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "üêç Python",
          "next": "prereq-check-python"
        },
        {
          "label": "‚òï Java",
          "next": "prereq-check-java"
        },
        {
          "label": "‚ö° C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "üíô TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in JavaScript, you'll need to know:\n- **Array indexing** - Accessing elements in an array using their position/index\n- **Hash map lookup** - Storing and retrieving key-value pairs in constant time\n- **Nested loops** - Understanding how to iterate through array elements multiple times\n- **Target decomposition** - Breaking down a target value into component parts to search for\n\nDo you feel confident with these JavaScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-js"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Array indexing:** Access elements using `nums[i]` where `i` is the position (0-based).\n\n**Hash map lookup:** Use `Map` or objects `{}` to store key-value pairs. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence - all in O(1) time.\n\n**Nested loops:** Two loops inside each other check every pair, but it's slow (O(n¬≤)).\n\n**Target decomposition:** If `a + b = target`, then `b = target - a`. We call `b` the complement of `a`.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Array indexing:** `nums[0]` gets first element, `nums[i]` gets element at position i.\n\n**Hash map:** `const map = new Map()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks if key exists.\n\n**Loops:** `for (let i = 0; i < nums.length; i++)` iterates through array.\n\n**Complement:** If target is 9 and current number is 2, complement is 9 - 2 = 7.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Python, you'll need to know:\n- **Array indexing** - Accessing elements in an array using their position/index\n- **Hash map lookup** - Storing and retrieving key-value pairs in constant time\n- **Nested loops** - Understanding how to iterate through array elements multiple times\n- **Target decomposition** - Breaking down a target value into component parts to search for\n\nDo you feel confident with these Python concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-python"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Array indexing:** Access elements using `nums[i]` where `i` is the position (0-based).\n\n**Hash map lookup:** Use dictionaries `{}` to store key-value pairs. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence - all in O(1) time.\n\n**Nested loops:** Two loops inside each other check every pair, but it's slow (O(n¬≤)).\n\n**Target decomposition:** If `a + b = target`, then `b = target - a`. We call `b` the complement of `a`.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Array indexing:** `nums[0]` gets first element, `nums[i]` gets element at position i.\n\n**Hash map:** `seen = {}` creates a dict. `seen[key] = value` stores, `seen[key]` retrieves, `key in seen` checks if key exists.\n\n**Loops:** `for i in range(len(nums))` iterates through array.\n\n**Complement:** If target is 9 and current number is 2, complement is 9 - 2 = 7.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Java, you'll need to know:\n- **Array indexing** - Accessing elements in an array using their position/index\n- **Hash map lookup** - Storing and retrieving key-value pairs in constant time\n- **Nested loops** - Understanding how to iterate through array elements multiple times\n- **Target decomposition** - Breaking down a target value into component parts to search for\n\nDo you feel confident with these Java concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-java"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Array indexing:** Access elements using `nums[i]` where `i` is the position (0-based).\n\n**Hash map lookup:** Use `HashMap<Integer, Integer>` to store key-value pairs. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence - all in O(1) time.\n\n**Nested loops:** Two loops inside each other check every pair, but it's slow (O(n¬≤)).\n\n**Target decomposition:** If `a + b = target`, then `b = target - a`. We call `b` the complement of `a`.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Array indexing:** `nums[0]` gets first element, `nums[i]` gets element at position i.\n\n**Hash map:** `Map<Integer, Integer> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks if key exists.\n\n**Loops:** `for (int i = 0; i < nums.length; i++)` iterates through array.\n\n**Complement:** If target is 9 and current number is 2, complement is 9 - 2 = 7.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in C++, you'll need to know:\n- **Array indexing** - Accessing elements in an array using their position/index\n- **Hash map lookup** - Storing and retrieving key-value pairs in constant time\n- **Nested loops** - Understanding how to iterate through array elements multiple times\n- **Target decomposition** - Breaking down a target value into component parts to search for\n\nDo you feel confident with these C++ concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Array indexing:** Access elements using `nums[i]` where `i` is the position (0-based).\n\n**Hash map lookup:** Use `unordered_map<int, int>` to store key-value pairs. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence - all in O(1) time.\n\n**Nested loops:** Two loops inside each other check every pair, but it's slow (O(n¬≤)).\n\n**Target decomposition:** If `a + b = target`, then `b = target - a`. We call `b` the complement of `a`.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Array indexing:** `nums[0]` gets first element, `nums[i]` gets element at position i.\n\n**Hash map:** `unordered_map<int, int> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks if key exists.\n\n**Loops:** `for (int i = 0; i < nums.size(); i++)` iterates through array.\n\n**Complement:** If target is 9 and current number is 2, complement is 9 - 2 = 7.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in TypeScript, you'll need to know:\n- **Array indexing** - Accessing elements in an array using their position/index\n- **Hash map lookup** - Storing and retrieving key-value pairs in constant time\n- **Nested loops** - Understanding how to iterate through array elements multiple times\n- **Target decomposition** - Breaking down a target value into component parts to search for\n\nDo you feel confident with these TypeScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Array indexing:** Access elements using `nums[i]` where `i` is the position (0-based).\n\n**Hash map lookup:** Use `Map<number, number>` to store key-value pairs. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence - all in O(1) time.\n\n**Nested loops:** Two loops inside each other check every pair, but it's slow (O(n¬≤)).\n\n**Target decomposition:** If `a + b = target`, then `b = target - a`. We call `b` the complement of `a`.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Array indexing:** `nums[0]` gets first element, `nums[i]` gets element at position i.\n\n**Hash map:** `const map = new Map<number, number>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks if key exists.\n\n**Loops:** `for (let i = 0; i < nums.length; i++)` iterates through array.\n\n**Complement:** If target is 9 and current number is 2, complement is 9 - 2 = 7.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "Perfect! Now let's understand what the Two Sum problem asks for.\n\nImagine you're at a grocery store with exactly $10, and you need to buy two items that add up to your budget. You walk down the aisles, and for each item you see (like a $3 bread), you mentally check if there's a $7 item you remember seeing earlier that would complete your $10 total. This is exactly how the Two Sum algorithm works - it remembers previous values in a hash map and checks if the \"complement\" needed to reach the target sum exists.\n\n# The Two Sum Problem\n\nHey! So the **Two Sum** problem is one of those classic coding challenges that's actually pretty straightforward once you get it.\n\n## What it's asking\n\nYou're given an array of numbers and a target number. Your job is to find **two numbers in the array that add up to the target**, and return their **indices** (positions in the array).\n\nThe key things to remember:\n- You need to return the **positions** of the numbers, not the numbers themselves\n- There's guaranteed to be exactly one solution\n- You can't use the same element twice\n\n## Let's walk through an example\n\nSay you have:\n- `nums = [2, 7, 11, 15]` \n- `target = 9`\n\nYou'd return `[0, 1]`.\n\n## Why does this work?\n\nLet's trace through it:\n- The number at index 0 is `2`\n- The number at index 1 is `7` \n- And `2 + 7 = 9`, which matches our target!\n\nSo we return `[0, 1]` - the indices where we found our two numbers.\n\nIf we had tried other combinations:\n- `2 + 11 = 13` (too big)\n- `2 + 15 = 17` (too big)  \n- `7 + 11 = 18` (too big)\n- `7 + 15 = 22` (way too big)\n\nOnly `2 + 7` gives us exactly `9`, so `[0, 1]` is our answer.\n\nPretty neat, right? The tricky part is usually figuring out how to do this efficiently, but that's the core idea!",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "You're solving the Two Sum problem: given an array of integers and a target sum, find two numbers that add up to the target. You're at index i examining number 7, with target 9. What should you look for in your hash map?",
      "choices": [
        {
          "label": "Look for the number 7 in the hash map",
          "next": "wrong-choice"
        },
        {
          "label": "Look for the number 2 (target - current number = 9 - 7 = 2) in the hash map",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-choice",
      "mentorSays": "This is tempting because you might think you need to check if the current number already exists. However, this would only help you find duplicates of the same number, not find two different numbers that sum to the target.",
      "action": "next",
      "next": "brute-force-rejection"
    },
    {
      "stepId": "brute-force-rejection",
      "mentorSays": "### Explicit Brute Force Rejection (O(n¬≤))\n\n**Why we reject nested loops:**\n\n**Brute force approach:**\n```javascript\nfor (let i = 0; i < nums.length; i++) {\n  for (let j = i + 1; j < nums.length; j++) {\n    if (nums[i] + nums[j] === target) {\n      return [i, j];\n    }\n  }\n}\n```\n\n**Time complexity:** O(n¬≤) - for each of n elements, we check n-1 other elements\n**Space complexity:** O(1) - no extra space needed\n\n**Why this fails:**\n- With n=10,000: ~50 million pair checks\n- With n=1,000,000: ~500 billion checks\n- **This doesn't scale** for production systems\n\n**We need O(n) time complexity** - hash map gives us instant lookups instead of nested loops.",
      "action": "next",
      "next": "invariant-definition"
    },
    {
      "stepId": "invariant-definition",
      "mentorSays": "### Core Invariant (CRITICAL)\n\n**Invariant:** At index i, the hash map contains all numbers (and their indices) that appear before index i.\n\n**Why this matters:**\n- When we're at index i, we've already processed indices 0 through i-1\n- The map remembers all those previous numbers\n- We can instantly check if the complement of nums[i] exists in those previous numbers\n\n**Concrete example:**\n```\nnums = [2, 7, 11, 15], target = 9\n\nAt i=0: map = {} (empty, no numbers before index 0)\nAt i=1: map = {2: 0} (contains number 2 from index 0)\n  ‚Üí num=7, need=9-7=2\n  ‚Üí 2 is in map at index 0 ‚úì\n  ‚Üí Return [0, 1]\n```\n\n**The invariant guarantees:** When we check for complement at index i, we're only checking numbers we've already seen, which is exactly what we need!",
      "action": "next",
      "next": "why-on2-fails"
    },
    {
      "stepId": "why-on2-fails",
      "mentorSays": "### Why O(n¬≤) Fails at Scale\n\n**Interview reasoning:**\n\n- **Brute force approach:** Check every pair with nested loops\n- **With n=10,000 elements:** That's ~50 million pair checks\n- **With n=1,000,000 elements:** That's ~500 billion checks!\n- **This doesn't scale** for production systems\n\n**We need O(n) time complexity.**\n\n**The tradeoff:** We trade space (O(n) for the hash map) for time (O(n) instead of O(n¬≤)).\n\n**This is a fundamental interview pattern:** Space-time tradeoff. Interviewers want to see you recognize when brute force fails and optimize accordingly.",
      "action": "next",
      "next": "why-map-works"
    },
    {
      "stepId": "why-map-works",
      "mentorSays": "### Why Map Works: The Intuition\n\n**Interview talk track:**\n\n1. **We need O(n) time** - can't check every pair (that's O(n¬≤))\n2. **We trade space for time** - use a hash map for O(1) lookups\n3. **The map stores \"what we've seen\"** - as we iterate, we remember numbers and their indices\n4. **For each number, we ask: \"Have I seen its complement?\"** - if yes, we found the pair\n5. **Hash maps give instant lookups** - O(1) instead of O(n) linear search\n\n**The magic:** Instead of searching through all previous numbers, the map gives us instant answers.\n\n**Example:** With array [2, 7, 11, 15] and target 9: when we reach 7, we check if complement 9-7=2 exists in our map - it does, so we return the indices of 2 and 7.",
      "action": "next",
      "next": "pattern-recognition",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "pattern-recognition",
      "mentorSays": "### Pattern Recognition: Hash Map for Complement Lookup\n\n**This problem follows the \"complement lookup\" pattern:**\n- **Hash map storage** - Store numbers and their indices as we iterate\n- **Complement calculation** - For each number, calculate target - num\n- **Instant lookup** - Check if complement exists in map (O(1) lookup)\n- **Single pass** - Process array in one iteration\n\n**Similar problems:**\n- Three Sum (extends two sum)\n- Four Sum (further extension)\n- Two Sum II (sorted array variant)\n- Contains Duplicate (similar hash map usage)\n\n**Key insight:** Instead of checking all pairs (O(n¬≤)), we use a hash map to instantly check if the complement exists. This trades O(n) space for O(n) time instead of O(n¬≤).",
      "action": "next",
      "next": "state-definition"
    },
    {
      "stepId": "state-definition",
      "mentorSays": "### State Definition: Complement Lookup State\n\n**State variables:**\n- **`map`** - Hash map storing number ‚Üí index mappings\n- **`nums`** - Array of numbers\n- **`target`** - Target sum\n- **`i`** - Current index being processed\n- **`complement`** - Target - nums[i] (what we're looking for)\n\n**State transitions:**\n1. **Initialize:** map = {}\n2. **Loop:** For each index i:\n   - Calculate complement = target - nums[i]\n   - If complement in map: return [map[complement], i]\n   - Else: map[nums[i]] = i (store for future lookups)\n3. **Result:** Return indices if found, or empty array if not found\n\n**State validity:** Map contains all numbers from indices [0..i-1] with their indices. When complement is found, we have the pair.",
      "action": "next",
      "next": "why-alternatives-fail"
    },
    {
      "stepId": "why-alternatives-fail",
      "mentorSays": "### Why Alternative Approaches Fail\n\n**Approach 1: Nested Loops (Brute Force)**\n- **Why it fails:** O(n¬≤) time complexity\n- **Issue:** For each element, check all other elements\n- **Better:** Hash map gives O(n) time with O(1) lookups\n\n**Approach 2: Sort Then Two Pointers**\n- **Why it doesn't fail:** Actually works, but loses original indices\n- **Issue:** Need to track original indices, more complex\n- **Better:** Hash map preserves indices naturally\n\n**Approach 3: Binary Search for Complement**\n- **Why it fails:** Requires sorted array, O(n log n) to sort\n- **Issue:** Still O(n log n) time, loses original indices\n- **Better:** Hash map is O(n) time, preserves indices\n\n**Our approach wins because:** Hash map with complement lookup finds the pair in O(n) time with O(n) space, which is optimal. The space-time tradeoff is favorable, and we preserve original indices naturally.",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "The key insight is to use a **hash map** to store each number and its index as we iterate through the array, then for each current number, check if its **complement** (target - current number) already exists in the map. This works because if we've seen the complement before, we've found our pair that sums to the target. This achieves **O(n) time complexity** instead of O(n¬≤) by trading space for time efficiency.",
      "action": "next",
      "next": "walkthrough",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "Let's trace through `nums=[2,7,11,15], target=9` with detailed steps:\n\n**Initial:** map = {}, target = 9\n\n**Step 1: i=0, num=2**\n- Calculate complement: 9 - 2 = 7\n- Check map: 7 not in map (map is empty)\n- Store: map[2] = 0\n- Map state: {2: 0}\n\n**Step 2: i=1, num=7**\n- Calculate complement: 9 - 7 = 2\n- Check map: 2 is in map! (stored at index 0)\n- **Found pair!** Return [map[2], 1] = [0, 1]\n\n**Final answer: [0, 1]**\n\n**Key insight:** At i=1, we need complement=2. The invariant guarantees that map contains all numbers before index 1, so 2 (from index 0) is already in the map. This is exactly what we need!",
      "action": "next",
      "next": "pseudocode-step",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "Here's our plan written as pseudocode:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now let's translate this into JavaScript, building it step by step.\n\nRemember: we'll add just 1-3 lines at a time!",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Create function signature and initialize empty map to store numbers and their indices\n\n```javascript\nfunction twoSum(nums, target) {\n    const map = new Map();\n}\n```",
      "action": "next",
      "next": "code-02",
      "pseudocodeLineIds": [
        "ps1"
      ],
      "example": "function twoSum(nums, target) {\n    const map = new Map();"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Start loop to iterate through each number in the array\n\n```javascript\nfunction twoSum(nums, target) {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n    }\n}\n```",
      "action": "next",
      "next": "code-03",
      "pseudocodeLineIds": [
        "ps2"
      ],
      "example": "    for (let i = 0; i < nums.length; i++) {"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Get current number and calculate complement (what we need to find)\n\n```javascript\nfunction twoSum(nums, target) {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const num = nums[i];\n        const complement = target - num;\n    }\n}\n```",
      "action": "next",
      "next": "code-04",
      "pseudocodeLineIds": [
        "ps3"
      ],
      "example": "        const num = nums[i];\n        const complement = target - num;"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Check if complement exists in map - if found, we have our answer\n\n```javascript\nfunction twoSum(nums, target) {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const num = nums[i];\n        const complement = target - num;\n        if (map.has(complement)) {\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-05",
      "pseudocodeLineIds": [
        "ps4"
      ],
      "example": "        if (map.has(complement)) {"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Return indices of complement (from map) and current number\n\n```javascript\nfunction twoSum(nums, target) {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const num = nums[i];\n        const complement = target - num;\n        if (map.has(complement)) {\n            return [map.get(complement), i];\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-06",
      "pseudocodeLineIds": [
        "ps5"
      ],
      "example": "            return [map.get(complement), i];"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Store current number and its index in map for future complement checks\n\n```javascript\nfunction twoSum(nums, target) {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const num = nums[i];\n        const complement = target - num;\n        if (map.has(complement)) {\n            return [map.get(complement), i];\n        }\n        map.set(num, i);\n    }\n}\n```",
      "action": "next",
      "next": "code-07",
      "pseudocodeLineIds": [
        "ps6"
      ],
      "example": "        map.set(num, i);"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Add return statement for edge case (though problem guarantees solution exists)\n\n```javascript\nfunction twoSum(nums, target) {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const num = nums[i];\n        const complement = target - num;\n        if (map.has(complement)) {\n            return [map.get(complement), i];\n        }\n        map.set(num, i);\n    }\n    return [];\n}\n```",
      "action": "next",
      "next": "wrap-up",
      "pseudocodeLineIds": [
        "ps7"
      ],
      "example": "    return [];"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Storing before checking** - If you store `map.set(num, i)` before checking for complement, you might use the same element twice\n2. **Using wrong map method** - In JavaScript, use `map.has()` and `map.get()`, not `map[key]` (that's for objects)\n3. **Forgetting to return indices** - Make sure to return `[map.get(complement), i]` not the values\n4. **Off-by-one errors** - Remember array indices start at 0\n5. **Not handling edge cases** - Empty array, single element (though problem guarantees solution exists)",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use a hash map to store numbers I've seen and their indices\"**\n2. **\"For each number, I calculate its complement (target - current) and check if I've seen it\"**\n3. **\"If the complement exists in the map, I return both indices\"**\n4. **\"Otherwise, I store the current number and its index for future lookups\"**\n5. **\"This gives us O(n) time and O(n) space, trading space for time efficiency\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "Great work mastering the Two Sum problem and the powerful hash map complement lookup pattern! You've learned one of the most fundamental techniques in algorithm design - using a hash map to transform a brute force O(n¬≤) solution into an efficient O(n) approach by storing complements for instant lookup.\n\n**Follow-up variant:**\n\n**Two Sum II - Input array is sorted:** How would you solve this if the array is already sorted? (Hint: Two pointers from both ends!)\n\nNext, we'll tackle the Best Time to Buy and Sell Stock problem, where you'll discover how to find optimal solutions using single-pass algorithms and tracking key values as you iterate.",
      "action": "complete"
    }
  ]
}