{
  "id": "group-anagrams",
  "title": "Group Anagrams - Canonical Form Hashing",
  "pattern": "hash-map-grouping",
  "difficulty": "medium",
  "language": "javascript",
  "status": "AI-GENERATED-V2-DIRECT",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 72,
    "tier": "MASTERY-II",
    "lessonOrderTag": "MASTERY-II-72",
    "introduces": [
      "canonical-form",
      "hash-grouping",
      "character-frequency"
    ],
    "assumesAlreadyTaught": [
      "hash-maps",
      "arrays",
      "strings"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "top-k-frequent-elements"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Create a hash map to store groups"
    },
    {
      "id": "ps2",
      "text": "For each string in array:"
    },
    {
      "id": "ps3",
      "text": "  Create canonical form (sorted or character count)"
    },
    {
      "id": "ps4",
      "text": "  Use canonical form as key in hash map"
    },
    {
      "id": "ps5",
      "text": "  Add string to the group for that key"
    },
    {
      "id": "ps6",
      "text": "Return all groups as an array"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "# Welcome to Group Anagrams! üî§\n\nTime to master one of the most elegant uses of hash maps!\n\n## What You'll Master:\n\n- Using canonical forms for grouping\n- Hash map strategies for similar items\n- Character frequency techniques\n- Efficient string comparison\n\nThis pattern is used in spell-checkers, word games, and text analysis!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Which programming language would you like to use for this lesson?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "Python",
          "next": "prereq-check-python"
        },
        {
          "label": "Java",
          "next": "prereq-check-java"
        },
        {
          "label": "C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "To solve this in JavaScript, you'll need to know:\n\n- **Hash maps** (Map or Object)\n- **String manipulation**\n- **Array sorting**\n- **Grouping patterns**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-js"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "To solve this in Python, you'll need to know:\n\n- **Dictionaries** for hash maps\n- **String manipulation**\n- **List sorting**\n- **defaultdict** (optional)\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-python"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "To solve this in Java, you'll need to know:\n\n- **HashMap** class\n- **String manipulation**\n- **Arrays.sort()**\n- **ArrayList**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-java"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "To solve this in C++, you'll need to know:\n\n- **unordered_map**\n- **String manipulation**\n- **sort() algorithm**\n- **Vectors**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "To solve this in TypeScript, you'll need to know:\n\n- **Map<K,V>** generic type\n- **String manipulation**\n- **Array sorting**\n- **Type annotations**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "# The Problem: Group Anagrams üìù\n\n**Real-world analogy:** You're building a word game app like Scrabble. When users enter words, you need to quickly group together all words that are anagrams of each other (same letters, different order). For example, \"eat\", \"tea\", and \"ate\" should all be in the same group.\n\n## The Challenge:\n\nGiven an array of strings `strs`, group the anagrams together. You can return the answer in any order.\n\nAn anagram is a word formed by rearranging the letters of another word.\n\n## Example:\n```\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\nExplanation:\n- \"eat\", \"tea\", \"ate\" are anagrams\n- \"tan\", \"nat\" are anagrams  \n- \"bat\" is alone\n```\n\n**Key insight:** Anagrams have the same characters with the same frequencies!",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "# ü§î How Can We Identify Anagrams?\n\nWe need a way to recognize that \"eat\" and \"tea\" are anagrams.\n\n**Question:** What's a good way to create a unique identifier for all anagrams of a word?",
      "choices": [
        {
          "label": "Compare each word with every other word - O(n¬≤)",
          "next": "wrong-compare-all"
        },
        {
          "label": "Sort the characters - sorted form is the same for all anagrams",
          "next": "core-idea"
        },
        {
          "label": "Count character frequencies and use as a key",
          "next": "alternative-approach"
        }
      ]
    },
    {
      "stepId": "wrong-compare-all",
      "mentorSays": "That would work but is very inefficient! With n words, we'd do n¬≤ comparisons.\n\nWe need something that can group words in one pass...",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "# The Key Insight: Canonical Form! üí°\n\n**Brilliant!** Use the sorted string as a \"canonical form\" - a unique identifier for all anagrams.\n\n## The Strategy:\n\n**\"eat\"** ‚Üí sort ‚Üí **\"aet\"**\n**\"tea\"** ‚Üí sort ‚Üí **\"aet\"**  \n**\"ate\"** ‚Üí sort ‚Üí **\"aet\"**\n\nAll anagrams produce the same sorted string!\n\n## The Algorithm:\n\n1. Create a hash map where:\n   - Key = sorted version of string\n   - Value = array of original strings\n\n2. For each word:\n   - Sort its characters\n   - Add it to the group for that sorted form\n\n3. Return all groups\n\n## Why This Works:\n\nSorting normalizes the strings - all anagrams become identical after sorting, so they map to the same hash bucket!",
      "action": "next",
      "next": "alternative-approach"
    },
    {
      "stepId": "alternative-approach",
      "mentorSays": "# Comparison of Key Strategies üìä\n\nThere are **two main approaches** to create keys for anagrams:\n\n## Strategy 1: Sorted Key\n\n**\"eat\"** ‚Üí sort ‚Üí **\"aet\"**\n**\"tea\"** ‚Üí sort ‚Üí **\"aet\"**\n**\"ate\"** ‚Üí sort ‚Üí **\"aet\"**\n\n**Implementation:**\n```javascript\nconst key = str.split('').sort().join('');\n```\n\n**Pros:**\n- Simple, clean code\n- Easy to understand\n\n**Cons:**\n- O(k log k) per word (k = word length)\n\n## Strategy 2: Frequency Key\n\n**\"eat\"** ‚Üí count ‚Üí `[1,0,0,0,1,0,...,1,...]` (a=1, e=1, t=1)\n**\"tea\"** ‚Üí count ‚Üí `[1,0,0,0,1,0,...,1,...]` (same frequencies)\n\n**Implementation:**\n```javascript\nconst count = new Array(26).fill(0);\nfor (let char of str) count[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\nconst key = count.join(',');\n```\n\n**Pros:**\n- O(k) per word (faster for long words)\n- More efficient for large inputs\n\n**Cons:**\n- More complex code\n- Requires array allocation\n\n**Interview depth upgrade:** Knowing both strategies shows deeper understanding!",
      "action": "next",
      "next": "pattern-recognition"
    },
    {
      "stepId": "pattern-recognition",
      "mentorSays": "### Pattern Recognition: Hash Map Grouping by Canonical Form\n\n**This problem follows the \"grouping by key\" pattern:**\n- **Canonical form** - Create a unique identifier for all anagrams\n- **Hash map grouping** - Use canonical form as key, group original strings as values\n- **Key strategies** - Sorted string or frequency array as canonical form\n- **Single pass** - Process all strings in one iteration\n\n**Similar problems:**\n- Valid Anagram (check if two strings are anagrams)\n- Group Anagrams (same problem)\n- Find All Anagrams in String (sliding window variant)\n\n**Key insight:** All anagrams produce the same canonical form (sorted string or frequency array). Using this as a hash map key naturally groups all anagrams together.",
      "action": "next",
      "next": "invariant"
    },
    {
      "stepId": "invariant",
      "mentorSays": "### Invariant: Map Groups Strings by Canonical Form\n\n**Invariant maintained throughout:**\n- **Key uniqueness:** Each canonical form maps to exactly one group\n- **Anagram grouping:** All strings with same canonical form are in same group\n- **Completeness:** All strings are added to exactly one group\n- **Order preservation:** Original strings are preserved in groups\n\n**Why this works:**\n- Anagrams have identical character frequencies\n- Sorted form or frequency array captures this identity\n- Strings with same canonical form are anagrams\n- Hash map naturally groups by key\n\n**Invariant guarantee:** After processing all strings, the map contains groups where each group contains all anagrams of each other. Strings in different groups are not anagrams.",
      "action": "next",
      "next": "state-definition"
    },
    {
      "stepId": "state-definition",
      "mentorSays": "### State Definition: Anagram Grouping State\n\n**State variables:**\n- **`map`** - Hash map: canonical form ‚Üí array of strings\n- **`strs`** - Array of input strings\n- **`key`** - Canonical form of current string (sorted or frequency array)\n\n**State transitions:**\n1. **Initialize:** map = {}\n2. **Loop:** For each string str in strs:\n   - Calculate key (sorted string or frequency array)\n   - If key not in map: map[key] = []\n   - Add str to map[key]\n3. **Result:** Return all values from map as array of arrays\n\n**State validity:** After processing, map contains all strings grouped by their canonical forms.",
      "action": "next",
      "next": "why-alternatives-fail"
    },
    {
      "stepId": "why-alternatives-fail",
      "mentorSays": "### Why Alternative Approaches Fail\n\n**Approach 1: Compare Each String with All Others**\n- **Why it fails:** O(n¬≤ * k) time complexity\n- **Issue:** For each string, check all other strings for anagram match\n- **Better:** Hash map grouping is O(n * k) or O(n * k log k)\n\n**Approach 2: Sort All Strings Then Group Adjacent**\n- **Why it fails:** Doesn't work correctly\n- **Issue:** Sorting strings doesn't group anagrams together\n- **Better:** Use canonical form (sorted characters) as key\n\n**Approach 3: Use Set of Character Counts**\n- **Why it fails:** Sets can't be used as map keys directly\n- **Issue:** Need to convert to string/array for key\n- **Better:** Use sorted string or frequency array as key\n\n**Our approach wins because:** Hash map grouping by canonical form groups all anagrams in O(n * k) or O(n * k log k) time. The canonical form (sorted or frequency) naturally identifies anagrams, making grouping efficient and intuitive.",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "# Let's Walk Through an Example üö∂\n\n```\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n```\n\n**Process \"eat\":**\n- Sort: \"eat\" ‚Üí \"aet\"\n- map[\"aet\"] = [\"eat\"]\n\n**Process \"tea\":**\n- Sort: \"tea\" ‚Üí \"aet\"\n- map[\"aet\"] = [\"eat\", \"tea\"]\n\n**Process \"tan\":**\n- Sort: \"tan\" ‚Üí \"ant\"\n- map[\"ant\"] = [\"tan\"]\n\n**Process \"ate\":**\n- Sort: \"ate\" ‚Üí \"aet\"\n- map[\"aet\"] = [\"eat\", \"tea\", \"ate\"]\n\n**Process \"nat\":**\n- Sort: \"nat\" ‚Üí \"ant\"\n- map[\"ant\"] = [\"tan\", \"nat\"]\n\n**Process \"bat\":**\n- Sort: \"bat\" ‚Üí \"abt\"\n- map[\"abt\"] = [\"bat\"]\n\n**Final map:**\n```\n\"aet\" ‚Üí [\"eat\", \"tea\", \"ate\"]\n\"ant\" ‚Üí [\"tan\", \"nat\"]\n\"abt\" ‚Üí [\"bat\"]\n```\n\n**Return:** [[\"eat\",\"tea\",\"ate\"], [\"tan\",\"nat\"], [\"bat\"]]",
      "action": "next",
      "next": "pseudocode-step"
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "# Here's Our Battle Plan üìã",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "# Time to Code! üíª\n\nWe'll use a Map to group anagrams by their sorted form.",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Start with creating the hash map:\n\n```javascript\nfunction groupAnagrams(strs) {\n    const map = new Map();\n```",
      "action": "next",
      "next": "code-02",
      "example": "function groupAnagrams(strs) {\n    const map = new Map();"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Iterate through each string:\n\n```javascript\n    for (const str of strs) {\n```",
      "action": "next",
      "next": "code-03",
      "example": "    for (const str of strs) {"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Create the canonical form by sorting:\n\n```javascript\n        const sorted = str.split('').sort().join('');\n```\n\nThis converts \"eat\" ‚Üí ['e','a','t'] ‚Üí ['a','e','t'] ‚Üí \"aet\"",
      "action": "next",
      "next": "code-04",
      "example": "        const sorted = str.split('').sort().join('');"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Check if group exists, create if not:\n\n```javascript\n        if (!map.has(sorted)) {\n            map.set(sorted, []);\n        }\n```",
      "action": "next",
      "next": "code-05",
      "example": "        if (!map.has(sorted)) {\n            map.set(sorted, []);\n        }"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Add the original string to its group:\n\n```javascript\n        map.get(sorted).push(str);\n    }\n```",
      "action": "next",
      "next": "code-06",
      "example": "        map.get(sorted).push(str);\n    }"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Return all groups as an array:\n\n```javascript\n    return Array.from(map.values());\n}\n```\n\nmap.values() gives us all the arrays, Array.from() converts to an array of arrays!",
      "action": "next",
      "next": "complexity-analysis",
      "example": "    return Array.from(map.values());\n}"
    },
    {
      "stepId": "complexity-analysis",
      "mentorSays": "# Complexity Analysis üìä\n\n## Time Complexity: O(n √ó k log k)\n- n = number of strings\n- k = maximum length of a string\n- For each string: O(k log k) to sort\n- Total: O(n √ó k log k)\n\n## Space Complexity: O(n √ó k)\n- Hash map stores all n strings\n- Keys are sorted strings (up to k characters each)\n- Total: O(n √ó k) space\n\n## Alternative with Frequency Counting:\n\n**Time:** O(n √ó k) - faster!\n**Space:** O(n √ó k) - same\n\nBut sorting is simpler to implement and k is usually small, so the difference is negligible in practice.",
      "action": "next",
      "next": "edge-cases"
    },
    {
      "stepId": "edge-cases",
      "mentorSays": "# Edge Cases üéØ\n\n1. **Empty array:** [] ‚Üí []\n\n2. **Single string:** [\"a\"] ‚Üí [[\"a\"]]\n\n3. **No anagrams:** [\"abc\", \"def\", \"ghi\"] ‚Üí [[\"abc\"], [\"def\"], [\"ghi\"]]\n\n4. **All anagrams:** [\"abc\", \"bca\", \"cab\"] ‚Üí [[\"abc\", \"bca\", \"cab\"]]\n\n5. **Empty strings:** [\"\", \"\"] ‚Üí [[\"\", \"\"]] (empty strings are anagrams of each other!)\n\n6. **Case sensitivity:** [\"Eat\", \"eat\"] ‚Üí Different groups (case matters)\n\nOur solution handles all these correctly!",
      "action": "next",
      "next": "common-mistakes"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "# Congratulations! üéâ\n\nYou've mastered **canonical form hashing** for grouping!\n\n## What You Learned:\n\n‚úÖ Using sorted strings as unique identifiers\n‚úÖ Hash map grouping patterns\n‚úÖ When to normalize data for comparison\n‚úÖ Alternative approaches (frequency counting)\n\n## Next Steps:\n\nReady for another hash map pattern? The next lesson is **Top K Frequent Elements** - using hash maps with heaps or bucket sort. Similar grouping concept, different optimization!\n\nThis canonical form pattern appears everywhere: deduplication, grouping, comparison.\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}