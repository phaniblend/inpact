{
  "id": "first-unique-character",
  "title": "First Unique Character in a String",
  "pattern": "frequency map",
  "difficulty": "easy",
  "language": "javascript",
  "status": "AI-GENERATED-V2-BATCH",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 24,
    "tier": "FOUNDATION",
    "lessonOrderTag": "FOUNDATION-24",
    "introduces": [
      "two-pass-technique",
      "count-then-check"
    ],
    "assumesAlreadyTaught": [
      "strings",
      "objects",
      "frequency-counting"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "intersection-of-two-arrays"
    ]
  },
  "problemStatement": {
    "description": "Find the first non-repeating character in a string and return its index. If no such character exists, return -1.",
    "inputs": [
      "s: string of lowercase English letters (length 1 to 10^5)"
    ],
    "outputs": [
      "Integer: index of first unique character, or -1 if none exists"
    ],
    "examples": [
      {
        "input": "s = \"leetcode\"",
        "output": "0",
        "explanation": "First pass: count frequencies. 'l' appears once, 'e' appears 3 times, etc. Second pass: first character with count=1 is 'l' at index 0."
      },
      {
        "input": "s = \"loveleetcode\"",
        "output": "2",
        "explanation": "First pass: count all characters. Second pass: 'l' appears twice, 'o' appears once but 'v' at index 2 appears once first, so return 2."
      },
      {
        "input": "s = \"aabb\"",
        "output": "-1",
        "explanation": "All characters repeat. No unique character, return -1."
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of only lowercase English letters"
    ],
    "realWorldUse": [
      "String analysis and validation",
      "Finding first occurrence patterns",
      "Character frequency analysis",
      "Data processing pipelines"
    ]
  },
  "patternRecognition": {
    "whyThisPattern": "We need global frequency information before identifying unique characters. A two-pass approach: first pass counts all characters, second pass finds the first with count=1.",
    "signalsToRecognize": [
      "SIGNAL 1: Problem asks for first unique/non-repeating character ‚Üí think two-pass frequency counting",
      "SIGNAL 2: Need global information before making decision ‚Üí count first, then find",
      "SIGNAL 3: Frequency-based problem ‚Üí use hash map for counting"
    ],
    "patternRules": [
      "If problem involves finding first unique element ‚Üí use two-pass: count then find",
      "When you see 'first unique', 'non-repeating', or 'frequency' ‚Üí consider frequency map",
      "If need to preserve order while checking frequency ‚Üí two-pass approach"
    ],
    "whyNotOtherApproaches": {
      "greedy": "Greedy doesn't apply - we need complete frequency information before identifying unique characters.",
      "bruteForce": "For each character, scanning entire string to check uniqueness is O(n¬≤). Two-pass is O(n).",
      "alternative": "Single pass with early exit doesn't work - we need to see all characters before knowing which are unique."
    }
  },
  "coreInvariant": {
    "statement": "After the first pass, the frequency map contains the count of every character in the string. During the second pass, the first character with count=1 is the first unique character.",
    "explanation": "This invariant holds because we count all characters in the first pass, giving us complete frequency information. In the second pass, we check each character's frequency in original order, so the first one with count=1 is the answer.",
    "whyItMatters": "This invariant guarantees correctness: by counting first, we have all information needed. By checking in original order, we find the first unique character."
  },
  "stateDefinition": {
    "states": [
      {
        "name": "charCount",
        "meaning": "Hash map storing character ‚Üí frequency count",
        "indexing": "Character as key, count as value"
      },
      {
        "name": "s",
        "meaning": "String being analyzed",
        "indexing": "0-indexed string"
      },
      {
        "name": "i",
        "meaning": "Current index in second pass",
        "indexing": "0-indexed, iterates from 0 to n-1"
      }
    ],
    "baseCases": [
      "If string is empty: return -1",
      "If all characters repeat: return -1 after second pass"
    ]
  },
  "transitionLogic": {
    "rules": [
      {
        "condition": "First pass: For each character c in s:",
        "transition": "charCount[c] = (charCount[c] || 0) + 1",
        "explanation": "Count frequency of each character. Increment count for each occurrence.",
        "example": "s=\"leetcode\": charCount['l']=1, charCount['e']=3, charCount['t']=1, etc."
      },
      {
        "condition": "Second pass: For each index i from 0 to n-1:",
        "transition": "If charCount[s[i]] == 1: return i",
        "explanation": "Check if current character has count 1. If yes, it's unique and first in order, return index.",
        "example": "s=\"leetcode\", i=0: charCount['l']=1, return 0"
      },
      {
        "condition": "After second pass completes:",
        "transition": "return -1 (no unique character found)",
        "explanation": "No character had count 1, all characters repeat.",
        "example": "s=\"aabb\": all characters have count >= 2, return -1"
      }
    ],
    "decisionTree": {
      "root": "Count all characters first, then find first with count=1",
      "branches": [
        "First pass: count frequency of each character",
        "Second pass: check each character in order",
        "If count == 1: return index immediately",
        "If no character with count == 1: return -1"
      ]
    }
  },
  "walkthrough": {
    "example": "s = \"leetcode\"",
    "steps": [
      {
        "step": 1,
        "description": "First pass: Count all characters",
        "state": "charCount = {'l':1, 'e':3, 't':1, 'c':1, 'o':1, 'd':1}",
        "logic": "Count frequency of each character",
        "result": "Frequency map complete"
      },
      {
        "step": 2,
        "description": "Second pass: i=0, s[0]='l', charCount['l']=1, return 0",
        "state": "i = 0, charCount['l'] = 1",
        "logic": "First character with count=1 found",
        "result": "Return 0"
      }
    ],
    "keyInsight": "Two-pass approach separates counting from finding. First pass gathers all frequency information, second pass finds the first unique character in original order. This is more efficient than checking uniqueness for each character individually."
  },
  "commonMistakes": [
    {
      "mistake": "Trying to find unique character in single pass",
      "symptom": "Can't determine uniqueness until seeing entire string",
      "fix": "Use two-pass: count all characters first, then find first with count=1",
      "example": "In single pass, you can't know if 'l' is unique until you've seen the entire string"
    },
    {
      "mistake": "Not checking characters in original order",
      "symptom": "May return wrong character (not the first unique)",
      "fix": "In second pass, iterate from index 0 to n-1, return first with count=1",
      "example": "If you check in different order, you might return a later unique character"
    },
    {
      "mistake": "Using array.includes() to check uniqueness",
      "symptom": "O(n¬≤) time complexity instead of O(n)",
      "fix": "Use frequency map for O(1) lookup, achieving O(n) total time",
      "example": "For each character, array.includes() scans entire array, making it O(n¬≤)"
    },
    {
      "mistake": "Not handling case where no unique character exists",
      "symptom": "May return undefined or wrong value",
      "fix": "After second pass, if no character with count=1 found, return -1",
      "example": "For s=\"aabb\", all characters repeat, return -1"
    },
    {
      "mistake": "Counting incorrectly (off-by-one or missing characters)",
      "symptom": "Wrong frequency counts, incorrect answer",
      "fix": "Ensure all characters are counted: charCount[c] = (charCount[c] || 0) + 1",
      "example": "If you miss counting a character, its frequency will be wrong"
    }
  ],
  "interviewTalkTrack": {
    "script": [
      "This is a two-pass frequency counting problem.",
      "",
      "I'll use a frequency map:",
      "- First pass: count frequency of each character",
      "- Second pass: iterate through string, return first character with count=1",
      "- If no unique character: return -1",
      "",
      "Time complexity: O(n) - two passes through string, O(1) map operations",
      "Space complexity: O(k) where k is number of unique characters (at most 26 for lowercase)",
      "",
      "Edge cases:",
      "- All characters repeat: return -1",
      "- Single character: return 0",
      "- First character is unique: return 0 immediately in second pass"
    ]
  },
  "variants": {
    "easier": {
      "problem": "First Unique Character (case-insensitive)",
      "approachChange": "Treat uppercase and lowercase as same character",
      "solution": "Convert to lowercase before counting, or use case-insensitive comparison in frequency map"
    },
    "harder": {
      "problem": "First Unique Character in a Stream",
      "approachChange": "Characters arrive one at a time, need to find first unique in current stream",
      "solution": "Maintain frequency map and queue. For each new character, update frequency. Remove from queue if it becomes non-unique. Queue head is first unique."
    }
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Create charCount = {} (frequency map)"
    },
    {
      "id": "ps2",
      "text": "First pass: For each character c in s: charCount[c] = (charCount[c] || 0) + 1"
    },
    {
      "id": "ps3",
      "text": "Second pass: For each index i from 0 to s.length - 1:"
    },
    {
      "id": "ps4",
      "text": "  If charCount[s[i]] == 1: return i"
    },
    {
      "id": "ps5",
      "text": "Return -1 (no unique character)"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "Hey! Ready to tackle a classic string problem? Today we're diving into \"First Unique Character in a String\" - and you're going to learn one of the most powerful patterns in programming: the frequency map!\n\nThis technique is like having a super organized filing system that tracks how often things appear. You'll use it constantly in interviews and real coding situations.\n\nHere's what you'll master:\n‚Ä¢ Build and use hash maps to count character frequencies efficiently\n‚Ä¢ Apply the two-pass technique to solve complex problems step by step  \n‚Ä¢ Recognize when frequency counting is the key to unlocking a solution\n\nThis pattern will become your go-to tool for so many string and array problems. Let's dive in!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Before we dive into the problem, which programming language would you like to use?\n\nThis will help me make sure you have the right building blocks.",
      "choices": [
        {
          "label": "üíõ JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "üêç Python",
          "next": "prereq-check-python"
        },
        {
          "label": "‚òï Java",
          "next": "prereq-check-java"
        },
        {
          "label": "‚ö° C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "üíô TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in JavaScript, you'll need to know:\n- **String-indexing** - Accessing characters in a string by position\n- **Hash-maps** - Using key-value data structures to store and retrieve data\n- **Frequency-counting** - Counting occurrences of elements in a collection\n- **String-iteration** - Traversing through all characters in a string sequentially\n\nDo you feel confident with these JavaScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-js"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Python, you'll need to know:\n- **String-indexing** - Accessing characters in a string by position\n- **Hash-maps** - Using key-value data structures to store and retrieve data\n- **Frequency-counting** - Counting occurrences of elements in a collection\n- **String-iteration** - Traversing through all characters in a string sequentially\n\nDo you feel confident with these Python concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-python"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Java, you'll need to know:\n- **String-indexing** - Accessing characters in a string by position\n- **Hash-maps** - Using key-value data structures to store and retrieve data\n- **Frequency-counting** - Counting occurrences of elements in a collection\n- **String-iteration** - Traversing through all characters in a string sequentially\n\nDo you feel confident with these Java concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-java"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in C++, you'll need to know:\n- **String-indexing** - Accessing characters in a string by position\n- **Hash-maps** - Using key-value data structures to store and retrieve data\n- **Frequency-counting** - Counting occurrences of elements in a collection\n- **String-iteration** - Traversing through all characters in a string sequentially\n\nDo you feel confident with these C++ concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in TypeScript, you'll need to know:\n- **String-indexing** - Accessing characters in a string by position\n- **Hash-maps** - Using key-value data structures to store and retrieve data\n- **Frequency-counting** - Counting occurrences of elements in a collection\n- **String-iteration** - Traversing through all characters in a string sequentially\n\nDo you feel confident with these TypeScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "Perfect! Now let's understand what the First Unique Character in a String problem asks for.\n\nImagine you're a teacher taking attendance in a classroom where some students have the same first name. You go through your class list from left to right, and you want to find the first student whose name appears only once in the entire class - you'd need to count how many times each name appears, then go back through your list to find the first name that had a count of exactly one.\n\n# First Unique Character in a String\n\n## The Problem\nYou need to find the **first character** in a string that appears exactly once, and return its index position. If no such character exists, return -1.\n\n## Example Walkthrough\nLet's say we have the string `\"leetcode\"`:\n\n```\nl e e t c o d e\n0 1 2 3 4 5 6 7\n```\n\n**Answer: 0** (the index of \"l\")\n\n## Why This Works\nLet's count how many times each character appears:\n- **l**: appears 1 time ‚úì\n- **e**: appears 4 times (positions 1, 2, 7, and... wait, let me recount: positions 1, 2, 7) = 3 times\n- **t**: appears 1 time ‚úì  \n- **c**: appears 1 time ‚úì\n- **o**: appears 1 time ‚úì\n- **d**: appears 1 time ‚úì\n\nSo we have several unique characters: l, t, c, o, d. But we want the **first** one that appears exactly once. Reading left to right, \"l\" at index 0 is the first character that appears exactly once in the string.\n\nThat's why the answer is 0!",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "You need to find the first character that appears exactly once in a string. What's your strategy?",
      "choices": [
        {
          "label": "For each character, scan the entire string to count its occurrences, return the first one with count=1",
          "next": "wrong-choice"
        },
        {
          "label": "First pass: build a frequency map of all characters. Second pass: iterate through the string and return the first character with frequency=1",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-choice",
      "mentorSays": "This creates O(n¬≤) time complexity because for each of the n characters, you're scanning the entire string again. You're doing redundant work by recounting characters you've already seen.",
      "action": "next",
      "next": "pattern-recognition"
    },
    {
      "stepId": "pattern-recognition",
      "mentorSays": "### Pattern Recognition: Two-Pass Frequency Counting\n\n**This problem follows the \"frequency map + linear scan\" pattern:**\n- **First pass:** Build frequency map of all characters\n- **Second pass:** Find first character with frequency = 1\n- **Hash map for counting** - Efficient O(1) lookups and updates\n\n**Similar problems:**\n- Valid Anagram (frequency counting)\n- Group Anagrams (frequency-based grouping)\n- Longest Substring Without Repeating (frequency tracking)\n\n**Key insight:** We need global frequency information before we can identify unique characters. A two-pass approach separates the counting phase from the finding phase, making the algorithm clear and efficient.",
      "action": "next",
      "next": "invariant"
    },
    {
      "stepId": "invariant",
      "mentorSays": "### Invariant: Frequency Map Contains Complete Counts\n\n**Invariant maintained throughout:**\n- **After first pass:** `charCount` contains the frequency of every character in the string\n- **During second pass:** We can determine if a character is unique by checking `charCount[char] === 1`\n- **Order preservation:** Second pass maintains the original order, so first unique character found is the answer\n\n**Why this works:**\n- First pass: Count all characters ‚Üí O(n) time\n- Second pass: Check each character's frequency ‚Üí O(n) time, O(1) per lookup\n- We return the first character (by original order) that has frequency 1\n\n**Invariant guarantee:** After the first pass, `charCount[char]` accurately represents how many times `char` appears in the entire string. During the second pass, when we find the first character with `charCount[char] === 1`, it is guaranteed to be the first unique character.",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "The key insight is to use a **two-pass approach** where the first pass counts the frequency of all characters, and the second pass finds the first character with a count of 1. This works because we need **global frequency information** before we can determine which characters are unique - we can't know if a character is truly unique until we've seen the entire string. The separation of concerns (counting vs. finding) makes the algorithm both **simple and efficient** at O(n) time complexity.",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "Let's trace through `\"leetcode\"`:\n\n- Step 1: Count frequency of each character: l=1, e=3, t=1, c=1, o=1, d=1\n- Step 2: Check index 0 ('l'): frequency is 1, so it's unique - return index 0\n- Final answer: **0 (index of \"l\")**",
      "action": "next",
      "next": "pseudocode-step",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "Here's our plan written as pseudocode:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now let's translate this into JavaScript, building it step by step.\n\nRemember: we'll add just 1-3 lines at a time!",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Create function signature and initialize character count map\n\n```javascript\nfunction firstUniqChar(s) {\n    const charCount = new Map();\n}\n```",
      "action": "next",
      "next": "code-02",
      "pseudocodeLineIds": [
        "ps1"
      ],
      "example": "function firstUniqChar(s) {\n    const charCount = new Map();\n}"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Pass 1: Loop through string to count each character occurrence\n\n```javascript\nfunction firstUniqChar(s) {\n    const charCount = new Map();\n    \n    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n    }\n}\n```",
      "action": "next",
      "next": "code-03",
      "pseudocodeLineIds": [
        "ps2"
      ],
      "example": "    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n    }"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Update character count in map (increment if exists, set to 1 if new)\n\n```javascript\nfunction firstUniqChar(s) {\n    const charCount = new Map();\n    \n    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n        charCount.set(char, (charCount.get(char) || 0) + 1);\n    }\n}\n```",
      "action": "next",
      "next": "code-04",
      "pseudocodeLineIds": [
        "ps3"
      ],
      "example": "        charCount.set(char, (charCount.get(char) || 0) + 1);"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Pass 2: Start second loop to find first character with count = 1\n\n```javascript\nfunction firstUniqChar(s) {\n    const charCount = new Map();\n    \n    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n        charCount.set(char, (charCount.get(char) || 0) + 1);\n    }\n    \n    for (let i = 0; i < s.length; i++) {\n    }\n}\n```",
      "action": "next",
      "next": "code-05",
      "pseudocodeLineIds": [
        "ps4"
      ],
      "example": "    for (let i = 0; i < s.length; i++) {\n    }"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Check if current character has count of 1 in our map\n\n```javascript\nfunction firstUniqChar(s) {\n    const charCount = new Map();\n    \n    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n        charCount.set(char, (charCount.get(char) || 0) + 1);\n    }\n    \n    for (let i = 0; i < s.length; i++) {\n        if (charCount.get(s[i]) === 1) {\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-06",
      "pseudocodeLineIds": [
        "ps5"
      ],
      "example": "        if (charCount.get(s[i]) === 1) {\n        }"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Return the index when we find first unique character\n\n```javascript\nfunction firstUniqChar(s) {\n    const charCount = new Map();\n    \n    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n        charCount.set(char, (charCount.get(char) || 0) + 1);\n    }\n    \n    for (let i = 0; i < s.length; i++) {\n        if (charCount.get(s[i]) === 1) {\n            return i;\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-07",
      "pseudocodeLineIds": [
        "ps6"
      ],
      "example": "            return i;"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Return -1 if no unique character is found after checking all characters\n\n```javascript\nfunction firstUniqChar(s) {\n    const charCount = new Map();\n    \n    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n        charCount.set(char, (charCount.get(char) || 0) + 1);\n    }\n    \n    for (let i = 0; i < s.length; i++) {\n        if (charCount.get(s[i]) === 1) {\n            return i;\n        }\n    }\n    \n    return -1;\n}\n```",
      "action": "next",
      "next": "common-mistakes",
      "pseudocodeLineIds": [
        "ps7"
      ],
      "example": "    return -1;"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "Great work mastering frequency maps! You've learned how to efficiently track character occurrences and use that data to solve string problems in a single pass. Next, we'll tackle intersection-of-two-arrays, where you'll apply similar counting techniques to find common elements between datasets.\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}