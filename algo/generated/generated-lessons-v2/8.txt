E:\projects\inpact\inpact\algo\generated\generated-lessons-v2\lesson-56-minimum-window-substring.json:
{
  "id": "minimum-window-substring",
  "title": "Minimum Window Substring",
  "pattern": "sliding window (advanced)",
  "difficulty": "hard",
  "language": "javascript",
  "status": "AI-GENERATED-V2-DIRECT",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 56,
    "tier": "EXPERT",
    "lessonOrderTag": "EXPERT-56",
    "introduces": [
      "template-matching",
      "window-validity",
      "minimum-window"
    ],
    "assumesAlreadyTaught": [
      "sliding-window-concept",
      "hash-map",
      "variable-window"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "find-median-data-stream"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Count target characters in t"
    },
    {
      "id": "ps2",
      "text": "Expand window: add right character to window counts"
    },
    {
      "id": "ps3",
      "text": "When window valid (contains all t chars): contract"
    },
    {
      "id": "ps4",
      "text": "While contracting, track minimum window"
    },
    {
      "id": "ps5",
      "text": "Remove left character, check if still valid"
    },
    {
      "id": "ps6",
      "text": "Return minimum window found"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "Hey! **Minimum Window Substring** - one of the toughest sliding window problems!\n\nThis teaches advanced window management: expanding to find valid windows, contracting to minimize.\n\nYou'll learn:\n‚Ä¢ Variable window with validity checks\n‚Ä¢ Frequency-based matching\n‚Ä¢ Expand-contract rhythm\n\nLet's dive in!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Which language?",
      "choices": [
        {
          "label": "üíõ JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "üêç Python",
          "next": "prereq-check-python"
        },
        {
          "label": "‚òï Java",
          "next": "prereq-check-java"
        },
        {
          "label": "‚ö° C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "üíô TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "Prerequisites:\n- **Sliding window**\n- **Hash map**\n- **Variable window**\n\nReady?",
      "choices": [
        {
          "label": "Yes",
          "next": "problem-understanding"
        },
        {
          "label": "No",
          "next": "teach-prereqs-js"
        },
        {
          "label": "Some",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let's quickly recap the basics you'll need for this problem.",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Let's quickly recap the basics you'll need for this problem.",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "Prerequisites:\n- **Sliding window**\n- **Hash map**\n- **Variable window**",
      "choices": [
        {
          "label": "Yes",
          "next": "problem-understanding"
        },
        {
          "label": "No",
          "next": "teach-prereqs-python"
        },
        {
          "label": "Some",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let's quickly recap the basics you'll need for this problem.",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Let's quickly recap the basics you'll need for this problem.",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "Prerequisites:\n- **Sliding window**\n- **Hash map**\n- **Variable window**",
      "choices": [
        {
          "label": "Yes",
          "next": "problem-understanding"
        },
        {
          "label": "No",
          "next": "teach-prereqs-java"
        },
        {
          "label": "Some",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let's quickly recap the basics you'll need for this problem.",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Let's quickly recap the basics you'll need for this problem.",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "Prerequisites:\n- **Sliding window**\n- **Hash map**\n- **Variable window**",
      "choices": [
        {
          "label": "Yes",
          "next": "problem-understanding"
        },
        {
          "label": "No",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "Some",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let's quickly recap the basics you'll need for this problem.",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Let's quickly recap the basics you'll need for this problem.",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "Prerequisites:\n- **Sliding window**\n- **Hash map**\n- **Variable window**",
      "choices": [
        {
          "label": "Yes",
          "next": "problem-understanding"
        },
        {
          "label": "No",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "Some",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let's quickly recap the basics you'll need for this problem.",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Let's quickly recap the basics you'll need for this problem.",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "**Finding a needle in a haystack** - but you want the SMALLEST haystack section containing the needle!\n\nGiven strings `s` and `t`, find the **minimum window** in `s` which contains all characters from `t` (including duplicates).\n\nExample:\n```\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\n```\nOutput: `\"BANC\"`\n\nThe window \"BANC\" is the smallest substring containing A, B, C.",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "How to find minimum window efficiently?",
      "choices": [
        {
          "label": "Check every substring",
          "next": "wrong-choice"
        },
        {
          "label": "Expand window until valid, then contract to minimize",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-choice",
      "mentorSays": "Checking all substrings is O(n¬≥)!\n\nSliding window with expand-contract is O(n).",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "The key: **expand to satisfy, contract to minimize**.\n\n1. Count characters needed from t\n2. **Expand** window right: add chars until window valid\n3. Once valid: **contract** from left while still valid\n4. Track minimum window during contraction\n5. Repeat\n\nThis ensures we find the smallest valid window!",
      "action": "next",
      "next": "formed-vs-required-invariant"
    },
    {
      "stepId": "formed-vs-required-invariant",
      "mentorSays": "### Formed vs Required Invariant\n\n**Window validity condition:**\n\n- **`required`** = number of unique characters in `t` that must appear in window\n- **`formed`** = number of unique characters in current window that have satisfied their frequency requirement\n\n**Invariant:** Window is valid when `formed == required`\n\n**Example:**\n```\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\n\nrequired = 3 (need A, B, C)\n\nWindow \"ADOBEC\":\n  A: need 1, have 1 ‚Üí satisfied ‚úì\n  B: need 1, have 1 ‚Üí satisfied ‚úì\n  C: need 1, have 1 ‚Üí satisfied ‚úì\n  formed = 3 == required = 3 ‚Üí VALID!\n\nWindow \"DOBEC\":\n  A: need 1, have 0 ‚Üí NOT satisfied\n  B: need 1, have 1 ‚Üí satisfied ‚úì\n  C: need 1, have 1 ‚Üí satisfied ‚úì\n  formed = 2 != required = 3 ‚Üí INVALID\n```\n\n**Why extra chars don't matter:**\n\n- Extra characters (like 'D', 'O', 'E') don't affect validity\n- Only characters in `t` matter for the `formed` count\n- Having more than needed frequency is fine (e.g., 2 A's when need 1)\n- **Window validity = all required chars have sufficient frequency, regardless of extras**\n\n**This invariant guides our algorithm:** We expand until `formed == required`, then contract while maintaining this equality.",
      "action": "next",
      "next": "walkthrough",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "Tracing s=\"ADOBECODEBANC\", t=\"ABC\":\n\n- Expand to \"ADOBEC\" - valid! (has A,B,C)\n- Contract: \"DOBEC\" - still valid\n- Contract: \"OBEC\" - invalid (no A), stop\n- Continue expanding...\n- Find \"CODEBA\" - valid\n- Contract to \"BA\" - invalid\n- Final \"BANC\" is minimum!\n\nAnswer: **\"BANC\"** (length 4)",
      "action": "next",
      "next": "pseudocode-step",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "Pseudocode:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Let's build this!",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Count target frequencies.\n\n```javascript\nfunction minWindow(s, t) {\n  const need = {};\n  for (const char of t) {\n    need[char] = (need[char] || 0) + 1;\n  }\n  let required = Object.keys(need).length;\n}\n```",
      "action": "next",
      "next": "code-02",
      "pseudocodeLineIds": [
        "ps1"
      ],
      "example": "const need = {};\nfor (const char of t) need[char] = (need[char] || 0) + 1;\nlet required = Object.keys(need).length;"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Initialize window and tracking variables.\n\n```javascript\nfunction minWindow(s, t) {\n  const need = {};\n  for (const char of t) {\n    need[char] = (need[char] || 0) + 1;\n  }\n  let required = Object.keys(need).length;\n  \n  let left = 0, formed = 0;\n  const windowCounts = {};\n  let result = [Infinity, 0, 0];\n}\n```",
      "action": "next",
      "next": "code-03",
      "pseudocodeLineIds": [
        "ps2"
      ],
      "example": "let left = 0, formed = 0;\nconst windowCounts = {};\nlet result = [Infinity, 0, 0];"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Expand window and check validity.\n\n```javascript\nfunction minWindow(s, t) {\n  const need = {};\n  for (const char of t) need[char] = (need[char] || 0) + 1;\n  let required = Object.keys(need).length;\n  let left = 0, formed = 0;\n  const windowCounts = {};\n  let result = [Infinity, 0, 0];\n  \n  for (let right = 0; right < s.length; right++) {\n    const char = s[right];\n    windowCounts[char] = (windowCounts[char] || 0) + 1;\n    if (need[char] && windowCounts[char] === need[char]) formed++;\n  }\n}\n```",
      "action": "next",
      "next": "code-04",
      "pseudocodeLineIds": [
        "ps2",
        "ps3"
      ],
      "example": "for (let right = 0; right < s.length; right++) {\n  const char = s[right];\n  windowCounts[char] = (windowCounts[char] || 0) + 1;\n  if (need[char] && windowCounts[char] === need[char]) formed++;"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Contract window when valid.\n\n```javascript\nfunction minWindow(s, t) {\n  const need = {};\n  for (const char of t) need[char] = (need[char] || 0) + 1;\n  let required = Object.keys(need).length;\n  let left = 0, formed = 0;\n  const windowCounts = {};\n  let result = [Infinity, 0, 0];\n  \n  for (let right = 0; right < s.length; right++) {\n    const char = s[right];\n    windowCounts[char] = (windowCounts[char] || 0) + 1;\n    if (need[char] && windowCounts[char] === need[char]) formed++;\n    \n    while (formed === required) {\n      if (right - left + 1 < result[0]) {\n        result = [right - left + 1, left, right];\n      }\n      const leftChar = s[left];\n      windowCounts[leftChar]--;\n      if (need[leftChar] && windowCounts[leftChar] < need[leftChar]) formed--;\n      left++;\n    }\n  }\n  \n  return result[0] === Infinity ? \"\" : s.substring(result[1], result[2] + 1);\n}\n```",
      "action": "next",
      "next": "wrap-up",
      "pseudocodeLineIds": [
        "ps3",
        "ps4",
        "ps5",
        "ps6"
      ],
      "example": "while (formed === required) {\n  if (right - left + 1 < result[0]) result = [right - left + 1, left, right];\n  const leftChar = s[left];\n  windowCounts[leftChar]--;\n  if (need[leftChar] && windowCounts[leftChar] < need[leftChar]) formed--;\n  left++;"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "Amazing! **Minimum Window Substring** conquered!\n\nThis pattern powers:\n‚Ä¢ Fuzzy string matching\n‚Ä¢ DNA sequence analysis\n‚Ä¢ Text search\n\nNext: **Find Median from Data Stream** - dual heap mastery!\n\nYou're unstoppable! üöÄ",
      "action": "complete"
    }
  ]
}

================================================================================

E:\projects\inpact\inpact\algo\generated\generated-lessons-v2\lesson-57-find-median-data-stream.json:
{
  "id": "find-median-data-stream",
  "title": "Find Median from Data Stream",
  "pattern": "two heaps",
  "difficulty": "hard",
  "language": "javascript",
  "status": "AI-GENERATED-V2-DIRECT",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 57,
    "tier": "EXPERT",
    "lessonOrderTag": "EXPERT-57",
    "introduces": ["heap-concept", "max-heap", "min-heap", "balanced-heaps"],
    "assumesAlreadyTaught": ["arrays", "comparison-operators", "Math.floor"],
    "prerequisiteCheckRequired": true,
    "nextRecommended": ["kth-largest-element"]
  },
  "pseudocode": [
    {"id": "ps1", "text": "Maintain two heaps: maxHeap (lower half), minHeap (upper half)"},
    {"id": "ps2", "text": "AddNum: add to maxHeap first"},
    {"id": "ps3", "text": "Balance: move maxHeap top to minHeap if needed"},
    {"id": "ps4", "text": "Rebalance: ensure heaps differ by at most 1"},
    {"id": "ps5", "text": "FindMedian: if sizes equal, average of tops; else return larger heap top"}
  ],
  "flow": [
    {"stepId": "objectives", "mentorSays": "Hey! **Find Median from Data Stream** - the two-heap pattern!\n\nThis elegant solution maintains the median in O(log n) time using two heaps working together.\n\nYou'll learn:\n‚Ä¢ Max heap and min heap concepts\n‚Ä¢ Balancing two heaps\n‚Ä¢ Finding median in constant time\n\nLet's dive in!", "action": "continue", "next": "language-selection"},
    {"stepId": "language-selection", "mentorSays": "Which language?", "choices": [{"label": "üíõ JavaScript", "next": "prereq-check-js"}, {"label": "üêç Python", "next": "prereq-check-python"}, {"label": "‚òï Java", "next": "prereq-check-java"}, {"label": "‚ö° C++", "next": "prereq-check-cpp"}, {"label": "üíô TypeScript", "next": "prereq-check-ts"}]},
    {"stepId": "prereq-check-js", "mentorSays": "Prerequisites:\n- **Arrays**\n- **Comparison operators**\n- **Math.floor**\n\nReady?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-js"}, {"label": "Some", "next": "select-prereqs-js"}]},
    {"stepId": "teach-prereqs-js", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-js", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-python", "mentorSays": "Prerequisites ready?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-python"}, {"label": "Some", "next": "select-prereqs-python"}]},
    {"stepId": "teach-prereqs-python", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-python", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-java", "mentorSays": "Prerequisites ready?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-java"}, {"label": "Some", "next": "select-prereqs-java"}]},
    {"stepId": "teach-prereqs-java", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-java", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-cpp", "mentorSays": "Prerequisites ready?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-cpp"}, {"label": "Some", "next": "select-prereqs-cpp"}]},
    {"stepId": "teach-prereqs-cpp", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-cpp", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-ts", "mentorSays": "Prerequisites ready?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-ts"}, {"label": "Some", "next": "select-prereqs-ts"}]},
    {"stepId": "teach-prereqs-ts", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-ts", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "problem-understanding", "mentorSays": "**Processing live data** - numbers arrive one at a time, and you need to report the median at any moment!\n\nDesign a data structure that supports:\n‚Ä¢ `addNum(num)`: Add number to the stream\n‚Ä¢ `findMedian()`: Return median of all numbers\n\nExample:\n```javascript\nconst mf = new MedianFinder();\nmf.addNum(1);\nmf.addNum(2);\nmf.findMedian(); // 1.5\nmf.addNum(3);\nmf.findMedian(); // 2\n```", "action": "continue", "next": "thinking-challenge"},
    {"stepId": "thinking-challenge", "mentorSays": "How to maintain median efficiently?", "choices": [{"label": "Sort array each time", "next": "wrong-choice"}, {"label": "Use two heaps: max heap for lower half, min heap for upper half", "next": "core-idea"}]},
    {"stepId": "wrong-choice", "mentorSays": "Sorting each time is O(n log n)!\n\nTwo heaps give us O(log n) insert and O(1) median lookup.", "action": "next", "next": "core-idea"},
    {"stepId": "core-idea", "mentorSays": "The key: **split data into two balanced heaps**.\n\n‚Ä¢ **MaxHeap**: Stores smaller half (largest at top)\n‚Ä¢ **MinHeap**: Stores larger half (smallest at top)\n\nBalance rule: Heaps differ by at most 1 element\n\n**Median:**\n‚Ä¢ If equal sizes: average of both tops\n‚Ä¢ If unequal: top of larger heap\n\nThis keeps median accessible in O(1)!", "action": "next", "next": "walkthrough", "pseudocodeLineIds": ["ps1", "ps2", "ps3"]},
    {"stepId": "walkthrough", "mentorSays": "Adding numbers [1,2,3]:\n\n**Add 1:** maxHeap=[1], minHeap=[]\n- Median: 1\n\n**Add 2:** maxHeap=[1], minHeap=[2]\n- Median: (1+2)/2 = 1.5\n\n**Add 3:** maxHeap=[1], minHeap=[2,3]\n- Rebalance: maxHeap=[1,2], minHeap=[3]\n- Median: 2 (top of larger heap)\n\nHeaps stay balanced!", "action": "next", "next": "pseudocode-step", "pseudocodeLineIds": ["ps1", "ps2", "ps3"]},
    {"stepId": "pseudocode-step", "mentorSays": "Pseudocode:", "action": "next", "next": "coding-intro", "pseudocodeLineIds": ["ps1", "ps2", "ps3", "ps4", "ps5"]},
    {"stepId": "coding-intro", "mentorSays": "Build it step by step!", "action": "next", "next": "code-01"},
    {"stepId": "code-01", "mentorSays": "Initialize two heaps (arrays for simplicity).\n\n```javascript\nclass MedianFinder {\n  constructor() {\n    this.maxHeap = [];\n    this.minHeap = [];\n  }\n}\n```", "action": "next", "next": "code-02", "pseudocodeLineIds": ["ps1"], "example": "constructor() {\n  this.maxHeap = [];\n  this.minHeap = [];"
    },
    {"stepId": "code-02", "mentorSays": "Implement addNum with balancing.\n\n```javascript\nclass MedianFinder {\n  constructor() {\n    this.maxHeap = [];\n    this.minHeap = [];\n  }\n  \n  addNum(num) {\n    if (this.maxHeap.length === 0 || num <= this.maxHeap[0]) {\n      this.maxHeap.push(num);\n      this.maxHeap.sort((a,b) => b-a);\n    } else {\n      this.minHeap.push(num);\n      this.minHeap.sort((a,b) => a-b);\n    }\n  }\n}\n```", "action": "next", "next": "code-03", "pseudocodeLineIds": ["ps2", "ps3"], "example": "addNum(num) {\n  if (this.maxHeap.length === 0 || num <= this.maxHeap[0]) {\n    this.maxHeap.push(num); this.maxHeap.sort((a,b) => b-a);\n  } else {\n    this.minHeap.push(num); this.minHeap.sort((a,b) => a-b);"
    },
    {"stepId": "code-03", "mentorSays": "Balance heaps.\n\n```javascript\nclass MedianFinder {\n  constructor() {\n    this.maxHeap = [];\n    this.minHeap = [];\n  }\n  \n  addNum(num) {\n    if (this.maxHeap.length === 0 || num <= this.maxHeap[0]) {\n      this.maxHeap.push(num);\n      this.maxHeap.sort((a,b) => b-a);\n    } else {\n      this.minHeap.push(num);\n      this.minHeap.sort((a,b) => a-b);\n    }\n    \n    if (this.maxHeap.length > this.minHeap.length + 1) {\n      this.minHeap.push(this.maxHeap.shift());\n      this.minHeap.sort((a,b) => a-b);\n    } else if (this.minHeap.length > this.maxHeap.length) {\n      this.maxHeap.push(this.minHeap.shift());\n      this.maxHeap.sort((a,b) => b-a);\n    }\n  }\n}\n```", "action": "next", "next": "code-04", "pseudocodeLineIds": ["ps4"], "example": "if (this.maxHeap.length > this.minHeap.length + 1) {\n  this.minHeap.push(this.maxHeap.shift());\n  this.minHeap.sort((a,b) => a-b);"
    },
    {"stepId": "code-04", "mentorSays": "Implement findMedian.\n\n```javascript\nclass MedianFinder {\n  constructor() {\n    this.maxHeap = [];\n    this.minHeap = [];\n  }\n  \n  addNum(num) {\n    if (this.maxHeap.length === 0 || num <= this.maxHeap[0]) {\n      this.maxHeap.push(num);\n      this.maxHeap.sort((a,b) => b-a);\n    } else {\n      this.minHeap.push(num);\n      this.minHeap.sort((a,b) => a-b);\n    }\n    \n    if (this.maxHeap.length > this.minHeap.length + 1) {\n      this.minHeap.push(this.maxHeap.shift());\n      this.minHeap.sort((a,b) => a-b);\n    } else if (this.minHeap.length > this.maxHeap.length) {\n      this.maxHeap.push(this.minHeap.shift());\n      this.maxHeap.sort((a,b) => b-a);\n    }\n  }\n  \n  findMedian() {\n    if (this.maxHeap.length > this.minHeap.length) {\n      return this.maxHeap[0];\n    }\n    return (this.maxHeap[0] + this.minHeap[0]) / 2;\n  }\n}\n```", "action": "next", "next": "wrap-up", "pseudocodeLineIds": ["ps5"], "example": "findMedian() {\n  if (this.maxHeap.length > this.minHeap.length) return this.maxHeap[0];\n  return (this.maxHeap[0] + this.minHeap[0]) / 2;"
    },
    {"stepId": "wrap-up", "mentorSays": "Perfect! **Two-heap pattern** mastered!\n\nUsed in:\n‚Ä¢ Running statistics\n‚Ä¢ Real-time data analysis\n‚Ä¢ Streaming algorithms\n\nNext: **Kth Largest Element** - quickselect!\n\nYou're on fire! üî•", "action": "complete"}
  ]
}


================================================================================

E:\projects\inpact\inpact\algo\generated\generated-lessons-v2\lesson-58-kth-largest-element.json:
{
  "id": "kth-largest-element",
  "title": "Kth Largest Element in Array",
  "pattern": "quickselect / heap",
  "difficulty": "medium",
  "language": "javascript",
  "status": "AI-GENERATED-V2-DIRECT",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 58,
    "tier": "EXPERT",
    "lessonOrderTag": "EXPERT-58",
    "introduces": ["quickselect-algorithm", "partition", "average-linear"],
    "assumesAlreadyTaught": ["arrays", "heap-concept", "recursion-concept"],
    "prerequisiteCheckRequired": true,
    "nextRecommended": ["merge-k-sorted-lists"]
  },
  "pseudocode": [
    {"id": "ps1", "text": "Choose pivot, partition array around it"},
    {"id": "ps2", "text": "If pivot index equals k-1, found answer"},
    {"id": "ps3", "text": "If k-1 < pivot index, search left"},
    {"id": "ps4", "text": "Else search right"},
    {"id": "ps5", "text": "Average O(n) time"}
  ],
  "flow": [
    {"stepId": "objectives", "mentorSays": "Hey! **Kth Largest Element** - learning quickselect!\n\nThis teaches an elegant O(n) average algorithm - faster than sorting!\n\nYou'll learn:\n‚Ä¢ Quickselect algorithm\n‚Ä¢ Partition technique\n‚Ä¢ When NOT to sort\n\nLet's dive in!", "action": "continue", "next": "language-selection"},
    {"stepId": "language-selection", "mentorSays": "Language?", "choices": [{"label": "üíõ JavaScript", "next": "prereq-check-js"}, {"label": "üêç Python", "next": "prereq-check-python"}, {"label": "‚òï Java", "next": "prereq-check-java"}, {"label": "‚ö° C++", "next": "prereq-check-cpp"}, {"label": "üíô TypeScript", "next": "prereq-check-ts"}]},
    {"stepId": "prereq-check-js", "mentorSays": "Prerequisites:\n- **Arrays**\n- **Heap concept**\n- **Recursion**\n\nReady?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-js"}, {"label": "Some", "next": "select-prereqs-js"}]},
    {"stepId": "teach-prereqs-js", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-js", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-python", "mentorSays": "Ready?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-python"}, {"label": "Some", "next": "select-prereqs-python"}]},
    {"stepId": "teach-prereqs-python", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-python", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-java", "mentorSays": "Ready?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-java"}, {"label": "Some", "next": "select-prereqs-java"}]},
    {"stepId": "teach-prereqs-java", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-java", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-cpp", "mentorSays": "Ready?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-cpp"}, {"label": "Some", "next": "select-prereqs-cpp"}]},
    {"stepId": "teach-prereqs-cpp", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-cpp", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-ts", "mentorSays": "Ready?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-ts"}, {"label": "Some", "next": "select-prereqs-ts"}]},
    {"stepId": "teach-prereqs-ts", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-ts", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "problem-understanding", "mentorSays": "**Finding the kth largest** without fully sorting!\n\nGiven array and integer k, return the **kth largest** element.\n\nExample:\n```\nnums = [3,2,1,5,6,4], k = 2\n```\nOutput: `5`\n\nThe 2nd largest element is 5.", "action": "continue", "next": "thinking-challenge"},
    {"stepId": "thinking-challenge", "mentorSays": "How to find kth largest efficiently?", "choices": [{"label": "Sort and return nums[length-k]", "next": "wrong-choice"}, {"label": "Use quickselect - partition until pivot at position k", "next": "core-idea"}]},
    {"stepId": "wrong-choice", "mentorSays": "Sorting works but is O(n log n).\n\nQuickselect is O(n) average!", "action": "next", "next": "core-idea"},
    {"stepId": "core-idea", "mentorSays": "The key: **partition like quicksort, but only recurse on one side**.\n\nQuickselect:\n1. Pick pivot, partition array\n2. If pivot at index k-1 ‚Üí found!\n3. If k-1 < pivot index ‚Üí search left\n4. Else ‚Üí search right\n\nAverage O(n) because we eliminate half each time!", "action": "next", "next": "walkthrough", "pseudocodeLineIds": ["ps1", "ps2", "ps3"]},
    {"stepId": "walkthrough", "mentorSays": "Finding 2nd largest in [3,2,1,5,6,4]:\n\nTarget index: 1 (length - k)\n\n- Partition with pivot=4: [3,2,1,4,6,5]\n- Pivot at index 3, want index 1\n- Search left: [3,2,1]\n- Partition: [1,2,3]\n- Pivot=2 at index 1 ‚úì\n\nAnswer: **5**", "action": "next", "next": "pseudocode-step", "pseudocodeLineIds": ["ps1", "ps2", "ps3"]},
    {"stepId": "pseudocode-step", "mentorSays": "Pseudocode:", "action": "next", "next": "coding-intro", "pseudocodeLineIds": ["ps1", "ps2", "ps3", "ps4", "ps5"]},
    {"stepId": "coding-intro", "mentorSays": "Build it!", "action": "next", "next": "code-01"},
    {"stepId": "code-01", "mentorSays": "Simple solution using built-in sort.\n\n```javascript\nfunction findKthLargest(nums, k) {\n  nums.sort((a,b) => b-a);\n  return nums[k-1];\n}\n```", "action": "next", "next": "code-02", "pseudocodeLineIds": ["ps1"], "example": "nums.sort((a,b) => b-a);\nreturn nums[k-1];"
    },
    {"stepId": "code-02", "mentorSays": "For quickselect, implement partition helper.\n\n```javascript\nfunction findKthLargest(nums, k) {\n  const partition = (left, right) => {\n    const pivot = nums[right];\n    let i = left;\n    for (let j = left; j < right; j++) {\n      if (nums[j] >= pivot) {\n        [nums[i], nums[j]] = [nums[j], nums[i]];\n        i++;\n      }\n    }\n    [nums[i], nums[right]] = [nums[right], nums[i]];\n    return i;\n  };\n}\n```", "action": "next", "next": "code-03", "pseudocodeLineIds": ["ps1"], "example": "const partition = (left, right) => {\n  const pivot = nums[right];\n  let i = left;\n  for (let j = left; j < right; j++) {\n    if (nums[j] >= pivot) [nums[i], nums[j]] = [nums[j], nums[i]], i++;\n  }\n  [nums[i], nums[right]] = [nums[right], nums[i]];\n  return i;"
    },
    {"stepId": "code-03", "mentorSays": "Implement quickselect logic.\n\n```javascript\nfunction findKthLargest(nums, k) {\n  const partition = (left, right) => {\n    const pivot = nums[right];\n    let i = left;\n    for (let j = left; j < right; j++) {\n      if (nums[j] >= pivot) {\n        [nums[i], nums[j]] = [nums[j], nums[i]];\n        i++;\n      }\n    }\n    [nums[i], nums[right]] = [nums[right], nums[i]];\n    return i;\n  };\n  \n  let left = 0, right = nums.length - 1;\n  while (true) {\n    const pivotIndex = partition(left, right);\n    if (pivotIndex === k - 1) return nums[pivotIndex];\n    if (pivotIndex > k - 1) right = pivotIndex - 1;\n    else left = pivotIndex + 1;\n  }\n}\n```", "action": "next", "next": "wrap-up", "pseudocodeLineIds": ["ps2", "ps3", "ps4"], "example": "let left = 0, right = nums.length - 1;\nwhile (true) {\n  const pivotIndex = partition(left, right);\n  if (pivotIndex === k - 1) return nums[pivotIndex];\n  if (pivotIndex > k - 1) right = pivotIndex - 1;\n  else left = pivotIndex + 1;"
    },
    {"stepId": "wrap-up", "mentorSays": "Brilliant! **Quickselect** mastered!\n\nUsed for:\n‚Ä¢ Finding medians\n‚Ä¢ Top-k problems\n‚Ä¢ Order statistics\n\nNext: **Merge K Sorted Lists** - heap mastery!\n\nYou're crushing it! üí™", "action": "complete"}
  ]
}


================================================================================

E:\projects\inpact\inpact\algo\generated\generated-lessons-v2\lesson-59-merge-k-sorted-lists.json:
{
  "id": "merge-k-sorted-lists",
  "title": "Merge K Sorted Lists",
  "pattern": "heap (min heap)",
  "difficulty": "hard",
  "language": "javascript",
  "status": "AI-GENERATED-V2-BATCH",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 59,
    "tier": "EXPERT",
    "lessonOrderTag": "EXPERT-59",
    "introduces": [
      "k-way-merge",
      "heap-ordering",
      "linked-list-merge"
    ],
    "assumesAlreadyTaught": [
      "heap-concept",
      "linked-lists",
      "merge-pattern"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "alien-dictionary"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Initialize a min heap to store (value, list_index, node_index) tuples"
    },
    {
      "id": "ps2",
      "text": "For each non-empty list in the k sorted lists, insert the first element into the min heap"
    },
    {
      "id": "ps3",
      "text": "Create a dummy head node and set current pointer to it for building the result list"
    },
    {
      "id": "ps4",
      "text": "While the min heap is not empty:"
    },
    {
      "id": "ps5",
      "text": "    Extract the minimum element (value, list_index, node_index) from the heap"
    },
    {
      "id": "ps6",
      "text": "    Add this minimum value to the result list by updating current.next"
    },
    {
      "id": "ps7",
      "text": "    If the extracted element has a next node in its original list, insert the next element into the heap"
    },
    {
      "id": "ps8",
      "text": "    Move the current pointer forward in the result list"
    },
    {
      "id": "ps9",
      "text": "Return dummy_head.next as the merged sorted list"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "Hey! Ready to tackle one of the classic \"multiple data structures\" problems? Today we're diving into **Merge K Sorted Lists** - and trust me, this one's going to pull together everything you've been learning!\n\nRemember how we just conquered finding the kth-largest-element using heaps? Well, that heap knowledge is about to become your secret weapon here. We're dealing with multiple sorted linked lists that need to be merged into one beautifully sorted list.\n\n**Quick Heap Refresher (Min Heap Focus):**\nA min heap is our \"smallest-first\" data structure - the root always holds the minimum value. When we pop elements, we get them in ascending order (perfect for merging!). Think of it as an automatic sorter that always hands you the next smallest item.\n\n**3 Key Skills You'll Master:**\n1. **Heap-based merging** - Using a min heap to efficiently track and extract the smallest elements across multiple lists\n2. **Pointer manipulation** - Managing multiple list pointers simultaneously while building our result\n3. **Optimal complexity thinking** - Understanding why O(N log K) beats the naive O(NK) approach\n\nThis problem beautifully combines linked list traversal with heap operations. You'll see how the heap eliminates the need to repeatedly scan through all K lists to find the next minimum - instead, we'll let the heap do that work for us!\n\nLet's merge some lists! üöÄ",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Which programming language would you like to use?",
      "choices": [
        {
          "label": "üíõ JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "üêç Python",
          "next": "prereq-check-python"
        },
        {
          "label": "‚òï Java",
          "next": "prereq-check-java"
        },
        {
          "label": "‚ö° C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "üíô TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "To solve this in JavaScript, you'll need:\n- **Priority_queue_operations** - Understanding how to insert, extract minimum/maximum, and maintain heap properties in a priority queue data structure\n- **Linked_list_traversal** - Ability to iterate through linked lists, access node values, and handle null pointers during list navigation\n- **Two_pointer_merge** - Knowledge of merging two sorted sequences using comparison-based merging with pointer manipulation\n- **Divide_and_conquer** - Understanding how to break down problems into smaller subproblems and combine solutions efficiently\n- **Space_time_complexity** - Ability to analyze and compare different algorithmic approaches in terms of memory usage and runtime performance\n\nConfident with these?",
      "choices": [
        {
          "label": "Yes, I know all",
          "next": "problem-understanding"
        },
        {
          "label": "No, explain",
          "next": "teach-prereqs-js"
        },
        {
          "label": "Some, not all",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "To solve this in Python, you'll need:\n- **Priority_queue_operations** - Understanding how to insert, extract minimum/maximum, and maintain heap properties in a priority queue data structure\n- **Linked_list_traversal** - Ability to iterate through linked lists, access node values, and handle null pointers during list navigation\n- **Two_pointer_merge** - Knowledge of merging two sorted sequences using comparison-based merging with pointer manipulation\n- **Divide_and_conquer** - Understanding how to break down problems into smaller subproblems and combine solutions efficiently\n- **Space_time_complexity** - Ability to analyze and compare different algorithmic approaches in terms of memory usage and runtime performance\n\nConfident with these?",
      "choices": [
        {
          "label": "Yes, I know all",
          "next": "problem-understanding"
        },
        {
          "label": "No, explain",
          "next": "teach-prereqs-python"
        },
        {
          "label": "Some, not all",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "To solve this in Java, you'll need:\n- **Priority_queue_operations** - Understanding how to insert, extract minimum/maximum, and maintain heap properties in a priority queue data structure\n- **Linked_list_traversal** - Ability to iterate through linked lists, access node values, and handle null pointers during list navigation\n- **Two_pointer_merge** - Knowledge of merging two sorted sequences using comparison-based merging with pointer manipulation\n- **Divide_and_conquer** - Understanding how to break down problems into smaller subproblems and combine solutions efficiently\n- **Space_time_complexity** - Ability to analyze and compare different algorithmic approaches in terms of memory usage and runtime performance\n\nConfident with these?",
      "choices": [
        {
          "label": "Yes, I know all",
          "next": "problem-understanding"
        },
        {
          "label": "No, explain",
          "next": "teach-prereqs-java"
        },
        {
          "label": "Some, not all",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "To solve this in C++, you'll need:\n- **Priority_queue_operations** - Understanding how to insert, extract minimum/maximum, and maintain heap properties in a priority queue data structure\n- **Linked_list_traversal** - Ability to iterate through linked lists, access node values, and handle null pointers during list navigation\n- **Two_pointer_merge** - Knowledge of merging two sorted sequences using comparison-based merging with pointer manipulation\n- **Divide_and_conquer** - Understanding how to break down problems into smaller subproblems and combine solutions efficiently\n- **Space_time_complexity** - Ability to analyze and compare different algorithmic approaches in terms of memory usage and runtime performance\n\nConfident with these?",
      "choices": [
        {
          "label": "Yes, I know all",
          "next": "problem-understanding"
        },
        {
          "label": "No, explain",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "Some, not all",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "To solve this in TypeScript, you'll need:\n- **Priority_queue_operations** - Understanding how to insert, extract minimum/maximum, and maintain heap properties in a priority queue data structure\n- **Linked_list_traversal** - Ability to iterate through linked lists, access node values, and handle null pointers during list navigation\n- **Two_pointer_merge** - Knowledge of merging two sorted sequences using comparison-based merging with pointer manipulation\n- **Divide_and_conquer** - Understanding how to break down problems into smaller subproblems and combine solutions efficiently\n- **Space_time_complexity** - Ability to analyze and compare different algorithmic approaches in terms of memory usage and runtime performance\n\nConfident with these?",
      "choices": [
        {
          "label": "Yes, I know all",
          "next": "problem-understanding"
        },
        {
          "label": "No, explain",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "Some, not all",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "Imagine you're a wedding planner merging guest lists from multiple families, where each family has already sorted their guests alphabetically. You need to create one master alphabetical list by comparing the first name from each family's list, picking the one that comes first alphabetically, then moving to the next name on that family's list. You continue this process until all guests from all families are combined into one perfectly sorted master list.\n\n# Merge K Sorted Lists\n\nHey! So here's a classic problem that comes up a lot in interviews and real-world scenarios.\n\n## The Problem\n\nYou're given an array of `k` linked lists, where each linked list is already sorted in ascending order. Your job is to merge all of them into one single sorted linked list and return it.\n\nThink of it like having multiple sorted to-do lists and wanting to combine them into one master list that's still in order!\n\n## Example\n\nLet's say you have these three sorted lists:\n```\nlists = [[1,4,5], [1,3,4], [2,6]]\n```\n\nBreaking it down:\n- List 1: 1 ‚Üí 4 ‚Üí 5\n- List 2: 1 ‚Üí 3 ‚Üí 4  \n- List 3: 2 ‚Üí 6\n\nAfter merging them all together while keeping everything sorted, you'd get:\n```\n[1,1,2,3,4,4,5,6]\n```\n\nWhich represents: 1 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 4 ‚Üí 5 ‚Üí 6\n\n## What makes this tricky?\n\n- You need to efficiently compare elements across multiple lists simultaneously\n- You want to avoid just concatenating everything and then sorting (that would work, but it's not optimal)\n- There are several approaches you could take - some more efficient than others!\n\nThe key insight is that since each individual list is already sorted, you can be smart about how you merge them rather than starting from scratch.\n\nWhat approach would you take to solve this?",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "You have K sorted linked lists and need to merge them into one sorted list. Which approach correctly handles this problem?",
      "choices": [
        {
          "label": "Merge lists one by one sequentially - take the first list, merge it with the second list, then merge that result with the third list, and so on.",
          "next": "wrong-choice"
        },
        {
          "label": "Use a min heap to track the smallest unprocessed node from each list. Extract the minimum, add it to result, and push the next node from that same list back into the heap.",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-choice",
      "mentorSays": "While this approach works, it's inefficient with O(N*K) time complexity where N is total nodes and K is number of lists. Each merge operation processes all previously merged nodes again, leading to redundant comparisons. For large K, this becomes very slow.",
      "action": "next",
      "next": "pattern-recognition"
    },
    {
      "stepId": "pattern-recognition",
      "mentorSays": "### Pattern Recognition: Heap for K-Way Merge\n\n**This problem follows the \"K-way merge with heap\" pattern:**\n- **Min heap** - Maintains smallest element from each of K lists\n- **Multi-list processing** - Process K sorted lists simultaneously\n- **Greedy selection** - Always pick the globally smallest element\n- **Pointer advancement** - After picking element, advance pointer in that list\n\n**Similar problems:**\n- Merge Two Sorted Lists (K=2 case)\n- Find K Pairs with Smallest Sums (similar heap usage)\n- Smallest Range Covering Elements from K Lists (related)\n\n**Key insight:** A min heap of size K efficiently tracks the smallest unprocessed element from each list. Extracting minimum gives us the next element in merged result, and we only need to add the next element from that same list back to the heap.",
      "action": "next",
      "next": "invariant"
    },
    {
      "stepId": "invariant",
      "mentorSays": "### Invariant: Heap Contains Smallest Unprocessed Element from Each List\n\n**Invariant maintained throughout:**\n- **Heap contents:** Heap contains exactly one element from each non-empty list\n- **Heap property:** Root is the globally smallest unprocessed element\n- **Result ordering:** Result list is sorted and contains all processed elements\n- **List pointers:** Each list pointer advances as elements are processed\n\n**Why this works:**\n- Initially, heap contains first element from each list\n- Extracting minimum gives us the globally smallest element\n- Adding next element from that list maintains the invariant\n- When a list is exhausted, we stop adding from it\n\n**Invariant guarantee:** After processing N elements, the result list contains the N smallest elements from all K lists in sorted order. The heap always contains the next candidate elements, ensuring we process elements in correct order.",
      "action": "next",
      "next": "state-definition"
    },
    {
      "stepId": "state-definition",
      "mentorSays": "### State Definition: K-Way Merge State\n\n**State variables:**\n- **`heap`** - Min heap containing (value, listIndex, nodeIndex) tuples\n- **`result`** - Merged sorted list being built\n- **`lists`** - Array of K sorted linked lists\n- **`current`** - Current node in result list\n\n**State transitions:**\n1. **Initialize:** Add first node from each list to heap\n2. **Extract:** Remove minimum from heap, add to result\n3. **Advance:** Move to next node in the list that provided minimum\n4. **Add back:** If list not exhausted, add next node to heap\n5. **Repeat:** Until heap is empty (all lists processed)\n\n**State validity:** Result is sorted and contains all processed elements when heap is empty.",
      "action": "next",
      "next": "why-alternatives-fail"
    },
    {
      "stepId": "why-alternatives-fail",
      "mentorSays": "### Why Alternative Approaches Fail\n\n**Approach 1: Merge Lists Sequentially (One by One)**\n- **Why it fails:** O(N*K) time complexity\n- **Issue:** Each merge processes all previously merged nodes again\n- **Example:** Merging list 1 with list 2, then result with list 3 processes list 1 elements twice\n- **Better:** Heap approach is O(N log K), only processes each element once\n\n**Approach 2: Collect All Elements, Then Sort**\n- **Why it fails:** O(N log N) time, ignores that lists are already sorted\n- **Issue:** Doesn't leverage the sorted property of individual lists\n- **Better:** Heap approach uses sorted property, O(N log K) time\n\n**Approach 3: Compare All K Heads Linearly**\n- **Why it fails:** O(N*K) time - linear scan for each element\n- **Issue:** For each of N elements, scan K lists to find minimum\n- **Better:** Heap gives O(log K) per element, total O(N log K)\n\n**Our approach wins because:** Min heap maintains smallest elements from each list in O(log K) time, allowing us to merge K sorted lists in O(N log K) time, which is optimal.",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "The key insight is to use a **min heap** to efficiently track the smallest unprocessed element from each of the K sorted lists at any given time. By maintaining only the **current head** of each list in the heap, we can repeatedly extract the globally smallest element in O(log K) time and advance the corresponding list pointer. This works because the heap automatically maintains the ordering property among the K candidates, eliminating the need to scan all K lists linearly for each merge operation. The approach achieves **O(N log K)** time complexity where N is the total number of nodes, making it far more efficient than naive approaches that would require O(NK) comparisons.",
      "action": "next",
      "next": "walkthrough",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "Let's trace through merging K sorted lists using a min-heap approach:\n\n**Initial Setup:**\n- Input: [[1,4,5], [1,3,4], [2,6]]\n- Min-heap: empty\n- Result: empty list\n\n**Step 1: Initialize heap with first element from each list**\n- Add (1, 0, 0) ‚Üí list 0, index 0, value 1\n- Add (1, 1, 0) ‚Üí list 1, index 0, value 1  \n- Add (2, 2, 0) ‚Üí list 2, index 0, value 2\n- Heap: [(1,0,0), (1,1,0), (2,2,0)]\n\n**Step 2: Extract minimum (1,0,0)**\n- Remove (1,0,0) from heap\n- Add 1 to result: [1]\n- Add next from list 0: (4,0,1)\n- Heap: [(1,1,0), (2,2,0), (4,0,1)]\n\n**Step 3: Extract minimum (1,1,0)**\n- Remove (1,1,0) from heap\n- Add 1 to result: [1,1]\n- Add next from list 1: (3,1,1)\n- Heap: [(2,2,0), (4,0,1), (3,1,1)]\n\n**Step 4: Extract minimum (2,2,0)**\n- Remove (2,2,0) from heap\n- Add 2 to result: [1,1,2]\n- Add next from list 2: (6,2,1)\n- Heap: [(3,1,1), (4,0,1), (6,2,1)]\n\n**Step 5: Extract minimum (3,1,1)**\n- Remove (3,1,1) from heap\n- Add 3 to result: [1,1,2,3]\n- Add next from list 1: (4,1,2)\n- Heap: [(4,0,1), (6,2,1), (4,1,2)]\n\n**Step 6: Extract minimum (4,0,1)**\n- Remove (4,0,1) from heap\n- Add 4 to result: [1,1,2,3,4]\n- Add next from list 0: (5,0,2)\n- Heap: [(4,1,2), (6,2,1), (5,0,2)]\n\n**Step 7: Extract minimum (4,1,2)**\n- Remove (4,1,2) from heap\n- Add 4 to result: [1,1,2,3,4,4]\n- List 1 exhausted, don't add anything\n- Heap: [(5,0,2), (6,2,1)]\n\n**Step 8: Extract minimum (5,0,2)**\n- Remove (5,0,2) from heap\n- Add 5 to result: [1,1,2,3,4,4,5]\n- List 0 exhausted, don't add anything\n- Heap: [(6,2,1)]\n\n**Step 9: Extract minimum (6,2,1)**\n- Remove (6,2,1) from heap\n- Add 6 to result: [1,1,2,3,4,4,5,6]\n- List 2 exhausted, heap now empty\n\n**[1,1,2,3,4,4,5,6]**",
      "action": "next",
      "next": "pseudocode-step",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "Here's our plan as pseudocode:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7",
        "ps8",
        "ps9"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now JavaScript, step by step.\n\n1-3 lines at a time!",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Define the function and initialize result array and min heap\n\n```javascript\nfunction mergeKLists(lists) {\n    const result = [];\n    const minHeap = new MinPriorityQueue({ priority: x => x.val });\n}\n```",
      "action": "next",
      "next": "code-02",
      "pseudocodeLineIds": [],
      "example": "function mergeKLists(lists) {\n    const result = [];\n    const minHeap = new MinPriorityQueue({ priority: x => x.val });\n}"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Add the head of each non-empty list to the min heap\n\n```javascript\nfunction mergeKLists(lists) {\n    const result = [];\n    const minHeap = new MinPriorityQueue({ priority: x => x.val });\n    \n    for (let head of lists) {\n        if (head) minHeap.enqueue(head);\n    }\n}\n```",
      "action": "next",
      "next": "code-03",
      "pseudocodeLineIds": [],
      "example": "    for (let head of lists) {\n        if (head) minHeap.enqueue(head);\n    }"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Start main loop to process heap until empty\n\n```javascript\nfunction mergeKLists(lists) {\n    const result = [];\n    const minHeap = new MinPriorityQueue({ priority: x => x.val });\n    \n    for (let head of lists) {\n        if (head) minHeap.enqueue(head);\n    }\n    \n    while (!minHeap.isEmpty()) {\n        \n    }\n}\n```",
      "action": "next",
      "next": "code-04",
      "pseudocodeLineIds": [],
      "example": "    while (!minHeap.isEmpty()) {\n        \n    }"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Extract the smallest node from heap and add to result\n\n```javascript\nfunction mergeKLists(lists) {\n    const result = [];\n    const minHeap = new MinPriorityQueue({ priority: x => x.val });\n    \n    for (let head of lists) {\n        if (head) minHeap.enqueue(head);\n    }\n    \n    while (!minHeap.isEmpty()) {\n        const smallest = minHeap.dequeue().element;\n        result.push(smallest.val);\n    }\n}\n```",
      "action": "next",
      "next": "code-05",
      "pseudocodeLineIds": [],
      "example": "        const smallest = minHeap.dequeue().element;\n        result.push(smallest.val);"
    },
    {
      "stepId": "code-05",
      "mentorSays": "If the extracted node has a next node, add it to heap\n\n```javascript\nfunction mergeKLists(lists) {\n    const result = [];\n    const minHeap = new MinPriorityQueue({ priority: x => x.val });\n    \n    for (let head of lists) {\n        if (head) minHeap.enqueue(head);\n    }\n    \n    while (!minHeap.isEmpty()) {\n        const smallest = minHeap.dequeue().element;\n        result.push(smallest.val);\n        \n        if (smallest.next) {\n            minHeap.enqueue(smallest.next);\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-06",
      "pseudocodeLineIds": [],
      "example": "        if (smallest.next) {\n            minHeap.enqueue(smallest.next);\n        }"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Return the merged result array\n\n```javascript\nfunction mergeKLists(lists) {\n    const result = [];\n    const minHeap = new MinPriorityQueue({ priority: x => x.val });\n    \n    for (let head of lists) {\n        if (head) minHeap.enqueue(head);\n    }\n    \n    while (!minHeap.isEmpty()) {\n        const smallest = minHeap.dequeue().element;\n        result.push(smallest.val);\n        \n        if (smallest.next) {\n            minHeap.enqueue(smallest.next);\n        }\n    }\n    \n    return result;\n}\n```",
      "action": "next",
      "next": "common-mistakes",
      "pseudocodeLineIds": [],
      "example": "    return result;"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "üéâ Fantastic work conquering \"Merge K Sorted Lists\" using the min heap pattern! You've mastered the art of efficiently combining multiple sorted sequences by leveraging the heap's ability to always give you the smallest element across all lists.\n\nNow you're ready to tackle \"Alien Dictionary\" - another exciting challenge that will expand your algorithmic toolkit with topological sorting concepts. Keep up the momentum!\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}

================================================================================

E:\projects\inpact\inpact\algo\generated\generated-lessons-v2\lesson-60-alien-dictionary.json:
{
  "id": "alien-dictionary",
  "title": "Alien Dictionary",
  "pattern": "topological sort (character ordering)",
  "difficulty": "hard",
  "language": "javascript",
  "status": "AI-GENERATED-V2-DIRECT",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 60,
    "tier": "EXPERT",
    "lessonOrderTag": "EXPERT-60",
    "introduces": ["character-graph", "ordering-inference", "lexicographic-order"],
    "assumesAlreadyTaught": ["topological-sort", "graph-concept", "strings"],
    "prerequisiteCheckRequired": true,
    "nextRecommended": ["network-delay-time"]
  },
  "pseudocode": [
    {"id": "ps1", "text": "Build graph by comparing adjacent words"},
    {"id": "ps2", "text": "Find first differing character pair ‚Üí edge in graph"},
    {"id": "ps3", "text": "Perform topological sort on character graph"},
    {"id": "ps4", "text": "Return topological order as string"}
  ],
  "flow": [
    {"stepId": "objectives", "mentorSays": "Hey! **Alien Dictionary** - deducing character order!\n\nThis brilliant problem uses topological sort to infer an alien language's alphabetical order from a sorted word list.\n\nYou'll learn:\n‚Ä¢ Building graphs from constraints\n‚Ä¢ Character-level topological sort\n‚Ä¢ Inferring order from sorted data\n\nLet's dive in!", "action": "continue", "next": "language-selection"},
    {"stepId": "language-selection", "mentorSays": "Language?", "choices": [{"label": "üíõ JavaScript", "next": "prereq-check-js"}, {"label": "üêç Python", "next": "prereq-check-python"}, {"label": "‚òï Java", "next": "prereq-check-java"}, {"label": "‚ö° C++", "next": "prereq-check-cpp"}, {"label": "üíô TypeScript", "next": "prereq-check-ts"}]},
    {"stepId": "prereq-check-js", "mentorSays": "Prerequisites:\n- **Topological sort**\n- **Graph concept**\n- **Strings**\n\nReady?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-js"}, {"label": "Some", "next": "select-prereqs-js"}]},
    {"stepId": "teach-prereqs-js", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-js", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-python", "mentorSays": "Ready?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-python"}, {"label": "Some", "next": "select-prereqs-python"}]},
    {"stepId": "teach-prereqs-python", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-python", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-java", "mentorSays": "Ready?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-java"}, {"label": "Some", "next": "select-prereqs-java"}]},
    {"stepId": "teach-prereqs-java", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-java", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-cpp", "mentorSays": "Ready?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-cpp"}, {"label": "Some", "next": "select-prereqs-cpp"}]},
    {"stepId": "teach-prereqs-cpp", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-cpp", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-ts", "mentorSays": "Ready?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-ts"}, {"label": "Some", "next": "select-prereqs-ts"}]},
    {"stepId": "teach-prereqs-ts", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-ts", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "problem-understanding", "mentorSays": "**Decoding an alien language!** You have words sorted in this alien alphabet. Can you deduce the alphabetical order?\n\nGiven sorted `words` array, return the lexicographical order of the alien language.\n\nExample:\n```\nwords = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]\n```\nOutput: `\"wertf\"`\n\nWhy? \"wrt\" < \"wrf\" means t < f. \"wrf\" < \"er\" means w < e, etc.", "action": "continue", "next": "thinking-challenge"},
    {"stepId": "thinking-challenge", "mentorSays": "How to infer character order?", "choices": [{"label": "Compare all word pairs", "next": "wrong-choice"}, {"label": "Compare adjacent words, build dependency graph, topological sort", "next": "core-idea"}]},
    {"stepId": "wrong-choice", "mentorSays": "Comparing all pairs gives redundant info!\n\nAdjacent words tell us the minimum needed ordering.", "action": "next", "next": "core-idea"},
    {"stepId": "core-idea", "mentorSays": "The key: **compare adjacent words to build a character dependency graph**.\n\n1. For each pair of adjacent words:\n   - Find first differing character\n   - Add edge: char1 ‚Üí char2 (char1 comes before char2)\n2. Perform topological sort on the graph\n3. Result is the alien alphabet order!\n\nIf cycle detected ‚Üí invalid input.", "action": "next", "next": "walkthrough", "pseudocodeLineIds": ["ps1", "ps2", "ps3"]},
    {"stepId": "walkthrough", "mentorSays": "From [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]:\n\n- \"wrt\" vs \"wrf\": t‚Üíf edge\n- \"wrf\" vs \"er\": w‚Üíe edge\n- \"er\" vs \"ett\": r‚Üít edge\n- \"ett\" vs \"rftt\": e‚Üír edge\n\nGraph: w‚Üíe‚Üír‚Üít‚Üíf\n\nTopological sort: **\"wertf\"**", "action": "next", "next": "pseudocode-step", "pseudocodeLineIds": ["ps1", "ps2", "ps3"]},
    {"stepId": "pseudocode-step", "mentorSays": "Pseudocode:", "action": "next", "next": "coding-intro", "pseudocodeLineIds": ["ps1", "ps2", "ps3", "ps4"]},
    {"stepId": "coding-intro", "mentorSays": "Build it!", "action": "next", "next": "code-01"},
    {"stepId": "code-01", "mentorSays": "Build graph from adjacent words.\n\n```javascript\nfunction alienOrder(words) {\n  const graph = new Map();\n  const inDegree = new Map();\n  \n  for (const word of words) {\n    for (const char of word) {\n      graph.set(char, new Set());\n      inDegree.set(char, 0);\n    }\n  }\n}\n```", "action": "next", "next": "code-02", "pseudocodeLineIds": ["ps1"], "example": "const graph = new Map();\nconst inDegree = new Map();\nfor (const word of words) {\n  for (const char of word) {\n    graph.set(char, new Set());\n    inDegree.set(char, 0);"
    },
    {"stepId": "code-02", "mentorSays": "Compare adjacent words and add edges.\n\n```javascript\nfunction alienOrder(words) {\n  const graph = new Map();\n  const inDegree = new Map();\n  \n  for (const word of words) {\n    for (const char of word) {\n      graph.set(char, new Set());\n      inDegree.set(char, 0);\n    }\n  }\n  \n  for (let i = 0; i < words.length - 1; i++) {\n    const w1 = words[i], w2 = words[i+1];\n    const minLen = Math.min(w1.length, w2.length);\n    for (let j = 0; j < minLen; j++) {\n      if (w1[j] !== w2[j]) {\n        if (!graph.get(w1[j]).has(w2[j])) {\n          graph.get(w1[j]).add(w2[j]);\n          inDegree.set(w2[j], inDegree.get(w2[j]) + 1);\n        }\n        break;\n      }\n    }\n  }\n}\n```", "action": "next", "next": "code-03", "pseudocodeLineIds": ["ps2"], "example": "for (let i = 0; i < words.length - 1; i++) {\n  const w1 = words[i], w2 = words[i+1];\n  for (let j = 0; j < Math.min(w1.length, w2.length); j++) {\n    if (w1[j] !== w2[j]) {\n      if (!graph.get(w1[j]).has(w2[j])) {\n        graph.get(w1[j]).add(w2[j]);\n        inDegree.set(w2[j], inDegree.get(w2[j]) + 1);"
    },
    {"stepId": "code-03", "mentorSays": "Perform topological sort.\n\n```javascript\nfunction alienOrder(words) {\n  const graph = new Map();\n  const inDegree = new Map();\n  \n  for (const word of words) {\n    for (const char of word) {\n      graph.set(char, new Set());\n      inDegree.set(char, 0);\n    }\n  }\n  \n  for (let i = 0; i < words.length - 1; i++) {\n    const w1 = words[i], w2 = words[i+1];\n    const minLen = Math.min(w1.length, w2.length);\n    for (let j = 0; j < minLen; j++) {\n      if (w1[j] !== w2[j]) {\n        if (!graph.get(w1[j]).has(w2[j])) {\n          graph.get(w1[j]).add(w2[j]);\n          inDegree.set(w2[j], inDegree.get(w2[j]) + 1);\n        }\n        break;\n      }\n    }\n  }\n  \n  const queue = [];\n  for (const [char, deg] of inDegree) {\n    if (deg === 0) queue.push(char);\n  }\n  \n  let result = \"\";\n  while (queue.length > 0) {\n    const char = queue.shift();\n    result += char;\n    for (const next of graph.get(char)) {\n      inDegree.set(next, inDegree.get(next) - 1);\n      if (inDegree.get(next) === 0) queue.push(next);\n    }\n  }\n  \n  return result.length === graph.size ? result : \"\";\n}\n```", "action": "next", "next": "wrap-up", "pseudocodeLineIds": ["ps3", "ps4"], "example": "const queue = [];\nfor (const [char, deg] of inDegree) if (deg === 0) queue.push(char);\nlet result = \"\";\nwhile (queue.length > 0) {\n  const char = queue.shift();\n  result += char;\n  for (const next of graph.get(char)) {\n    inDegree.set(next, inDegree.get(next) - 1);\n    if (inDegree.get(next) === 0) queue.push(next);"
    },
    {"stepId": "wrap-up", "mentorSays": "Amazing! **Alien Dictionary** solved!\n\nThis pattern powers:\n‚Ä¢ Build systems\n‚Ä¢ Package managers\n‚Ä¢ Course prerequisites\n‚Ä¢ Task scheduling\n\nYou've completed the Expert tier! üéâ", "action": "complete"}
  ]
}


================================================================================

E:\projects\inpact\inpact\algo\generated\generated-lessons-v2\lesson-61-network-delay-time.json:
{
  "id": "network-delay-time",
  "title": "Network Delay Time",
  "pattern": "Dijkstra's shortest path",
  "difficulty": "medium",
  "language": "javascript",
  "status": "AI-GENERATED-V2-DIRECT",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 61,
    "tier": "MASTERY-I",
    "lessonOrderTag": "MASTERY-I-61",
    "introduces": ["dijkstra-algorithm", "priority-queue", "weighted-graph", "shortest-path"],
    "assumesAlreadyTaught": ["graph-concept", "BFS-concept", "heap-concept"],
    "prerequisiteCheckRequired": true,
    "nextRecommended": ["cheapest-flights-k-stops"]
  },
  "pseudocode": [
    {"id": "ps1", "text": "Initialize distances to infinity, start node to 0"},
    {"id": "ps2", "text": "Use min heap with (distance, node) pairs"},
    {"id": "ps3", "text": "Pop minimum distance node from heap"},
    {"id": "ps4", "text": "For each neighbor, if new path shorter, update and add to heap"},
    {"id": "ps5", "text": "Return max distance, or -1 if any node unreachable"}
  ],
  "flow": [
    {"stepId": "objectives", "mentorSays": "Hey! **Network Delay Time** - learning Dijkstra's algorithm!\n\nThis classic algorithm finds shortest paths in weighted graphs - used in GPS routing, network protocols, and more.\n\nYou'll learn:\n‚Ä¢ Dijkstra's shortest path algorithm\n‚Ä¢ Priority queue optimization\n‚Ä¢ Weighted graph traversal\n\nLet's dive in!", "action": "continue", "next": "language-selection"},
    {"stepId": "language-selection", "mentorSays": "Which language?", "choices": [{"label": "üíõ JavaScript", "next": "prereq-check-js"}, {"label": "üêç Python", "next": "prereq-check-python"}, {"label": "‚òï Java", "next": "prereq-check-java"}, {"label": "‚ö° C++", "next": "prereq-check-cpp"}, {"label": "üíô TypeScript", "next": "prereq-check-ts"}]},
    {"stepId": "prereq-check-js", "mentorSays": "Prerequisites:\n- **Graph concept**\n- **BFS concept**\n- **Heap concept**\n\nReady?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-js"}, {"label": "Some", "next": "select-prereqs-js"}]},
    {"stepId": "teach-prereqs-js", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-js", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-python", "mentorSays": "Ready?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-python"}, {"label": "Some", "next": "select-prereqs-python"}]},
    {"stepId": "teach-prereqs-python", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-python", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-java", "mentorSays": "Ready?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-java"}, {"label": "Some", "next": "select-prereqs-java"}]},
    {"stepId": "teach-prereqs-java", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-java", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-cpp", "mentorSays": "Ready?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-cpp"}, {"label": "Some", "next": "select-prereqs-cpp"}]},
    {"stepId": "teach-prereqs-cpp", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-cpp", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-ts", "mentorSays": "Ready?", "choices": [{"label": "Yes", "next": "problem-understanding"}, {"label": "No", "next": "teach-prereqs-ts"}, {"label": "Some", "next": "select-prereqs-ts"}]},
    {"stepId": "teach-prereqs-ts", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-ts", "mentorSays": "[Phase 2]", "action": "continue", "next": "problem-understanding"},
    {"stepId": "problem-understanding", "mentorSays": "**Network signal propagation!** You send a signal from one node - how long until ALL nodes receive it?\n\nGiven:\n- `n` nodes (labeled 1 to n)\n- `times[i] = [u, v, w]`: signal travels from u to v in w time\n- `k`: starting node\n\nReturn minimum time for all nodes to receive signal, or -1 if impossible.\n\nExample:\n```\nn = 4, times = [[2,1,1],[2,3,1],[3,4,1]], k = 2\n```\nOutput: `2`\n\n2‚Üí1 (1), 2‚Üí3 (1), 3‚Üí4 (2). Max is 2.", "action": "continue", "next": "thinking-challenge"},
    {"stepId": "thinking-challenge", "mentorSays": "How to find time to reach all nodes?", "choices": [{"label": "BFS from start node", "next": "wrong-choice"}, {"label": "Dijkstra's algorithm to find shortest paths to all nodes", "next": "core-idea"}]},
    {"stepId": "wrong-choice", "mentorSays": "Regular BFS doesn't handle weights!\n\nDijkstra's algorithm always picks the shortest path first.", "action": "next", "next": "core-idea"},
    {"stepId": "core-idea", "mentorSays": "The key: **Dijkstra's algorithm finds shortest paths from source to all nodes**.\n\n1. Track distances (initially ‚àû, start = 0)\n2. Use min heap: always process closest unvisited node\n3. For each neighbor, relax edge if shorter path found\n4. Return max distance (time for last node)\n\nGreedy approach: always expand closest node first!", "action": "next", "next": "walkthrough", "pseudocodeLineIds": ["ps1", "ps2", "ps3"]},
    {"stepId": "walkthrough", "mentorSays": "From k=2 in example:\n\n**Init:** dist = [‚àû, ‚àû, 0, ‚àû] (node 2 = 0)\n**Process 2:** Update 1‚Üí1, 3‚Üí1\n**Process 1:** (no outgoing edges)\n**Process 3:** Update 4‚Üí2\n**Process 4:** Done\n\n**Max distance: 2**\n\nAll nodes reachable!", "action": "next", "next": "pseudocode-step", "pseudocodeLineIds": ["ps1", "ps2", "ps3"]},
    {"stepId": "pseudocode-step", "mentorSays": "Pseudocode:", "action": "next", "next": "coding-intro", "pseudocodeLineIds": ["ps1", "ps2", "ps3", "ps4", "ps5"]},
    {"stepId": "coding-intro", "mentorSays": "Build it!", "action": "next", "next": "code-01"},
    {"stepId": "code-01", "mentorSays": "Build adjacency list and initialize distances.\n\n```javascript\nfunction networkDelayTime(times, n, k) {\n  const graph = Array.from({length: n + 1}, () => []);\n  for (const [u, v, w] of times) {\n    graph[u].push([v, w]);\n  }\n  \n  const dist = Array(n + 1).fill(Infinity);\n  dist[k] = 0;\n}\n```", "action": "next", "next": "code-02", "pseudocodeLineIds": ["ps1"], "example": "const graph = Array.from({length: n + 1}, () => []);\nfor (const [u, v, w] of times) graph[u].push([v, w]);\nconst dist = Array(n + 1).fill(Infinity);\ndist[k] = 0;"
    },
    {"stepId": "code-02", "mentorSays": "Implement Dijkstra with min heap (priority queue).\n\n```javascript\nfunction networkDelayTime(times, n, k) {\n  const graph = Array.from({length: n + 1}, () => []);\n  for (const [u, v, w] of times) {\n    graph[u].push([v, w]);\n  }\n  \n  const dist = Array(n + 1).fill(Infinity);\n  dist[k] = 0;\n  \n  const heap = [[0, k]];\n  \n  while (heap.length > 0) {\n    heap.sort((a, b) => a[0] - b[0]);\n    const [d, node] = heap.shift();\n    \n    if (d > dist[node]) continue;\n    \n    for (const [neighbor, weight] of graph[node]) {\n      const newDist = d + weight;\n      if (newDist < dist[neighbor]) {\n        dist[neighbor] = newDist;\n        heap.push([newDist, neighbor]);\n      }\n    }\n  }\n}\n```", "action": "next", "next": "code-03", "pseudocodeLineIds": ["ps2", "ps3", "ps4"], "example": "const heap = [[0, k]];\nwhile (heap.length > 0) {\n  heap.sort((a, b) => a[0] - b[0]);\n  const [d, node] = heap.shift();\n  if (d > dist[node]) continue;\n  for (const [neighbor, weight] of graph[node]) {\n    const newDist = d + weight;\n    if (newDist < dist[neighbor]) {\n      dist[neighbor] = newDist;\n      heap.push([newDist, neighbor]);"
    },
    {"stepId": "code-03", "mentorSays": "Return max distance or -1.\n\n```javascript\nfunction networkDelayTime(times, n, k) {\n  const graph = Array.from({length: n + 1}, () => []);\n  for (const [u, v, w] of times) {\n    graph[u].push([v, w]);\n  }\n  \n  const dist = Array(n + 1).fill(Infinity);\n  dist[k] = 0;\n  \n  const heap = [[0, k]];\n  \n  while (heap.length > 0) {\n    heap.sort((a, b) => a[0] - b[0]);\n    const [d, node] = heap.shift();\n    \n    if (d > dist[node]) continue;\n    \n    for (const [neighbor, weight] of graph[node]) {\n      const newDist = d + weight;\n      if (newDist < dist[neighbor]) {\n        dist[neighbor] = newDist;\n        heap.push([newDist, neighbor]);\n      }\n    }\n  }\n  \n  const maxDist = Math.max(...dist.slice(1));\n  return maxDist === Infinity ? -1 : maxDist;\n}\n```", "action": "next", "next": "wrap-up", "pseudocodeLineIds": ["ps5"], "example": "const maxDist = Math.max(...dist.slice(1));\nreturn maxDist === Infinity ? -1 : maxDist;"
    },
    {"stepId": "wrap-up", "mentorSays": "Brilliant! **Dijkstra's algorithm** mastered!\n\nUsed in:\n‚Ä¢ GPS routing\n‚Ä¢ Network protocols\n‚Ä¢ Game pathfinding\n‚Ä¢ Social networks\n\nNext: **Cheapest Flights K Stops** - Bellman-Ford!\n\nYou're crushing graph algorithms! üöÄ", "action": "complete"}
  ]
}


================================================================================

E:\projects\inpact\inpact\algo\generated\generated-lessons-v2\lesson-62-cheapest-flights-k-stops.json:
{
  "id": "cheapest-flights-k-stops",
  "title": "Cheapest Flights Within K Stops - Constrained Shortest Paths",
  "pattern": "bellman-ford-constrained",
  "difficulty": "medium",
  "language": "javascript",
  "status": "AI-GENERATED-V2-DIRECT",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 62,
    "tier": "MASTERY-I",
    "lessonOrderTag": "MASTERY-I-62",
    "introduces": [
      "bellman-ford",
      "constrained-shortest-path",
      "dynamic-programming-graphs"
    ],
    "assumesAlreadyTaught": [
      "dijkstra-algorithm",
      "graphs",
      "bfs"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "partition-equal-subset-sum"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Create a DP array where dp[i] = minimum cost to reach each city"
    },
    {
      "id": "ps2",
      "text": "Initialize all cities to infinity, source city to 0"
    },
    {
      "id": "ps3",
      "text": "For each stop from 0 to k:"
    },
    {
      "id": "ps4",
      "text": "  Create a temporary copy of current DP array"
    },
    {
      "id": "ps5",
      "text": "  For each flight [from, to, price]:"
    },
    {
      "id": "ps6",
      "text": "    If we can reach 'from' city:"
    },
    {
      "id": "ps7",
      "text": "      Update temp[to] = min(temp[to], dp[from] + price)"
    },
    {
      "id": "ps8",
      "text": "  Copy temp array back to dp"
    },
    {
      "id": "ps9",
      "text": "Return dp[destination], or -1 if still infinity"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "# Welcome to Cheapest Flights Within K Stops! ‚úàÔ∏è\n\nYou're about to learn a powerful variation of shortest path algorithms: **finding paths with constraints**.\n\n## What You'll Master:\n\n- Understanding the Bellman-Ford algorithm\n- Handling path constraints (maximum number of stops)\n- Dynamic programming on graphs\n- Real-world flight booking optimization\n\nThis technique is used in flight booking systems, network routing with hop limits, and resource-constrained pathfinding!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Which programming language would you like to use for this lesson?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "Python",
          "next": "prereq-check-python"
        },
        {
          "label": "Java",
          "next": "prereq-check-java"
        },
        {
          "label": "C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "To solve this in JavaScript, you'll need to know:\n\n- **Graph shortest paths** (Dijkstra's algorithm)\n- **Dynamic programming** basics\n- **Array operations** (copying, iterating)\n- **BFS concepts**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-js"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "To solve this in Python, you'll need to know:\n\n- **Graph shortest paths** (Dijkstra's algorithm)\n- **Dynamic programming** basics\n- **List operations** (copying, iterating)\n- **BFS concepts**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-python"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "To solve this in Java, you'll need to know:\n\n- **Graph shortest paths** (Dijkstra's algorithm)\n- **Dynamic programming** basics\n- **Arrays class** (copying, filling)\n- **BFS concepts**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-java"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "To solve this in C++, you'll need to know:\n\n- **Graph shortest paths** (Dijkstra's algorithm)\n- **Dynamic programming** basics\n- **Vector operations** (copying, filling)\n- **BFS concepts**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "To solve this in TypeScript, you'll need to know:\n\n- **Graph shortest paths** (Dijkstra's algorithm)\n- **Dynamic programming** basics\n- **Array operations** (copying, iterating)\n- **BFS concepts**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "# The Problem: Cheapest Flights Within K Stops üé´\n\n**Real-world analogy:** You're booking a flight and want the cheapest route, but you don't want too many layovers! You're willing to make at most K stops (connecting flights) to get from your source city to your destination. Some routes might be cheaper but require more stops - we need to find the best option within our constraint.\n\n## The Challenge:\n\nYou have `n` cities connected by flights. You're given:\n- `flights`: array where `flights[i] = [from, to, price]`\n- `src`: source city\n- `dst`: destination city  \n- `k`: maximum number of stops allowed\n\nFind the **cheapest price** from `src` to `dst` with at most `k` stops. Return `-1` if no such route exists.\n\n## Example:\n```\nn = 4\nflights = [[0,1,100], [1,2,100], [2,0,100], [1,3,600], [2,3,200]]\nsrc = 0, dst = 3, k = 1\n\nOutput: 700\n```\n\nPath: 0 ‚Üí 1 (cost 100) ‚Üí 3 (cost 600) = 700\nAlternative: 0 ‚Üí 1 ‚Üí 2 ‚Üí 3 would cost 400, but requires 2 stops (exceeds k=1)",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "# ü§î Why Can't We Use Dijkstra's?\n\nRemember Dijkstra's algorithm from the last lesson? It finds the absolute shortest path.\n\n**Question:** What's the problem with using Dijkstra's algorithm for this problem?",
      "choices": [
        {
          "label": "Dijkstra's doesn't work with negative weights",
          "next": "wrong-negative"
        },
        {
          "label": "Dijkstra's finds the shortest path by cost, but ignores the number of stops constraint",
          "next": "core-idea"
        },
        {
          "label": "Dijkstra's is too slow for this problem",
          "next": "wrong-slow"
        }
      ]
    },
    {
      "stepId": "wrong-negative",
      "mentorSays": "True, Dijkstra's doesn't handle negative weights! But that's not our issue here - all our flight prices are positive.\n\nThe real problem is different...",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "wrong-slow",
      "mentorSays": "Actually, Dijkstra's has good time complexity! That's not the issue.\n\nThe problem is about what it optimizes for versus what we need...",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "# The Key Insight: Bellman-Ford with Constraints üí°\n\nDijkstra's algorithm finds the **absolute cheapest** path, but we have a constraint: **at most k stops**.\n\nThe cheapest path might require too many stops! We need something that:\n1. Respects the maximum stops constraint\n2. Finds the cheapest path within that constraint\n\n## Enter Bellman-Ford (Modified):\n\n**Core idea:** Build up solutions layer by layer, where each layer represents one additional stop.\n\n- **DP approach:** `dp[i]` = cheapest way to reach city `i`\n- **Iterate k+1 times:** Each iteration adds one more potential stop\n- **Relaxation:** For each flight, if we can afford to take it, update the destination cost\n\n## Why This Works:\n\nAfter iteration 0: We know costs to reach cities with 0 stops (just source)\nAfter iteration 1: We know costs with at most 1 stop\nAfter iteration k: We know costs with at most k stops ‚úÖ",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "# Let's Walk Through an Example üö∂\n\n```\nflights = [[0,1,100], [1,2,100], [2,0,100], [1,3,600], [2,3,200]]\nsrc = 0, dst = 3, k = 1\n```\n\n**Initial:** dp = [0, ‚àû, ‚àû, ‚àû]\n\n**Iteration 0 (k=0, direct flights only):**\n- Process [0,1,100]: dp[1] = min(‚àû, 0+100) = 100\n- Process [1,2,100]: Can't use (city 1 unreachable at start)\n- Process [2,0,100]: Can't use\n- Process [1,3,600]: Can't use\n- Process [2,3,200]: Can't use\n- Result: dp = [0, 100, ‚àû, ‚àû]\n\n**Iteration 1 (k=1, one stop allowed):**\n- Use previous dp as baseline\n- Process [0,1,100]: dp[1] = min(100, 0+100) = 100 (same)\n- Process [1,2,100]: dp[2] = min(‚àû, 100+100) = 200 ‚úì\n- Process [2,0,100]: dp[0] = min(0, ‚àû+100) = 0 (same)\n- Process [1,3,600]: dp[3] = min(‚àû, 100+600) = 700 ‚úì\n- Process [2,3,200]: Can't use (city 2 was ‚àû before this iteration)\n- Result: dp = [0, 100, 200, 700]\n\n**Answer:** dp[3] = 700",
      "action": "next",
      "next": "pseudocode-step"
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "# Here's Our Battle Plan üìã\n\nLet's break down the Bellman-Ford approach:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7",
        "ps8",
        "ps9"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "# Time to Code! üíª\n\nWe'll build this solution step by step, using dynamic programming to respect our stop constraint.",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Let's start with the function signature and initialize our DP array:\n\n```javascript\nfunction findCheapestPrice(n, flights, src, dst, k) {\n    // Initialize costs to infinity, source to 0\n    let dp = new Array(n).fill(Infinity);\n    dp[src] = 0;\n```\n\nWe track the minimum cost to reach each city.",
      "action": "next",
      "next": "code-02",
      "example": "function findCheapestPrice(n, flights, src, dst, k) {\n    let dp = new Array(n).fill(Infinity);\n    dp[src] = 0;"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Now iterate k+1 times (0 stops, 1 stop, ..., k stops):\n\n```javascript\n    // k+1 iterations: allow up to k stops\n    for (let i = 0; i <= k; i++) {\n```\n\nEach iteration represents adding one more potential stop to our route.",
      "action": "next",
      "next": "code-03",
      "example": "    for (let i = 0; i <= k; i++) {"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Create a temporary copy of the current DP state:\n\n```javascript\n        const temp = [...dp];\n```\n\nThis is crucial! We need to use the previous iteration's values, not values we're updating in this iteration.",
      "action": "next",
      "next": "code-04",
      "example": "        const temp = [...dp];"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Process each flight and try to relax edges:\n\n```javascript\n        for (const [from, to, price] of flights) {\n```\n\nFor each flight, check if we can improve the cost to the destination.",
      "action": "next",
      "next": "code-05",
      "example": "        for (const [from, to, price] of flights) {"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Only update if we can actually reach the 'from' city:\n\n```javascript\n            if (dp[from] !== Infinity) {\n                temp[to] = Math.min(temp[to], dp[from] + price);\n            }\n```\n\nIf `dp[from]` is Infinity, we can't use this flight yet. Otherwise, we try to update the destination cost.",
      "action": "next",
      "next": "code-06",
      "example": "            if (dp[from] !== Infinity) {\n                temp[to] = Math.min(temp[to], dp[from] + price);\n            }"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Close the flights loop and copy temp back to dp:\n\n```javascript\n        }\n        dp = temp;\n    }\n```\n\nAfter processing all flights for this iteration, update our DP array for the next iteration.",
      "action": "next",
      "next": "code-07",
      "example": "        }\n        dp = temp;\n    }"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Finally, return the result:\n\n```javascript\n    return dp[dst] === Infinity ? -1 : dp[dst];\n}\n```\n\nIf the destination is still Infinity, it's unreachable within k stops. Otherwise, return the minimum cost!",
      "action": "next",
      "next": "complexity-analysis",
      "example": "    return dp[dst] === Infinity ? -1 : dp[dst];\n}"
    },
    {
      "stepId": "complexity-analysis",
      "mentorSays": "# Complexity Analysis üìä\n\n## Time Complexity: O(k √ó E)\n- k = maximum number of stops\n- E = number of flights (edges)\n- We iterate k+1 times, and in each iteration process all E flights\n\n## Space Complexity: O(n)\n- n = number of cities\n- We use two arrays of size n (dp and temp)\n- The temp array could be eliminated with careful indexing, but it makes the code clearer\n\n## Why This Works:\n\nBellman-Ford traditionally runs n-1 iterations to guarantee shortest paths. Here we run k+1 iterations because:\n- We only care about paths with at most k stops\n- Each iteration adds one more \"hop\" to our possible paths\n- This gives us exactly what we need while being efficient!",
      "action": "next",
      "next": "bellman-vs-dijkstra"
    },
    {
      "stepId": "bellman-vs-dijkstra",
      "mentorSays": "# Bellman-Ford vs Dijkstra ü§î\n\n**When to use Bellman-Ford:**\n- Negative edge weights (Dijkstra can't handle these)\n- Need to detect negative cycles\n- Have constraints on path length (like our k stops)\n- Simpler implementation\n\n**When to use Dijkstra:**\n- All edges are non-negative\n- Need absolute shortest path\n- Want better performance: O(E log V) vs O(V √ó E)\n\n**Our problem:** Even though edges are positive, we have a constraint (k stops) that makes Bellman-Ford the right choice!",
      "action": "next",
      "next": "alternative-approach"
    },
    {
      "stepId": "alternative-approach",
      "mentorSays": "# Alternative: Modified Dijkstra üéØ\n\nYou could also solve this with modified Dijkstra where state = (city, stops_used):\n\n```javascript\n// Priority queue with [cost, city, stops]\n// Track visited as [city][stops] pairs\n// More complex but also works!\n```\n\n**Tradeoffs:**\n- Dijkstra approach: Potentially faster with good heap\n- Bellman-Ford approach: Simpler code, easier to understand\n- Both are valid for interviews - choose what you're comfortable with!\n\nBellman-Ford is cleaner for this specific problem.",
      "action": "next",
      "next": "edge-cases"
    },
    {
      "stepId": "edge-cases",
      "mentorSays": "# Edge Cases to Consider üéØ\n\n1. **Source equals destination:** k = 0, already at destination ‚Üí return 0\n\n2. **No path exists:** Some cities unreachable ‚Üí return -1\n\n3. **k = 0:** Only direct flights allowed (no stops)\n\n4. **Cycles in graph:** Our algorithm handles these correctly (won't infinite loop)\n\n5. **Multiple flights same route:** Take the cheapest one (handled by min operation)\n\nOur implementation handles all these naturally!",
      "action": "next",
      "next": "common-mistakes"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "# Congratulations! üéâ\n\nYou've mastered **constrained shortest path** problems using Bellman-Ford!\n\n## What You Learned:\n\n‚úÖ Bellman-Ford algorithm for shortest paths\n‚úÖ Handling path constraints with dynamic programming\n‚úÖ When to choose Bellman-Ford over Dijkstra\n‚úÖ Building solutions layer by layer with DP\n\n## Next Steps:\n\nReady for a different type of challenge? The next lesson covers **Partition Equal Subset Sum** - a classic dynamic programming problem about dividing arrays. It's a different domain but uses similar DP thinking!\n\nKeep practicing shortest path problems - they're everywhere in real-world systems!\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}

================================================================================

E:\projects\inpact\inpact\algo\generated\generated-lessons-v2\lesson-63-partition-equal-subset-sum.json:
{
  "id": "partition-equal-subset-sum",
  "title": "Partition Equal Subset Sum - 0/1 Knapsack",
  "pattern": "01-knapsack-dp",
  "difficulty": "medium",
  "language": "javascript",
  "status": "AI-GENERATED-V2-DIRECT",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 63,
    "tier": "MASTERY-I",
    "lessonOrderTag": "MASTERY-I-63",
    "introduces": [
      "01-knapsack",
      "subset-sum",
      "boolean-dp"
    ],
    "assumesAlreadyTaught": [
      "dynamic-programming",
      "arrays"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "target-sum"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Calculate total sum of all numbers"
    },
    {
      "id": "ps2",
      "text": "If sum is odd, return false (can't split evenly)"
    },
    {
      "id": "ps3",
      "text": "Set target = sum / 2"
    },
    {
      "id": "ps4",
      "text": "Create DP array where dp[i] = can we make sum i?"
    },
    {
      "id": "ps5",
      "text": "Initialize dp[0] = true (we can make 0 with empty set)"
    },
    {
      "id": "ps6",
      "text": "For each number in array:"
    },
    {
      "id": "ps7",
      "text": "  For each sum from target down to number:"
    },
    {
      "id": "ps8",
      "text": "    If dp[sum - number] is true:"
    },
    {
      "id": "ps9",
      "text": "      Set dp[sum] = true"
    },
    {
      "id": "ps10",
      "text": "Return dp[target]"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "# Welcome to Partition Equal Subset Sum! √¢≈°‚Äì√Ø¬∏\n\nYou're about to learn one of the most fundamental dynamic programming patterns: the **0/1 Knapsack problem**.\n\n## What You'll Master:\n\n- Understanding the knapsack paradigm\n- Using DP to solve subset problems\n- Space optimization techniques\n- Boolean DP arrays\n\nThis pattern appears in countless interview problems and real-world optimization scenarios!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Which programming language would you like to use for this lesson?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "Python",
          "next": "prereq-check-python"
        },
        {
          "label": "Java",
          "next": "prereq-check-java"
        },
        {
          "label": "C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "To solve this in JavaScript, you'll need to know:\n\n- **Dynamic programming** fundamentals\n- **Arrays and iteration**\n- **Boolean logic**\n- **Basic math operations**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-js"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "To solve this in Python, you'll need to know:\n\n- **Dynamic programming** fundamentals\n- **Lists and iteration**\n- **Boolean logic**\n- **Basic math operations**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-python"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "To solve this in Java, you'll need to know:\n\n- **Dynamic programming** fundamentals\n- **Arrays and loops**\n- **Boolean logic**\n- **Basic math operations**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-java"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "To solve this in C++, you'll need to know:\n\n- **Dynamic programming** fundamentals\n- **Vectors or arrays**\n- **Boolean logic**\n- **Basic math operations**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "To solve this in TypeScript, you'll need to know:\n\n- **Dynamic programming** fundamentals\n- **Arrays and iteration**\n- **Boolean logic**\n- **Basic math operations**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "# The Problem: Partition Equal Subset Sum üéØ\n\n**Real-world analogy:** Imagine you're dividing your belongings between two moving boxes before a move. You want both boxes to weigh exactly the same so they're balanced. Given a set of items with different weights, can you split them into two groups with equal total weight?\n\n## The Challenge:\n\nGiven an array of positive integers `nums`, determine if you can partition it into two subsets such that the sum of elements in both subsets is equal.\n\n## Example 1:\n```\nnums = [1, 5, 11, 5]\nOutput: true\nExplanation: [1, 5, 5] and [11] both sum to 11\n```\n\n## Example 2:\n```\nnums = [1, 2, 3, 5]\nOutput: false\nExplanation: Cannot partition into equal sum subsets\n```\n\n## Key Insight:\n\nIf we can partition into two equal subsets, then each subset must sum to `totalSum / 2`. So the question becomes: **Can we find a subset that sums to exactly half of the total?**",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "# ü§î How Should We Approach This?\n\nLet's think about the problem transformation:\n\n**Question:** If the total sum is 22, and we need two equal subsets, what are we really looking for?",
      "choices": [
        {
          "label": "Two subsets that both sum to 11",
          "next": "wrong-two-subsets"
        },
        {
          "label": "One subset that sums to 11 (the other automatically sums to 11 too)",
          "next": "core-idea"
        },
        {
          "label": "All possible subset combinations",
          "next": "wrong-all-combos"
        }
      ]
    },
    {
      "stepId": "wrong-two-subsets",
      "mentorSays": "You're on the right track! Both subsets do need to sum to 11.\n\nBut here's the key insight: if we find ONE subset that sums to 11, the remaining elements automatically sum to 11 too (since 22 - 11 = 11).\n\nSo we only need to search for one subset, not two!",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "wrong-all-combos",
      "mentorSays": "That would work but is incredibly inefficient! With n elements, there are 2^n possible subsets.\n\nWe need something smarter that doesn't try every combination...",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "# The Key Insight: Subset Sum with DP üí°\n\n**Problem transformation:**\n1. Calculate total sum\n2. If odd, impossible to split evenly ‚Üí return false\n3. If even, find if we can make a subset summing to `total / 2`\n\n**This is the classic Subset Sum problem!**\n\n## DP Approach:\n\n**State:** `dp[i]` = Can we make sum `i` using some subset of numbers?\n\n**Recurrence:** For each number `num`:\n- If we can make sum `s - num`, then we can make sum `s` by including `num`\n- `dp[s] = dp[s] OR dp[s - num]`\n\n**Base case:** `dp[0] = true` (we can always make 0 with empty subset)\n\n## The Trick:\n\nIterate backwards through sums to avoid using the same number twice!",
      "action": "next",
      "next": "dp-table-semantics"
    },
    {
      "stepId": "dp-table-semantics",
      "mentorSays": "### DP Table Row/Column Semantics\n\n**1D DP Table (optimized):**\n\n```\nColumns (sums):  0   1   2   3   4   5   6   7   8   9  10  11\n                ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nInitial:       [T,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F]\nAfter num=1:   [T,  T,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F]\nAfter num=5:   [T,  T,  F,  F,  F,  T,  T,  F,  F,  F,  F,  F]\nAfter num=11:  [T,  T,  F,  F,  F,  T,  T,  F,  F,  F,  F,  T]\n```\n\n**What each column means:**\n- Column `j` = Can we make sum `j`?\n- `dp[j] = true` means \"Yes, we can make sum j\"\n\n**2D DP Table (conceptual):**\n\n```\n        Sums:  0   1   2   3   4   5   6   7   8   9  10  11\nNumbers\n  []         [T,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F]\n  [1]        [T,  T,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F]\n  [1,5]      [T,  T,  F,  F,  F,  T,  T,  F,  F,  F,  F,  F]\n  [1,5,11]   [T,  T,  F,  F,  F,  T,  T,  F,  F,  F,  F,  T]\n```\n\n**What each row means:**\n- Row `i` = Using first `i` numbers\n\n**What each cell means:**\n- `dp[i][j]` = Can we make sum `j` using first `i` numbers?\n\n**This prevents DP confusion** - understanding row/column semantics is crucial!",
      "action": "next",
      "next": "pattern-recognition"
    },
    {
      "stepId": "pattern-recognition",
      "mentorSays": "### Pattern Recognition: Subset Sum DP (0/1 Knapsack Variant)\n\n**This problem follows the \"subset sum DP\" pattern:**\n- **Problem transformation** - Partition into two equal subsets ‚Üí find subset summing to total/2\n- **0/1 knapsack variant** - Each number can be used at most once\n- **1D DP optimization** - Can optimize from 2D to 1D by iterating backward\n- **Boolean DP** - dp[i] = true if sum i is achievable\n\n**Similar problems:**\n- Target Sum (similar subset sum with different constraint)\n- Coin Change (unbounded knapsack variant)\n- Subset Sum (same pattern, different problem)\n\n**Key insight:** This is a subset sum problem. We check if we can make sum = total/2 using some subset of numbers. The DP recurrence is: dp[sum] = dp[sum] OR dp[sum - num] for each number.",
      "action": "next",
      "next": "invariant"
    },
    {
      "stepId": "invariant",
      "mentorSays": "### Invariant: dp[i] = Can We Make Sum i Using Processed Numbers\n\n**Invariant maintained throughout:**\n- **State definition:** dp[i] = true if sum i can be made using numbers processed so far\n- **Base case:** dp[0] = true (empty subset sums to 0)\n- **Recurrence:** For each number num, dp[sum] = dp[sum] OR dp[sum - num]\n- **Backward iteration:** Iterate sums backward to avoid using same number twice\n\n**Why this works:**\n- Initially, only dp[0] = true (can make 0 with empty subset)\n- For each number num, we can make sum s if:\n  - We could already make s (don't use num), OR\n  - We could make s - num (use num)\n- Backward iteration ensures we don't use num multiple times\n\n**Invariant guarantee:** After processing all numbers, dp[target] = true if and only if we can partition into two equal subsets. If dp[target] = false, partition is impossible.",
      "action": "next",
      "next": "state-definition"
    },
    {
      "stepId": "state-definition",
      "mentorSays": "### State Definition: Subset Sum DP State\n\n**State variables:**\n- **`dp`** - Boolean array where dp[i] = can make sum i (size target+1)\n- **`nums`** - Array of numbers\n- **`target`** - Target sum (total / 2)\n- **`num`** - Current number being processed\n\n**State transitions:**\n1. **Check total:** If total is odd, return false\n2. **Initialize:** target = total / 2, dp[0] = true, others = false\n3. **Process numbers:** For each num in nums:\n   - For sum from target down to num:\n     - dp[sum] = dp[sum] OR dp[sum - num]\n4. **Result:** Return dp[target]\n\n**State validity:** After processing all numbers, dp[target] indicates if partition is possible.",
      "action": "next",
      "next": "why-alternatives-fail"
    },
    {
      "stepId": "why-alternatives-fail",
      "mentorSays": "### Why Alternative Approaches Fail\n\n**Approach 1: Try All Subset Combinations**\n- **Why it fails:** Exponential time O(2^n)\n- **Issue:** Too many subsets to try, especially for large n\n- **Better:** DP reduces to O(n * target) time\n\n**Approach 2: Greedy (Always Pick Largest)**\n- **Why it fails:** Doesn't guarantee optimal\n- **Issue:** May miss valid partitions\n- **Example:** [1,5,11,5] - greedy might not find partition\n- **Better:** DP considers all possibilities\n\n**Approach 3: Recursion Without Memoization**\n- **Why it fails:** Exponential time due to overlapping subproblems\n- **Issue:** Recalculates same sums many times\n- **Better:** DP stores results, avoiding recalculation\n\n**Our approach wins because:** DP with subset sum pattern finds if partition is possible in O(n * target) time with O(target) space. The backward iteration ensures each number is used at most once, and the boolean DP efficiently tracks achievable sums.",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "# Let's Walk Through an Example üö∂\n\n```\nnums = [1, 5, 11, 5]\ntotal = 22, target = 11\n```\n\n**Initial:** dp = [true, false, false, ..., false] (size 12, for sums 0-11)\n\n**Process num = 1:**\n- Check sum 11: dp[11-1]=dp[10]=false, skip\n- Check sum 10: dp[10-1]=dp[9]=false, skip\n- ...\n- Check sum 1: dp[1-1]=dp[0]=true, so dp[1]=true ‚úì\n- Result: dp = [T, T, F, F, F, F, F, F, F, F, F, F]\n\n**Process num = 5:**\n- Check sum 11: dp[6]=false, skip\n- Check sum 6: dp[1]=true, so dp[6]=true ‚úì\n- Check sum 5: dp[0]=true, so dp[5]=true ‚úì\n- Result: dp = [T, T, F, F, F, T, T, F, F, F, F, F]\n\n**Process num = 11:**\n- Check sum 11: dp[0]=true, so dp[11]=true ‚úì (FOUND!)\n\n**Answer:** dp[11] = true, partition possible!",
      "action": "next",
      "next": "pseudocode-step"
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "# Here's Our Battle Plan üìã\n\nLet's break down the subset sum DP approach:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7",
        "ps8",
        "ps9",
        "ps10"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "# Time to Code! üíª\n\nWe'll build this solution step by step, using the 0/1 knapsack pattern.",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Let's start by calculating the total sum and checking if partition is possible:\n\n```javascript\nfunction canPartition(nums) {\n    // Calculate total sum\n    const sum = nums.reduce((a, b) => a + b, 0);\n```\n\nWe need the total to determine our target.",
      "action": "next",
      "next": "code-02",
      "example": "function canPartition(nums) {\n    const sum = nums.reduce((a, b) => a + b, 0);"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Check if the sum is odd (impossible to partition evenly):\n\n```javascript\n    // If sum is odd, can't partition into equal halves\n    if (sum % 2 !== 0) return false;\n```\n\nAn odd sum means each subset would need a fractional sum, which is impossible.",
      "action": "next",
      "next": "code-03",
      "example": "    if (sum % 2 !== 0) return false;"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Calculate our target sum:\n\n```javascript\n    const target = sum / 2;\n```\n\nThis is what one subset needs to sum to.",
      "action": "next",
      "next": "code-04",
      "example": "    const target = sum / 2;"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Create our DP array and set the base case:\n\n```javascript\n    // dp[i] = can we make sum i?\n    const dp = new Array(target + 1).fill(false);\n    dp[0] = true; // We can always make 0 with empty set\n```\n\nThe DP array tracks which sums are achievable.",
      "action": "next",
      "next": "code-05",
      "example": "    const dp = new Array(target + 1).fill(false);\n    dp[0] = true;"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Iterate through each number in the array:\n\n```javascript\n    for (const num of nums) {\n```\n\nFor each number, we'll update which sums we can make.",
      "action": "next",
      "next": "code-06",
      "example": "    for (const num of nums) {"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Iterate backwards through possible sums (this is crucial!):\n\n```javascript\n        // Iterate backwards to avoid using same number twice\n        for (let sum = target; sum >= num; sum--) {\n```\n\nWhy backwards? If we go forwards, we might use the same number multiple times in one iteration!",
      "action": "next",
      "next": "code-07",
      "example": "        for (let sum = target; sum >= num; sum--) {"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Update the DP array using the recurrence relation:\n\n```javascript\n            // If we can make (sum - num), we can make sum\n            dp[sum] = dp[sum] || dp[sum - num];\n```\n\nThis is the heart of the algorithm: if we can make `sum - num`, adding `num` gives us `sum`!",
      "action": "next",
      "next": "code-08",
      "example": "            dp[sum] = dp[sum] || dp[sum - num];"
    },
    {
      "stepId": "code-08",
      "mentorSays": "Close the loops:\n\n```javascript\n        }\n    }\n```",
      "action": "next",
      "next": "code-09",
      "example": "        }\n    }"
    },
    {
      "stepId": "code-09",
      "mentorSays": "Return whether we can make the target sum:\n\n```javascript\n    return dp[target];\n}\n```\n\nIf `dp[target]` is true, we found a subset that sums to exactly half the total!",
      "action": "next",
      "next": "complexity-analysis",
      "example": "    return dp[target];\n}"
    },
    {
      "stepId": "complexity-analysis",
      "mentorSays": "# Complexity Analysis üìä\n\n## Time Complexity: O(n √ó sum)\n- n = number of elements\n- sum = total sum of all elements\n- We process each number once\n- For each number, we check up to sum/2 positions\n\n## Space Complexity: O(sum)\n- We use a DP array of size (sum/2 + 1)\n- This is space-optimized! A 2D approach would use O(n √ó sum)\n\n## Why This Matters:\n\nThis is a **pseudo-polynomial** time complexity:\n- Polynomial in the value of inputs (sum)\n- Not polynomial in the size of inputs (n)\n- For small sums, very efficient\n- For huge sums, can be slow",
      "action": "next",
      "next": "why-backwards"
    },
    {
      "stepId": "why-backwards",
      "mentorSays": "# Why Iterate Backwards? üîÑ\n\nThis is a crucial optimization! Let's see what happens with forwards iteration:\n\n**Forward iteration (WRONG):**\n```javascript\nnum = 5, target = 10\nfor (let sum = 5; sum <= 10; sum++)\n```\n- sum=5: dp[5] = dp[0]=true ‚úì\n- sum=10: dp[10] = dp[5]=true ‚úì (PROBLEM!)\n\nWe used 5 twice to make 10! That's incorrect.\n\n**Backward iteration (CORRECT):**\n```javascript\nfor (let sum = 10; sum >= 5; sum--)\n```\n- sum=10: dp[10] = dp[5]=false (5 not achievable yet)\n- sum=5: dp[5] = dp[0]=true ‚úì\n\nWe only use each number once per iteration!",
      "action": "next",
      "next": "edge-cases"
    },
    {
      "stepId": "edge-cases",
      "mentorSays": "# Edge Cases to Consider üéØ\n\n1. **Single element:** [1] ‚Üí false (can't partition one element)\n\n2. **Two equal elements:** [5, 5] ‚Üí true (each subset gets one)\n\n3. **Odd sum:** [1, 2, 3] ‚Üí false (sum=6 works, but [1,2,3,5] sum=11 doesn't)\n\n4. **All zeros:** [0, 0, 0] ‚Üí true (both subsets sum to 0)\n\n5. **Large numbers:** If one number is larger than sum/2, impossible\n\nOur implementation handles all these correctly!",
      "action": "next",
      "next": "common-mistakes"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "# Congratulations! üéâ\n\nYou've mastered the **0/1 Knapsack** pattern - one of the most important DP patterns!\n\n## What You Learned:\n\n‚úÖ Transforming problems into subset sum\n‚úÖ Using boolean DP for existence queries\n‚úÖ Space-optimized 1D DP arrays\n‚úÖ Why backward iteration prevents reusing elements\n\n## Next Steps:\n\nReady for a variation? The next lesson covers **Target Sum** - a related problem where we assign +/- signs to numbers. It builds on the same knapsack foundation!\n\nThis pattern appears everywhere: coin change, knapsack problems, subset problems. Master it!\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}

================================================================================

E:\projects\inpact\inpact\algo\generated\generated-lessons-v2\lesson-64-target-sum.json:
{
  "id": "target-sum",
  "title": "Target Sum - Knapsack with Signs",
  "pattern": "knapsack-variation",
  "difficulty": "medium",
  "language": "javascript",
  "status": "AI-GENERATED-V2-DIRECT",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 64,
    "tier": "MASTERY-I",
    "lessonOrderTag": "MASTERY-I-64",
    "introduces": [
      "sign-assignment-dp",
      "sum-transformation"
    ],
    "assumesAlreadyTaught": [
      "01-knapsack",
      "subset-sum",
      "dynamic-programming"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "unique-paths-ii"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Transform problem: Find subset P where sum(P) - sum(N) = target"
    },
    {
      "id": "ps2",
      "text": "Since sum(P) + sum(N) = total, we get sum(P) = (target + total) / 2"
    },
    {
      "id": "ps3",
      "text": "Problem becomes: count subsets that sum to (target + total) / 2"
    },
    {
      "id": "ps4",
      "text": "Check if (target + total) is even and target <= total"
    },
    {
      "id": "ps5",
      "text": "Create DP array where dp[i] = number of ways to make sum i"
    },
    {
      "id": "ps6",
      "text": "Initialize dp[0] = 1 (one way to make 0: use nothing)"
    },
    {
      "id": "ps7",
      "text": "For each number in array:"
    },
    {
      "id": "ps8",
      "text": "  For sum from target down to number:"
    },
    {
      "id": "ps9",
      "text": "    dp[sum] += dp[sum - number]"
    },
    {
      "id": "ps10",
      "text": "Return dp[target]"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "# Welcome to Target Sum! üéØ\n\nReady for a mind-bending twist on the knapsack problem? We're adding +/- signs to numbers!\n\n## What You'll Master:\n\n- Transforming complex problems into simpler ones\n- Counting variations in DP\n- Math-based problem simplification\n- Advanced knapsack applications\n\nThis is one of those \"aha!\" problems where the solution is elegant once you see it!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Which programming language would you like to use for this lesson?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "Python",
          "next": "prereq-check-python"
        },
        {
          "label": "Java",
          "next": "prereq-check-java"
        },
        {
          "label": "C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "To solve this in JavaScript, you'll need to know:\n\n- **0/1 Knapsack** pattern\n- **Subset sum** DP\n- **Array operations**\n- **Basic algebra** for problem transformation\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-js"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "To solve this in Python, you'll need to know:\n\n- **0/1 Knapsack** pattern\n- **Subset sum** DP\n- **List operations**\n- **Basic algebra** for problem transformation\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-python"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "To solve this in Java, you'll need to know:\n\n- **0/1 Knapsack** pattern\n- **Subset sum** DP\n- **Array operations**\n- **Basic algebra** for problem transformation\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-java"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "To solve this in C++, you'll need to know:\n\n- **0/1 Knapsack** pattern\n- **Subset sum** DP\n- **Vector operations**\n- **Basic algebra** for problem transformation\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "To solve this in TypeScript, you'll need to know:\n\n- **0/1 Knapsack** pattern\n- **Subset sum** DP\n- **Array operations**\n- **Basic algebra** for problem transformation\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "# The Problem: Target Sum ‚ûï‚ûñ\n\n**Real-world analogy:** You're a teacher creating a math quiz. You have a list of numbers and want students to place + or - signs in front of each number to reach a target sum. For example, with [1, 2, 3] and target 0, they could write: +1 -2 +3 - 2 = 0. How many different ways can students assign signs to hit the target?\n\n## The Challenge:\n\nGiven an array of non-negative integers `nums` and an integer `target`, find the number of ways to assign + or - signs to each number to make the sum equal target.\n\nYou must use all numbers exactly once.\n\n## Example:\n```\nnums = [1, 1, 1, 1, 1]\ntarget = 3\n\nOutput: 5\nExplanation:\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n```\n\nThere are 5 different ways!",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "# ü§î How Can We Simplify This?\n\nAt first glance, this seems like we need to try every combination of +/- signs (2^n possibilities!).\n\nBut there's a mathematical transformation that makes this much simpler...\n\n**Question:** If we split numbers into two groups - P (positive signs) and N (negative signs) - what equation must hold?",
      "choices": [
        {
          "label": "sum(P) - sum(N) = target",
          "next": "correct-equation"
        },
        {
          "label": "sum(P) + sum(N) = target",
          "next": "wrong-addition"
        },
        {
          "label": "sum(P) = sum(N) = target/2",
          "next": "wrong-equal"
        }
      ]
    },
    {
      "stepId": "wrong-addition",
      "mentorSays": "Not quite! Remember, numbers in N have negative signs, so they're subtracted.\n\nThink about what the equation +1 -2 +3 = 2 really means...",
      "action": "next",
      "next": "correct-equation"
    },
    {
      "stepId": "wrong-equal",
      "mentorSays": "That would be true if target was 0, but we need to handle any target.\n\nThink about the general relationship between P, N, and target...",
      "action": "next",
      "next": "correct-equation"
    },
    {
      "stepId": "correct-equation",
      "mentorSays": "# The Mathematical Transformation! üéì\n\nExactly! If P = positive numbers and N = negative numbers:\n\n**sum(P) - sum(N) = target** ... (1)\n\nWe also know:\n**sum(P) + sum(N) = total** ... (2) (all numbers)\n\nAdding equations (1) and (2):\n```\nsum(P) - sum(N) = target\nsum(P) + sum(N) = total\n----------------------------\n2 √ó sum(P) = target + total\n\nsum(P) = (target + total) / 2\n```\n\n**üéØ The insight:** We just need to count subsets that sum to `(target + total) / 2`!\n\nThis transforms our problem into subset sum - which we already know how to solve!",
      "action": "next",
      "next": "math-transformation-derivation"
    },
    {
      "stepId": "math-transformation-derivation",
      "mentorSays": "### Math Transformation Derivation (Step-by-Step)\n\n**Step 1: Define the problem mathematically**\n\nGiven: Assign + or - to each number in `nums` to get `target`\n\nSplit numbers into two groups:\n- **P** = numbers with + sign (positive group)\n- **N** = numbers with - sign (negative group)\n\n**Step 2: Write the constraint equation**\n\n```\nsum(P) - sum(N) = target  ... (Equation 1)\n```\n\nThis says: positive sum minus negative sum equals target.\n\n**Step 3: Write the total sum equation**\n\nSince we use all numbers exactly once:\n```\nsum(P) + sum(N) = total  ... (Equation 2)\n```\n\nWhere `total = sum(nums)` (sum of all numbers).\n\n**Step 4: Solve the system of equations**\n\nWe have two equations:\n```\n(1) sum(P) - sum(N) = target\n(2) sum(P) + sum(N) = total\n```\n\n**Method: Add equations to eliminate sum(N)**\n\n```\n(1) + (2):\n  sum(P) - sum(N) = target\n+ sum(P) + sum(N) = total\n----------------------------\n  2 √ó sum(P)      = target + total\n```\n\n**Step 5: Solve for sum(P)**\n\n```\nsum(P) = (target + total) / 2\n```\n\n**Step 6: Transform the problem**\n\nOriginal problem: Count ways to assign +/- to get `target`\n\nNew problem: Count subsets of `nums` that sum to `(target + total) / 2`\n\n**Step 7: Check validity conditions**\n\n1. `(target + total)` must be even (otherwise no solution)\n2. `target <= total` (otherwise impossible)\n3. `(target + total) / 2 >= 0` (subset sum must be non-negative)\n\n**This step-by-step derivation transforms a complex sign-assignment problem into a simple subset-sum problem!**",
      "action": "next",
      "next": "dp-update-numerically"
    },
    {
      "stepId": "dp-update-numerically",
      "mentorSays": "### One DP Update Numerically\n\n**Example:** `nums = [1, 1, 1, 1, 1]`, `target = 3`\n\n**After transformation:**\n- `total = 5`\n- `subsetSum = (3 + 5) / 2 = 4`\n- We need to count subsets that sum to 4\n\n**DP state:** `dp[i] = number of ways to make sum i`\n\n**Initial state:**\n```\ndp = [1, 0, 0, 0, 0, 0]\n     ‚Üë\n   sum=0: 1 way (use nothing)\n```\n\n**Processing first number (1):**\n\nWe iterate backwards from `sum = 4` down to `1`:\n\n```\nFor sum = 4: dp[4] += dp[4-1] = dp[3] = 0 ‚Üí dp[4] = 0\nFor sum = 3: dp[3] += dp[3-1] = dp[2] = 0 ‚Üí dp[3] = 0\nFor sum = 2: dp[2] += dp[2-1] = dp[1] = 0 ‚Üí dp[2] = 0\nFor sum = 1: dp[1] += dp[1-1] = dp[0] = 1 ‚Üí dp[1] = 1 ‚úì\n```\n\n**After first number:**\n```\ndp = [1, 1, 0, 0, 0, 0]\n     ‚Üë  ‚Üë\n     0  1 ways to make sum 1: {1}\n```\n\n**Processing second number (1):**\n\n```\nFor sum = 4: dp[4] += dp[3] = 0 ‚Üí dp[4] = 0\nFor sum = 3: dp[3] += dp[2] = 0 ‚Üí dp[3] = 0\nFor sum = 2: dp[2] += dp[1] = 1 ‚Üí dp[2] = 1 ‚úì\nFor sum = 1: dp[1] += dp[0] = 1 ‚Üí dp[1] = 2 ‚úì\n```\n\n**After second number:**\n```\ndp = [1, 2, 1, 0, 0, 0]\n     ‚Üë  ‚Üë  ‚Üë\n     0  1  2 ways to make sum 1: {1}, {1}\n         1 way to make sum 2: {1,1}\n```\n\n**Continue for all 5 numbers...**\n\n**Final:** `dp[4] = 5` (5 ways to make sum 4)\n\n**This numeric DP update shows how each number contributes to the count!**",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "# Let's Walk Through an Example üö∂\n\n```\nnums = [1, 1, 1, 1, 1]\ntarget = 3\ntotal = 5\nsubsetSum = (3 + 5) / 2 = 4\n```\n\nWe need to count subsets that sum to 4.\n\n**Initial:** dp = [1, 0, 0, 0, 0] (one way to make 0)\n\n**Process 1:**\n- dp[4] += dp[3] = 0\n- dp[3] += dp[2] = 0\n- dp[2] += dp[1] = 0\n- dp[1] += dp[0] = 1 ‚úì\n- Result: dp = [1, 1, 0, 0, 0]\n\n**Process 1 (second):**\n- dp[2] += dp[1] = 1 ‚úì\n- dp[1] += dp[0] = 1 (2 ways now!)\n- Result: dp = [1, 2, 1, 0, 0]\n\n**Process 1 (third):**\n- dp[3] += dp[2] = 1 ‚úì\n- dp[2] += dp[1] = 2 (3 ways!)\n- dp[1] += dp[0] = 1 (3 ways!)\n- Result: dp = [1, 3, 3, 1, 0]\n\n**Continue...**\n\nFinal: dp[4] = 5 ways!",
      "action": "next",
      "next": "pseudocode-step"
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "# Here's Our Battle Plan üìã",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7",
        "ps8",
        "ps9",
        "ps10"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "# Time to Code! üíª\n\nWe'll transform the problem mathematically, then use subset sum counting.",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Start with calculating the total and target subset sum:\n\n```javascript\nfunction findTargetSumWays(nums, target) {\n    const total = nums.reduce((a, b) => a + b, 0);\n```",
      "action": "next",
      "next": "code-02",
      "example": "function findTargetSumWays(nums, target) {\n    const total = nums.reduce((a, b) => a + b, 0);"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Check if the problem is solvable:\n\n```javascript\n    // If (target + total) is odd or target > total, impossible\n    if ((target + total) % 2 !== 0 || Math.abs(target) > total) {\n        return 0;\n    }\n```\n\nWe need (target + total) / 2 to be an integer!",
      "action": "next",
      "next": "code-03",
      "example": "    if ((target + total) % 2 !== 0 || Math.abs(target) > total) {\n        return 0;\n    }"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Calculate the subset sum we're looking for:\n\n```javascript\n    const subsetSum = (target + total) / 2;\n```",
      "action": "next",
      "next": "code-04",
      "example": "    const subsetSum = (target + total) / 2;"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Create DP array for counting subsets:\n\n```javascript\n    // dp[i] = number of ways to make sum i\n    const dp = new Array(subsetSum + 1).fill(0);\n    dp[0] = 1; // One way to make 0: use nothing\n```",
      "action": "next",
      "next": "code-05",
      "example": "    const dp = new Array(subsetSum + 1).fill(0);\n    dp[0] = 1;"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Iterate through each number:\n\n```javascript\n    for (const num of nums) {\n```",
      "action": "next",
      "next": "code-06",
      "example": "    for (const num of nums) {"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Update DP array backwards (to avoid reusing same number):\n\n```javascript\n        for (let sum = subsetSum; sum >= num; sum--) {\n            dp[sum] += dp[sum - num];\n        }\n```\n\nWe ADD the number of ways (not just set to true like boolean DP)!",
      "action": "next",
      "next": "code-07",
      "example": "        for (let sum = subsetSum; sum >= num; sum--) {\n            dp[sum] += dp[sum - num];\n        }"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Close loops and return result:\n\n```javascript\n    }\n    return dp[subsetSum];\n}\n```",
      "action": "next",
      "next": "complexity-analysis",
      "example": "    }\n    return dp[subsetSum];\n}"
    },
    {
      "stepId": "complexity-analysis",
      "mentorSays": "# Complexity Analysis üìä\n\n## Time Complexity: O(n √ó sum)\n- n = number of elements\n- sum = (target + total) / 2\n- Same as subset sum problem\n\n## Space Complexity: O(sum)\n- Single DP array of size sum + 1\n\n## Comparison:\n\n**Brute force:** O(2^n) - try all sign combinations\n**Our solution:** O(n √ó sum) - polynomial in value\n\nMassive improvement through mathematical transformation!",
      "action": "next",
      "next": "edge-cases"
    },
    {
      "stepId": "edge-cases",
      "mentorSays": "# Edge Cases üéØ\n\n1. **Impossible target:** target > total sum ‚Üí return 0\n\n2. **Odd (target + total):** Can't split into integer ‚Üí return 0\n\n3. **Zeros in array:** [0, 0, 1], target = 1 ‚Üí 4 ways (both zeros can be +/- )\n\n4. **Single element:** [1], target = 1 ‚Üí 1 way (+1)\n\n5. **Negative target:** [-1, 1], target = -2 ‚Üí 1 way (-1 -1)\n\nOur solution handles all of these!",
      "action": "next",
      "next": "common-mistakes"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "# Congratulations! üéâ\n\nYou've mastered **problem transformation** - turning a complex problem into one you already know!\n\n## What You Learned:\n\n‚úÖ Mathematical problem transformation\n‚úÖ Counting variations with DP (vs boolean DP)\n‚úÖ When algebra simplifies coding problems\n‚úÖ Advanced knapsack applications\n\n## Next Steps:\n\nReady for grid DP? The next lesson is **Unique Paths II** - navigating grids with obstacles. Different domain, but similar DP thinking!\n\nThe transformation technique you learned here is incredibly powerful - watch for it in other problems!\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}

================================================================================

E:\projects\inpact\inpact\algo\generated\generated-lessons-v2\lesson-65-unique-paths-ii.json:
{
  "id": "unique-paths-ii",
  "title": "Unique Paths II - Grid DP with Obstacles",
  "pattern": "grid-dp-obstacles",
  "difficulty": "medium",
  "language": "javascript",
  "status": "AI-GENERATED-V2-DIRECT",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 65,
    "tier": "MASTERY-I",
    "lessonOrderTag": "MASTERY-I-65",
    "introduces": [
      "grid-dp",
      "obstacle-handling",
      "2d-dp-arrays"
    ],
    "assumesAlreadyTaught": [
      "dynamic-programming",
      "arrays",
      "2d-arrays"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "minimum-path-sum"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "If start or end is obstacle, return 0"
    },
    {
      "id": "ps2",
      "text": "Create DP grid same size as input grid"
    },
    {
      "id": "ps3",
      "text": "Initialize dp[0][0] = 1 (starting position)"
    },
    {
      "id": "ps4",
      "text": "Fill first row: dp[0][j] = dp[0][j-1] if no obstacle, else 0"
    },
    {
      "id": "ps5",
      "text": "Fill first column: dp[i][0] = dp[i-1][0] if no obstacle, else 0"
    },
    {
      "id": "ps6",
      "text": "For each cell (i, j) in grid:"
    },
    {
      "id": "ps7",
      "text": "  If cell is obstacle: dp[i][j] = 0"
    },
    {
      "id": "ps8",
      "text": "  Else: dp[i][j] = dp[i-1][j] + dp[i][j-1]"
    },
    {
      "id": "ps9",
      "text": "Return dp[m-1][n-1]"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "# Welcome to Unique Paths II! ü§ñ\n\nYou're about to learn one of the most practical DP patterns: **grid navigation with obstacles**.\n\n## What You'll Master:\n\n- Solving grid DP problems with constraints\n- Handling obstacles in pathfinding\n- 2D DP array initialization and filling\n- Real-world robot navigation\n\nThis pattern is used in robotics, warehouse automation, game development, and logistics!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Which programming language would you like to use for this lesson?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "Python",
          "next": "prereq-check-python"
        },
        {
          "label": "Java",
          "next": "prereq-check-java"
        },
        {
          "label": "C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "To solve this in JavaScript, you'll need to know:\n\n- **Dynamic programming** fundamentals\n- **2D arrays** (arrays of arrays)\n- **Grid traversal**\n- **Basic iteration**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-js"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "To solve this in Python, you'll need to know:\n\n- **Dynamic programming** fundamentals\n- **2D lists** (lists of lists)\n- **Grid traversal**\n- **Basic iteration**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-python"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "To solve this in Java, you'll need to know:\n\n- **Dynamic programming** fundamentals\n- **2D arrays** (int[][])\n- **Grid traversal**\n- **Basic iteration**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-java"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "To solve this in C++, you'll need to know:\n\n- **Dynamic programming** fundamentals\n- **2D vectors** (vector<vector<int>>)\n- **Grid traversal**\n- **Basic iteration**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "To solve this in TypeScript, you'll need to know:\n\n- **Dynamic programming** fundamentals\n- **2D arrays** with type annotations\n- **Grid traversal**\n- **Basic iteration**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "# The Problem: Unique Paths II üöß\n\n**Real-world analogy:** Imagine you're programming a warehouse robot that needs to navigate from the loading dock (top-left) to the shipping area (bottom-right). The robot can only move right or down. Some aisles are blocked by inventory (obstacles marked as 1). How many different valid paths can the robot take?\n\n## The Challenge:\n\nYou're given an `m x n` grid. A robot starts at `grid[0][0]` and wants to reach `grid[m-1][n-1]`. The robot can only move down or right at any point.\n\nCells with value `1` are obstacles - the robot cannot pass through them.\nCells with value `0` are open paths.\n\nReturn the number of possible unique paths the robot can take to reach the destination.\n\n## Example:\n```\ngrid = [\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\nOutput: 2\n\nPaths:\n1. Right ‚Üí Right ‚Üí Down ‚Üí Down\n2. Down ‚Üí Down ‚Üí Right ‚Üí Right\n```\n\nThe middle obstacle blocks the direct diagonal approaches!",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "# ü§î How Should We Think About This?\n\nLet's think about the robot's decision-making:\n\n**Question:** At any cell (i, j), how many ways can the robot reach that cell?",
      "choices": [
        {
          "label": "The sum of ways to reach all previous cells",
          "next": "wrong-all-previous"
        },
        {
          "label": "The sum of ways to reach the cell above and the cell to the left",
          "next": "core-idea"
        },
        {
          "label": "We need to try all possible paths with backtracking",
          "next": "wrong-backtracking"
        }
      ]
    },
    {
      "stepId": "wrong-all-previous",
      "mentorSays": "Not quite! The robot can only move right or down, so it can only arrive from two directions.\n\nThink about which cells can directly lead to cell (i, j)...",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "wrong-backtracking",
      "mentorSays": "Backtracking would work but is incredibly inefficient! We'd be recalculating the same sub-paths many times.\n\nThere's a much smarter way using dynamic programming...",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "# The Key Insight: Grid DP üí°\n\n**Perfect!** At any cell (i, j), the robot can only arrive from:\n1. The cell above (i-1, j) - if it exists\n2. The cell to the left (i, j-1) - if it exists\n\n**Core recurrence:**\n```\ndp[i][j] = dp[i-1][j] + dp[i][j-1]\n```\n\n**But with obstacles:**\n```\nif grid[i][j] == 1:\n    dp[i][j] = 0  // Obstacle! No paths through here\nelse:\n    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n```\n\n## Why This Works:\n\nWe build up the solution from the start, cell by cell. Each cell's answer depends only on the answers for cells we've already computed. Classic DP!",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "# Let's Walk Through an Example üö∂\n\n```\ngrid = [\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\n```\n\n**Step 1:** Initialize first cell\n```\ndp = [\n  [1,0,0],\n  [0,0,0],\n  [0,0,0]\n]\n```\n\n**Step 2:** Fill first row (can only come from left)\n```\ndp = [\n  [1,1,1],\n  [0,0,0],\n  [0,0,0]\n]\n```\n\n**Step 3:** Fill first column (can only come from above)\n```\ndp = [\n  [1,1,1],\n  [1,0,0],\n  [1,0,0]\n]\n```\n\n**Step 4:** Fill remaining cells\n- dp[1][1] = obstacle! = 0\n- dp[1][2] = dp[0][2] + dp[1][1] = 1 + 0 = 1\n- dp[2][1] = dp[1][1] + dp[2][0] = 0 + 1 = 1\n- dp[2][2] = dp[1][2] + dp[2][1] = 1 + 1 = 2 ‚úì\n\n**Final:**\n```\ndp = [\n  [1,1,1],\n  [1,0,1],\n  [1,1,2]\n]\n```\n\nAnswer: 2 paths!",
      "action": "next",
      "next": "pseudocode-step"
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "# Here's Our Battle Plan üìã",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7",
        "ps8",
        "ps9"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "# Time to Code! üíª\n\nWe'll build this solution step by step, handling obstacles carefully.",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Start with the function signature and edge case checks:\n\n```javascript\nfunction uniquePathsWithObstacles(obstacleGrid) {\n    const m = obstacleGrid.length;\n    const n = obstacleGrid[0].length;\n```",
      "action": "next",
      "next": "code-02",
      "example": "function uniquePathsWithObstacles(obstacleGrid) {\n    const m = obstacleGrid.length;\n    const n = obstacleGrid[0].length;"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Check if start or end is blocked:\n\n```javascript\n    // If start or end is obstacle, no path possible\n    if (obstacleGrid[0][0] === 1 || obstacleGrid[m-1][n-1] === 1) {\n        return 0;\n    }\n```",
      "action": "next",
      "next": "code-03",
      "example": "    if (obstacleGrid[0][0] === 1 || obstacleGrid[m-1][n-1] === 1) {\n        return 0;\n    }"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Create DP grid and initialize starting position:\n\n```javascript\n    // Create DP grid\n    const dp = Array(m).fill(0).map(() => Array(n).fill(0));\n    dp[0][0] = 1; // Starting position\n```",
      "action": "next",
      "next": "code-04",
      "example": "    const dp = Array(m).fill(0).map(() => Array(n).fill(0));\n    dp[0][0] = 1;"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Fill the first row:\n\n```javascript\n    // Fill first row\n    for (let j = 1; j < n; j++) {\n        dp[0][j] = (obstacleGrid[0][j] === 1) ? 0 : dp[0][j-1];\n    }\n```\n\nIf there's an obstacle, that cell and all cells after it in the row become unreachable from the start.",
      "action": "next",
      "next": "code-05",
      "example": "    for (let j = 1; j < n; j++) {\n        dp[0][j] = (obstacleGrid[0][j] === 1) ? 0 : dp[0][j-1];\n    }"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Fill the first column:\n\n```javascript\n    // Fill first column\n    for (let i = 1; i < m; i++) {\n        dp[i][0] = (obstacleGrid[i][0] === 1) ? 0 : dp[i-1][0];\n    }\n```\n\nSame logic: obstacle blocks all cells below it in the column.",
      "action": "next",
      "next": "code-06",
      "example": "    for (let i = 1; i < m; i++) {\n        dp[i][0] = (obstacleGrid[i][0] === 1) ? 0 : dp[i-1][0];\n    }"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Now fill the rest of the grid:\n\n```javascript\n    // Fill remaining cells\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n```",
      "action": "next",
      "next": "code-07",
      "example": "    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Check if current cell is an obstacle:\n\n```javascript\n            if (obstacleGrid[i][j] === 1) {\n                dp[i][j] = 0;\n```\n\nIf it's an obstacle, no paths go through it!",
      "action": "next",
      "next": "code-08",
      "example": "            if (obstacleGrid[i][j] === 1) {\n                dp[i][j] = 0;"
    },
    {
      "stepId": "code-08",
      "mentorSays": "Otherwise, sum paths from above and left:\n\n```javascript\n            } else {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\n            }\n```\n\nThis is the core DP recurrence!",
      "action": "next",
      "next": "code-09",
      "example": "            } else {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\n            }"
    },
    {
      "stepId": "code-09",
      "mentorSays": "Close the loops and return the result:\n\n```javascript\n        }\n    }\n    return dp[m-1][n-1];\n}\n```\n\nThe bottom-right cell contains our answer!",
      "action": "next",
      "next": "complexity-analysis",
      "example": "        }\n    }\n    return dp[m-1][n-1];\n}"
    },
    {
      "stepId": "complexity-analysis",
      "mentorSays": "# Complexity Analysis üìä\n\n## Time Complexity: O(m √ó n)\n- We visit each cell exactly once\n- m = number of rows, n = number of columns\n- Each cell requires O(1) work\n\n## Space Complexity: O(m √ó n)\n- We use a 2D DP array of size m √ó n\n- Can be optimized to O(n) by using only one row at a time!\n\n## Space Optimization:\n\nSince each row only depends on the previous row, we could use just two 1D arrays (or even one with careful updates). But the 2D approach is clearer and m √ó n is usually acceptable.",
      "action": "next",
      "next": "edge-cases"
    },
    {
      "stepId": "edge-cases",
      "mentorSays": "# Edge Cases to Consider üéØ\n\n1. **Start is obstacle:** grid[0][0] = 1 ‚Üí return 0\n\n2. **End is obstacle:** grid[m-1][n-1] = 1 ‚Üí return 0\n\n3. **Single cell:** [[0]] ‚Üí return 1, [[1]] ‚Üí return 0\n\n4. **All obstacles:** No valid path ‚Üí return 0\n\n5. **No obstacles:** Same as Unique Paths I problem\n\n6. **Obstacle in first row/column:** Blocks all cells after it in that row/column\n\nOur implementation handles all these correctly!",
      "action": "next",
      "next": "common-mistakes"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "# Congratulations! üéâ\n\nYou've mastered **grid DP with constraints**!\n\n## What You Learned:\n\n‚úÖ Solving DP problems on 2D grids\n‚úÖ Handling obstacles and constraints\n‚úÖ Building solutions bottom-up with DP\n‚úÖ Initializing grid DP correctly\n\n## Next Steps:\n\nReady for optimization? The next lesson is **Minimum Path Sum** - finding the cheapest path through a weighted grid. It builds directly on what you learned here!\n\nGrid DP is everywhere: games, robotics, route planning. Master this pattern!\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}

================================================================================

E:\projects\inpact\inpact\algo\generated\generated-lessons-v2\lesson-66-minimum-path-sum.json:
{
  "id": "minimum-path-sum",
  "title": "Minimum Path Sum - Grid DP Optimization",
  "pattern": "grid-dp-minimization",
  "difficulty": "medium",
  "language": "javascript",
  "status": "AI-GENERATED-V2-DIRECT",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 66,
    "tier": "MASTERY-I",
    "lessonOrderTag": "MASTERY-I-66",
    "introduces": [
      "grid-path-cost",
      "in-place-dp"
    ],
    "assumesAlreadyTaught": [
      "grid-dp",
      "dynamic-programming"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "decode-ways"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Create DP grid same size as input"
    },
    {
      "id": "ps2",
      "text": "Set dp[0][0] = grid[0][0]"
    },
    {
      "id": "ps3",
      "text": "Fill first row with cumulative sums"
    },
    {
      "id": "ps4",
      "text": "Fill first column with cumulative sums"
    },
    {
      "id": "ps5",
      "text": "For each cell: dp[i][j] = grid[i][j] + min(top, left)"
    },
    {
      "id": "ps6",
      "text": "Return dp[m-1][n-1]"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "# Welcome to Minimum Path Sum! üõ£Ô∏è\n\nFind the minimum cost path through a grid!\n\n## What You'll Master:\n- Grid DP optimization\n- Path cost minimization\n- Space-efficient solutions",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Which language?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "Python",
          "next": "prereq-check-python"
        },
        {
          "label": "Java",
          "next": "prereq-check-java"
        },
        {
          "label": "C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "Prerequisites: Grid DP, 2D arrays. Ready?",
      "choices": [
        {
          "label": "Yes!",
          "next": "problem-understanding"
        },
        {
          "label": "No",
          "next": "teach-prereqs-js"
        },
        {
          "label": "Review",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "Prerequisites: Grid DP, 2D arrays. Ready?",
      "choices": [
        {
          "label": "Yes!",
          "next": "problem-understanding"
        },
        {
          "label": "No",
          "next": "teach-prereqs-python"
        },
        {
          "label": "Review",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "Prerequisites: Grid DP, 2D arrays. Ready?",
      "choices": [
        {
          "label": "Yes!",
          "next": "problem-understanding"
        },
        {
          "label": "No",
          "next": "teach-prereqs-java"
        },
        {
          "label": "Review",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "Prerequisites: Grid DP, 2D arrays. Ready?",
      "choices": [
        {
          "label": "Yes!",
          "next": "problem-understanding"
        },
        {
          "label": "No",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "Review",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "Prerequisites: Grid DP, 2D arrays. Ready?",
      "choices": [
        {
          "label": "Yes!",
          "next": "problem-understanding"
        },
        {
          "label": "No",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "Review",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "# Minimum Path Sum\n\n**Analogy:** GPS finding cheapest route through toll roads.\n\nGiven m√ón grid of costs, find minimum cost path from top-left to bottom-right (only move right or down).",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "How to find minimum path?",
      "choices": [
        {
          "label": "Try all paths",
          "next": "wrong"
        },
        {
          "label": "DP: min(from top, from left) + current",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong",
      "mentorSays": "Too slow! DP is better.",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "# Key Insight!\n\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n\nMinimum cost to reach any cell = current cost + minimum of (from above, from left).",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "# Example\n\nGrid:\n```\n1 3 1\n1 5 1\n4 2 1\n```\nMin path: 1‚Üí3‚Üí1‚Üí1‚Üí1 = 7",
      "action": "next",
      "next": "pseudocode-step"
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "# Plan",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "# Let's Code!",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Setup:\n\n```javascript\nfunction minPathSum(grid) {\n    const m = grid.length, n = grid[0].length;\n    const dp = Array(m).fill(0).map(() => Array(n).fill(0));\n```",
      "action": "next",
      "next": "code-02",
      "example": "function minPathSum(grid) {\n    const m = grid.length, n = grid[0].length;\n    const dp = Array(m).fill(0).map(() => Array(n).fill(0));"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Initialize first cell:\n\n```javascript\n    dp[0][0] = grid[0][0];\n```",
      "action": "next",
      "next": "code-03",
      "example": "    dp[0][0] = grid[0][0];"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Fill first row:\n\n```javascript\n    for (let j = 1; j < n; j++) {\n        dp[0][j] = dp[0][j-1] + grid[0][j];\n    }\n```",
      "action": "next",
      "next": "code-04",
      "example": "    for (let j = 1; j < n; j++) {\n        dp[0][j] = dp[0][j-1] + grid[0][j];\n    }"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Fill first column:\n\n```javascript\n    for (let i = 1; i < m; i++) {\n        dp[i][0] = dp[i-1][0] + grid[i][0];\n    }\n```",
      "action": "next",
      "next": "code-05",
      "example": "    for (let i = 1; i < m; i++) {\n        dp[i][0] = dp[i-1][0] + grid[i][0];\n    }"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Fill remaining cells:\n\n```javascript\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n```",
      "action": "next",
      "next": "code-06",
      "example": "    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);\n        }\n    }"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Return result:\n\n```javascript\n    return dp[m-1][n-1];\n}\n```",
      "action": "next",
      "next": "complexity-analysis",
      "example": "    return dp[m-1][n-1];\n}"
    },
    {
      "stepId": "complexity-analysis",
      "mentorSays": "# Complexity\n\nTime: O(m√ón)\nSpace: O(m√ón) - can optimize to O(n)!",
      "action": "next",
      "next": "edge-cases"
    },
    {
      "stepId": "edge-cases",
      "mentorSays": "# Edge Cases\n\n1. Single cell: return grid[0][0]\n2. Single row/column: sum all cells",
      "action": "next",
      "next": "common-mistakes"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "# Complete! üéâ\n\nYou've mastered grid DP path optimization!\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}

================================================================================

E:\projects\inpact\inpact\algo\generated\generated-lessons-v2\lesson-67-decode-ways.json:
{
  "id": "decode-ways",
  "title": "Decode Ways - String DP",
  "pattern": "string-dp-decoding",
  "difficulty": "medium",
  "language": "javascript",
  "status": "AI-GENERATED-V2-DIRECT",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 67,
    "tier": "MASTERY-I",
    "lessonOrderTag": "MASTERY-I-67",
    "introduces": [
      "string-dp",
      "decode-patterns"
    ],
    "assumesAlreadyTaught": [
      "dynamic-programming",
      "strings"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": []
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Create dp array where dp[i] = ways to decode string[0..i-1]"
    },
    {
      "id": "ps2",
      "text": "dp[0] = 1 (empty string)"
    },
    {
      "id": "ps3",
      "text": "dp[1] = 1 if first char not '0'"
    },
    {
      "id": "ps4",
      "text": "For i from 2 to n:"
    },
    {
      "id": "ps5",
      "text": "  If single digit valid: dp[i] += dp[i-1]"
    },
    {
      "id": "ps6",
      "text": "  If two digit valid (10-26): dp[i] += dp[i-2]"
    },
    {
      "id": "ps7",
      "text": "Return dp[n]"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "# Welcome to Decode Ways - String DP! üéØ\n\nLearn string DP by decoding numeric messages!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Which programming language?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "Python",
          "next": "prereq-check-python"
        },
        {
          "label": "Java",
          "next": "prereq-check-java"
        },
        {
          "label": "C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "Prerequisites: DP, Strings. Ready?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-js"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "Prerequisites: DP, Strings. Ready?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-python"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "Prerequisites: DP, Strings. Ready?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-java"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "Prerequisites: DP, Strings. Ready?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "Prerequisites: DP, Strings. Ready?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "# The Problem\n\n**Analogy:** Decoding encrypted messages where digits can be grouped different ways\n\nGiven string of digits, count ways to decode it (1=A, 2=B, ..., 26=Z)",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "How should we approach this?",
      "choices": [
        {
          "label": "Brute force",
          "next": "wrong"
        },
        {
          "label": "DP: ways[i] = ways[i-1] + ways[i-2] if valid",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong",
      "mentorSays": "Brute force is too slow. There's a better way...",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "# Key Insight! üí°\n\nSimilar to climbing stairs! Each position can be reached in multiple ways.",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "# Example Walkthrough\n\n'226' can be decoded as 'BZ', 'VF', 'BBF' = 3 ways",
      "action": "next",
      "next": "pseudocode-step"
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "# Battle Plan",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "# Let's Code! üíª",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Setup and initialize:\n\n```javascript\nfunction numDecodings(s) {\n    if (!s || s[0] === '0') return 0;\n    const n = s.length;\n    const dp = new Array(n + 1).fill(0);\n```",
      "action": "next",
      "next": "code-02",
      "example": "function numDecodings(s) {\n    if (!s || s[0] === '0') return 0;\n    const n = s.length;\n    const dp = new Array(n + 1).fill(0);"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Base cases:\n\n```javascript\n    dp[0] = 1; // empty string\n    dp[1] = 1; // first character (already checked not '0')\n```",
      "action": "next",
      "next": "code-03",
      "example": "    dp[0] = 1;\n    dp[1] = 1;"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Fill DP array:\n\n```javascript\n    for (let i = 2; i <= n; i++) {\n```",
      "action": "next",
      "next": "code-04",
      "example": "    for (let i = 2; i <= n; i++) {"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Check single digit:\n\n```javascript\n        if (s[i - 1] !== '0') {\n            dp[i] += dp[i - 1];\n        }\n```",
      "action": "next",
      "next": "code-05",
      "example": "        if (s[i - 1] !== '0') {\n            dp[i] += dp[i - 1];\n        }"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Check two digits:\n\n```javascript\n        const twoDigit = parseInt(s.substring(i - 2, i));\n        if (twoDigit >= 10 && twoDigit <= 26) {\n            dp[i] += dp[i - 2];\n        }\n    }\n```",
      "action": "next",
      "next": "code-06",
      "example": "        const twoDigit = parseInt(s.substring(i - 2, i));\n        if (twoDigit >= 10 && twoDigit <= 26) {\n            dp[i] += dp[i - 2];\n        }\n    }"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Return result:\n\n```javascript\n    return dp[n];\n}\n```",
      "action": "next",
      "next": "complexity-analysis",
      "example": "    return dp[n];\n}"
    },
    {
      "stepId": "complexity-analysis",
      "mentorSays": "# Complexity Analysis\n\nTime: O(n), Space: O(n) or O(1) optimized",
      "action": "next",
      "next": "edge-cases"
    },
    {
      "stepId": "edge-cases",
      "mentorSays": "# Edge Cases\n\nLeading zeros, '0' in middle, invalid sequences",
      "action": "next",
      "next": "common-mistakes"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "# Congratulations! üéâ\n\nYou've mastered this pattern!\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}

================================================================================
CONSOLIDATED 12 FILES
================================================================================
