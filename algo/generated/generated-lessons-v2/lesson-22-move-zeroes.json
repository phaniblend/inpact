{
  "id": "move-zeroes",
  "title": "Move Zeroes",
  "pattern": "slow-fast pointers",
  "difficulty": "easy",
  "language": "javascript",
  "status": "AI-GENERATED-V2-BATCH",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 22,
    "tier": "FOUNDATION",
    "lessonOrderTag": "FOUNDATION-22",
    "introduces": [
      "partition-like-operation",
      "relative-order-preservation"
    ],
    "assumesAlreadyTaught": [
      "arrays",
      "slow-fast-pointers",
      "swap-technique"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "squares-of-sorted-array"
    ]
  },
  "problemStatement": {
    "description": "Move all zeros to the end of an array while maintaining the relative order of non-zero elements. Modify the array in-place.",
    "inputs": [
      "nums: array of integers (length 1 to 10^4)"
    ],
    "outputs": [
      "Modify nums in-place (no return value needed, or return the modified array)"
    ],
    "examples": [
      {
        "input": "nums = [0,1,0,3,12]",
        "output": "[1,3,12,0,0]",
        "explanation": "Move zeros to end while keeping non-zeros in original order. Slow pointer tracks next position for non-zero, fast finds non-zeros and swaps them."
      },
      {
        "input": "nums = [0]",
        "output": "[0]",
        "explanation": "Single zero, already at end. No changes needed."
      },
      {
        "input": "nums = [1,0,2,0,3]",
        "output": "[1,2,3,0,0]",
        "explanation": "Move zeros to end: [1,2,3,0,0]. Non-zeros maintain relative order."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-2^31 <= nums[i] <= 2^31 - 1"
    ],
    "realWorldUse": [
      "Data filtering and partitioning",
      "Array reorganization",
      "In-place array operations",
      "Maintaining order while segregating elements"
    ]
  },
  "patternRecognition": {
    "whyThisPattern": "We need to partition the array: non-zeros on the left, zeros on the right, while preserving relative order. The slow-fast pointer pattern allows us to do this in-place efficiently.",
    "signalsToRecognize": [
      "SIGNAL 1: Problem asks to move/partition elements while preserving order â†’ think slow-fast pointers",
      "SIGNAL 2: Need in-place modification â†’ use two-pointer partition",
      "SIGNAL 3: Segregate elements based on condition â†’ slow tracks write position, fast finds valid elements"
    ],
    "patternRules": [
      "If problem involves partitioning array in-place â†’ use slow-fast pointers",
      "When you see 'move to end', 'partition', or 'segregate' â†’ consider two-pointer approach",
      "If need to preserve relative order â†’ swap instead of overwrite"
    ],
    "whyNotOtherApproaches": {
      "greedy": "Actually uses greedy approach - at each step, move non-zero to slow position. This is the greedy partition pattern.",
      "bruteForce": "Creating new array and copying works but uses O(n) space. Two-pointer uses O(1) space.",
      "alternative": "Counting zeros then filling works but requires two passes. Single-pass two-pointer is more efficient."
    }
  },
  "coreInvariant": {
    "statement": "All elements at indices [0..slow-1] are non-zero and in their original relative order. Elements at indices [slow..fast-1] are zeros. Slow points to the next position where a non-zero should be placed.",
    "explanation": "This invariant holds because we only increment slow and swap when fast finds a non-zero. This ensures non-zeros are moved to the left while preserving their order, and zeros accumulate between slow and fast.",
    "whyItMatters": "This invariant guarantees correctness: after processing, all non-zeros are at positions [0..slow-1] in original order, and zeros are at positions [slow..n-1]."
  },
  "stateDefinition": {
    "states": [
      {
        "name": "slow",
        "meaning": "Pointer tracking the next position for a non-zero element (0-indexed)",
        "indexing": "0-indexed, starts at 0"
      },
      {
        "name": "fast",
        "meaning": "Pointer scanning through array to find non-zero elements (0-indexed)",
        "indexing": "0-indexed, starts at 0, iterates through array"
      },
      {
        "name": "nums",
        "meaning": "Array being modified in-place",
        "indexing": "0-indexed array"
      }
    ],
    "baseCases": [
      "If nums.length == 0: return (no processing needed)",
      "If all elements are non-zero: no swaps needed, array unchanged"
    ]
  },
  "transitionLogic": {
    "rules": [
      {
        "condition": "if nums[fast] != 0",
        "transition": "Swap nums[slow] and nums[fast], then slow++",
        "explanation": "Found non-zero element. Swap it to slow position to move it left, then increment slow to next write position.",
        "example": "nums=[0,1,0,3], slow=0, fast=1: nums[1]=1 != 0, swap nums[0] and nums[1], slow=1"
      },
      {
        "condition": "if nums[fast] == 0",
        "transition": "fast++ (skip zero, don't swap)",
        "explanation": "Current element is zero, skip it and continue scanning. Don't move slow.",
        "example": "nums=[0,1,0,3], slow=0, fast=0: nums[0]=0, just fast++"
      }
    ],
    "decisionTree": {
      "root": "For each fast from 0 to n-1, check if element is non-zero",
      "branches": [
        "If non-zero: swap with slow position, increment slow",
        "If zero: skip (just increment fast)",
        "After loop: all non-zeros are at [0..slow-1], zeros at [slow..n-1]"
      ]
    }
  },
  "walkthrough": {
    "example": "nums = [0,1,0,3,12]",
    "steps": [
      {
        "step": 1,
        "description": "Initialize: slow = 0, fast = 0",
        "state": "slow = 0, fast = 0, nums = [0,1,0,3,12]",
        "logic": "Start both pointers at beginning",
        "result": "Ready to partition"
      },
      {
        "step": 2,
        "description": "fast=0: nums[0]=0, skip, fast++",
        "state": "slow = 0, fast = 1",
        "logic": "Zero found, skip it",
        "result": "fast = 1"
      },
      {
        "step": 3,
        "description": "fast=1: nums[1]=1 != 0, swap nums[0] and nums[1], slow++",
        "state": "slow = 1, fast = 1, nums = [1,0,0,3,12]",
        "logic": "Non-zero found, swap to slow position",
        "result": "Non-zeros: [1]"
      },
      {
        "step": 4,
        "description": "fast=2: nums[2]=0, skip, fast++",
        "state": "slow = 1, fast = 3",
        "logic": "Zero found, skip",
        "result": "fast = 3"
      },
      {
        "step": 5,
        "description": "fast=3: nums[3]=3 != 0, swap nums[1] and nums[3], slow++",
        "state": "slow = 2, fast = 3, nums = [1,3,0,0,12]",
        "logic": "Another non-zero, swap to slow position",
        "result": "Non-zeros: [1,3]"
      },
      {
        "step": 6,
        "description": "fast=4: nums[4]=12 != 0, swap nums[2] and nums[4], slow++",
        "state": "slow = 3, fast = 4, nums = [1,3,12,0,0]",
        "logic": "Last non-zero, swap to slow position",
        "result": "Final: [1,3,12,0,0]"
      }
    ],
    "keyInsight": "The slow pointer marks where the next non-zero should go. The fast pointer finds non-zeros. By swapping when fast finds a non-zero, we move all non-zeros to the left while preserving their relative order. Zeros naturally end up on the right."
  },
  "commonMistakes": [
    {
      "mistake": "Not swapping, just copying (overwriting)",
      "symptom": "Loses zero values, may not correctly move zeros to end",
      "fix": "Use swap: temp = nums[slow], nums[slow] = nums[fast], nums[fast] = temp",
      "example": "If you do nums[slow] = nums[fast] without swapping, you lose the value at nums[slow]"
    },
    {
      "mistake": "Incrementing slow when element is zero",
      "symptom": "Wrong positions, zeros may end up in wrong places",
      "fix": "Only increment slow when you swap (when fast finds non-zero)",
      "example": "If slow increments on zeros, non-zeros will be placed at wrong positions"
    },
    {
      "mistake": "Not incrementing fast in all cases",
      "symptom": "Infinite loop if fast doesn't always increment",
      "fix": "Always increment fast after each iteration, regardless of swap",
      "example": "Fast must increment even when element is zero"
    },
    {
      "mistake": "Using two separate loops (move non-zeros, then add zeros)",
      "symptom": "Works but less efficient, requires knowing count of zeros",
      "fix": "Use single-pass two-pointer approach for O(n) time",
      "example": "Two passes is less efficient than one pass"
    },
    {
      "mistake": "Creating new array instead of modifying in-place",
      "symptom": "Uses O(n) extra space unnecessarily",
      "fix": "Use two-pointer swap technique to modify in-place with O(1) space",
      "example": "Creating result array uses extra space"
    }
  ],
  "interviewTalkTrack": {
    "script": [
      "This is a two-pointer partition problem.",
      "",
      "I'll use slow and fast pointers:",
      "- Initialize slow = 0, fast = 0",
      "- For each fast from 0 to n-1:",
      "  - If nums[fast] != 0:",
      "    - Swap nums[slow] and nums[fast]",
      "    - Increment slow",
      "  - Always increment fast",
      "",
      "Time complexity: O(n) - single pass through array",
      "Space complexity: O(1) - only using two pointers, modifying in-place",
      "",
      "Edge cases:",
      "- All zeros: no swaps, array unchanged",
      "- No zeros: swaps happen but array order preserved",
      "- The slow pointer tracks next position for non-zero"
    ]
  },
  "variants": {
    "easier": {
      "problem": "Move Zeroes (return new array)",
      "approachChange": "Can create new array instead of modifying in-place, simpler but uses O(n) space",
      "solution": "Create result array, copy non-zeros first, then fill with zeros"
    },
    "harder": {
      "problem": "Sort Colors (three-way partition)",
      "approachChange": "Partition into three groups (0s, 1s, 2s) instead of two. Need three pointers or two-pass approach.",
      "solution": "Use Dutch National Flag algorithm: three pointers (left, curr, right) to partition into three regions."
    }
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Initialize slow = 0, fast = 0"
    },
    {
      "id": "ps2",
      "text": "For fast from 0 to nums.length - 1:"
    },
    {
      "id": "ps3",
      "text": "  If nums[fast] != 0:"
    },
    {
      "id": "ps4",
      "text": "    Swap nums[slow] and nums[fast]"
    },
    {
      "id": "ps5",
      "text": "    Increment slow: slow = slow + 1"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "Hey! Ready to tackle another classic two-pointer problem? After mastering finding the middle of a linked list, you're perfectly set up to learn the \"Move Zeroes\" pattern - where we use slow and fast pointers moving at different speeds through an array.\n\nHere's what you'll walk away with:\nâ€¢ Master the slow-fast pointer technique for in-place array modifications\nâ€¢ Learn how to maintain relative order while rearranging elements efficiently\nâ€¢ Build confidence with O(1) space complexity solutions that modify arrays without extra storage\n\nThis pattern shows up everywhere in coding interviews and will give you a powerful tool for array manipulation problems. Let's dive in!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Before we dive into the problem, which programming language would you like to use?\n\nThis will help me make sure you have the right building blocks.",
      "choices": [
        {
          "label": "ðŸ’› JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "ðŸ Python",
          "next": "prereq-check-python"
        },
        {
          "label": "â˜• Java",
          "next": "prereq-check-java"
        },
        {
          "label": "âš¡ C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "ðŸ’™ TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in JavaScript, you'll need to know:\n- **Array-traversal** - Ability to iterate through arrays using indices\n- **Two-pointer-technique** - Understanding of maintaining multiple pointers/indices simultaneously\n- **In-place-modification** - Modifying array elements without using extra space\n- **Element-swapping** - Exchanging values between different array positions\n- **Conditional-logic** - Using if-else statements to make decisions during iteration\n\nDo you feel confident with these JavaScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-js"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Python, you'll need to know:\n- **Array-traversal** - Ability to iterate through arrays using indices\n- **Two-pointer-technique** - Understanding of maintaining multiple pointers/indices simultaneously\n- **In-place-modification** - Modifying array elements without using extra space\n- **Element-swapping** - Exchanging values between different array positions\n- **Conditional-logic** - Using if-else statements to make decisions during iteration\n\nDo you feel confident with these Python concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-python"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Java, you'll need to know:\n- **Array-traversal** - Ability to iterate through arrays using indices\n- **Two-pointer-technique** - Understanding of maintaining multiple pointers/indices simultaneously\n- **In-place-modification** - Modifying array elements without using extra space\n- **Element-swapping** - Exchanging values between different array positions\n- **Conditional-logic** - Using if-else statements to make decisions during iteration\n\nDo you feel confident with these Java concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-java"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in C++, you'll need to know:\n- **Array-traversal** - Ability to iterate through arrays using indices\n- **Two-pointer-technique** - Understanding of maintaining multiple pointers/indices simultaneously\n- **In-place-modification** - Modifying array elements without using extra space\n- **Element-swapping** - Exchanging values between different array positions\n- **Conditional-logic** - Using if-else statements to make decisions during iteration\n\nDo you feel confident with these C++ concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in TypeScript, you'll need to know:\n- **Array-traversal** - Ability to iterate through arrays using indices\n- **Two-pointer-technique** - Understanding of maintaining multiple pointers/indices simultaneously\n- **In-place-modification** - Modifying array elements without using extra space\n- **Element-swapping** - Exchanging values between different array positions\n- **Conditional-logic** - Using if-else statements to make decisions during iteration\n\nDo you feel confident with these TypeScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "Perfect! Now let's understand what the Move Zeroes problem asks for.\n\nImagine organizing books on a shelf where you want all the empty spaces at the end. You go through each position from left to right, and whenever you find a book, you slide it over to fill the next available spot from the left, naturally pushing all the empty spaces to the right side of the shelf.\n\n# Move Zeroes Problem\n\n## What you need to do:\n\nGiven an array of integers, **move all the zeros to the end** while keeping all the non-zero elements in their original relative order. You need to do this **in-place** (modify the original array, don't create a new one).\n\n## Example:\n\n**Input:** `[0, 1, 0, 3, 12]`  \n**Output:** `[1, 3, 12, 0, 0]`\n\n## Why this works:\n\nLet's trace through what happens:\n- We start with: `[0, 1, 0, 3, 12]`\n- The non-zero elements are `1, 3, 12` - and notice they appear in positions 1, 3, and 4\n- In our result `[1, 3, 12, 0, 0]`, these same numbers appear in positions 0, 1, and 2\n- **The key insight:** `1` still comes before `3`, and `3` still comes before `12` - their relative order is preserved!\n- All the zeros (there were 2 of them) got pushed to the end\n\nThink of it like this: imagine you're organizing books on a shelf, and you want to move all the empty spaces to the right end while keeping all the actual books in the same order they were before. That's exactly what we're doing here with numbers!",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "You need to move all zeros to the end while maintaining relative order of non-zeros. How would YOU approach this?",
      "choices": [
        {
          "label": "Create new array, copy non-zeros first, then add zeros at end",
          "next": "wrong-choice"
        },
        {
          "label": "Use slow pointer for next non-zero position, fast pointer to find non-zeros, swap when found",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-choice",
      "mentorSays": "This works but uses O(n) extra space. The problem asks to modify the array in-place, and this approach misses the opportunity to use the two-pointer technique that solves it optimally with O(1) space.",
      "action": "next",
      "next": "pattern-recognition"
    },
    {
      "stepId": "pattern-recognition",
      "mentorSays": "### Pattern Recognition: Two-Pointer Partition\n\n**This problem follows the \"partition array\" pattern:**\n- **Slow pointer** - Marks the boundary between processed non-zeros and unprocessed elements\n- **Fast pointer** - Scans through array to find non-zero elements\n- **Swap-based partitioning** - Move non-zeros to the left, zeros naturally end up on the right\n\n**Similar problems:**\n- Remove Element (similar two-pointer partition)\n- Sort Colors (three-way partition)\n- Remove Duplicates from Sorted Array (two-pointer with different condition)\n\n**Key insight:** The slow pointer maintains the invariant that all elements before it are non-zero, and all zeros are after it. When fast finds a non-zero, we swap it to the slow position.",
      "action": "next",
      "next": "invariant"
    },
    {
      "stepId": "invariant",
      "mentorSays": "### Invariant: Non-Zeros Before Slow, Zeros After\n\n**Invariant maintained throughout:**\n- **Elements before `slow`:** All are non-zero and in their original relative order\n- **Elements from `slow` to `fast`:** All are zeros (or unprocessed)\n- **Elements after `fast`:** Unprocessed (may contain zeros or non-zeros)\n\n**Why this works:**\n- Slow pointer marks the next position where a non-zero should go\n- When fast finds a non-zero, we swap it to the slow position\n- This ensures all non-zeros are moved to the left while preserving their order\n- Zeros naturally accumulate between slow and fast, then get pushed to the end\n\n**Invariant guarantee:** After processing index `i`, all non-zero elements from `nums[0..i]` are in positions `[0..slow)`, and all zeros from `nums[0..i]` are in positions `[slow..i+1)`.",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "The key insight is to use a **two-pointer approach** where the **slow pointer marks the next position** where a non-zero element should be placed, while the **fast pointer scans** through the array. When the fast pointer finds a non-zero element, we **swap it with the element at the slow position** and increment slow. This works because the slow pointer always points to either a zero or the first position after all processed non-zeros, ensuring that swapping maintains the relative order of non-zero elements while moving all zeros to the end.",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "Let's trace through `[0,1,0,3,12]`:\n\n- Step 1: Initialize two pointers: left=0 (for next non-zero position), right=0 (current element scanner)\n- Step 2: right=0, nums[0]=0 is zero, skip it, increment right to 1\n- Step 3: right=1, nums[1]=1 is non-zero, swap with nums[left=0], array becomes [1,0,0,3,12], increment both pointers\n- Step 4: right=2, nums[2]=0 is zero, skip it, increment right to 3\n- Step 5: right=3, nums[3]=3 is non-zero, swap with nums[left=1], array becomes [1,3,0,0,12], increment both pointers\n- Step 6: right=4, nums[4]=12 is non-zero, swap with nums[left=2], array becomes [1,3,12,0,0], increment both pointers\n- Step 7: right=5 reaches end of array, algorithm complete\n- Final answer: **[1,3,12,0,0]**",
      "action": "next",
      "next": "pseudocode-step",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "Here's our plan written as pseudocode:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now let's translate this into JavaScript, building it step by step.\n\nRemember: we'll add just 1-3 lines at a time!",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Initialize function signature with nums array parameter\n\n```javascript\nfunction moveZeroes(nums) {\n}\n```",
      "action": "next",
      "next": "code-02",
      "pseudocodeLineIds": [
        "ps1"
      ],
      "example": "function moveZeroes(nums) {\n}"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Initialize slow pointer to track next position for non-zero element\n\n```javascript\nfunction moveZeroes(nums) {\n    let slow = 0;\n}\n```",
      "action": "next",
      "next": "code-03",
      "pseudocodeLineIds": [
        "ps2"
      ],
      "example": "    let slow = 0;"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Start fast pointer loop to scan through all array elements\n\n```javascript\nfunction moveZeroes(nums) {\n    let slow = 0;\n    for (let fast = 0; fast < nums.length; fast++) {\n    }\n}\n```",
      "action": "next",
      "next": "code-04",
      "pseudocodeLineIds": [
        "ps3"
      ],
      "example": "    for (let fast = 0; fast < nums.length; fast++) {\n    }"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Check if current fast element is non-zero\n\n```javascript\nfunction moveZeroes(nums) {\n    let slow = 0;\n    for (let fast = 0; fast < nums.length; fast++) {\n        if (nums[fast] !== 0) {\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-05",
      "pseudocodeLineIds": [
        "ps4"
      ],
      "example": "        if (nums[fast] !== 0) {\n        }"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Swap non-zero element to slow position when found\n\n```javascript\nfunction moveZeroes(nums) {\n    let slow = 0;\n    for (let fast = 0; fast < nums.length; fast++) {\n        if (nums[fast] !== 0) {\n            [nums[slow], nums[fast]] = [nums[fast], nums[slow]];\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-06",
      "pseudocodeLineIds": [
        "ps5"
      ],
      "example": "            [nums[slow], nums[fast]] = [nums[fast], nums[slow]];"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Increment slow pointer to next available position after placing non-zero\n\n```javascript\nfunction moveZeroes(nums) {\n    let slow = 0;\n    for (let fast = 0; fast < nums.length; fast++) {\n        if (nums[fast] !== 0) {\n            [nums[slow], nums[fast]] = [nums[fast], nums[slow]];\n            slow++;\n        }\n    }\n}\n```",
      "action": "next",
      "next": "common-mistakes",
      "pseudocodeLineIds": [
        "ps6"
      ],
      "example": "            slow++;"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "Great work mastering the slow-fast pointer pattern with \"Move Zeroes\"! You've learned how to efficiently rearrange arrays in-place by using two pointers moving at different speeds - one to track the insertion position and another to scan through elements. Next, we'll tackle \"Squares of Sorted Array\" where you'll apply pointer techniques to handle sorted data transformations.\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}