{
  "id": "word-ladder",
  "title": "Word Ladder",
  "pattern": "BFS (shortest path)",
  "difficulty": "hard",
  "language": "javascript",
  "status": "AI-GENERATED-V2-DIRECT",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 45,
    "tier": "ADVANCED",
    "lessonOrderTag": "ADVANCED-45",
    "introduces": ["BFS-shortest-path", "word-graph", "transformation-rules"],
    "assumesAlreadyTaught": ["BFS-concept", "queue-concept", "hash-set"],
    "prerequisiteCheckRequired": true,
    "nextRecommended": ["longest-common-subsequence"]
  },
  "pseudocode": [
    {"id": "ps1", "text": "Add wordList to set for O(1) lookup"},
    {"id": "ps2", "text": "Create queue with [beginWord, 1] (word, steps)"},
    {"id": "ps3", "text": "While queue not empty, process current word"},
    {"id": "ps4", "text": "Try changing each character to a-z"},
    {"id": "ps5", "text": "If transformed word equals endWord, return steps + 1"},
    {"id": "ps6", "text": "If transformed word in wordList, add to queue"},
    {"id": "ps7", "text": "Remove word from set to avoid revisiting"},
    {"id": "ps8", "text": "If queue empty and endWord not reached, return 0"}
  ],
  "flow": [
    {"stepId": "objectives", "mentorSays": "Hey! Ready for **Word Ladder** - a challenging BFS shortest path problem!\n\nThis teaches you how to model word transformations as a graph and find the shortest transformation sequence using BFS.\n\nYou'll learn:\nâ€¢ Treating words as graph nodes\nâ€¢ BFS for finding shortest paths in unweighted graphs\nâ€¢ Efficient neighbor generation\n\nLet's dive in!", "action": "continue", "next": "language-selection"},
    {"stepId": "language-selection", "mentorSays": "Before we dive into the problem, which programming language would you like to use?\n\nThis will help me make sure you have the right building blocks.", "choices": [{"label": "ðŸ’› JavaScript", "next": "prereq-check-js"}, {"label": "ðŸ Python", "next": "prereq-check-python"}, {"label": "â˜• Java", "next": "prereq-check-java"}, {"label": "âš¡ C++", "next": "prereq-check-cpp"}, {"label": "ðŸ’™ TypeScript", "next": "prereq-check-ts"}]},
    {"stepId": "prereq-check-js", "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in JavaScript, you'll need to know:\n- **BFS concept** - Level-by-level graph traversal\n- **Queue concept** - FIFO data structure for BFS\n- **Hash set** - Fast lookup for valid words\n\nDo you feel confident with these JavaScript concepts?", "choices": [{"label": "Yes, I know all of them", "next": "problem-understanding"}, {"label": "No, please explain them", "next": "teach-prereqs-js"}, {"label": "I know some, not all", "next": "select-prereqs-js"}]},
    {"stepId": "teach-prereqs-js", "mentorSays": "I'll teach you the prerequisites you need. [Full interactive teaching will be added in Phase 2]\n\nFor now, let's continue with the lesson!", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-js", "mentorSays": "Which concepts would you like me to explain? [Individual selection will be added in Phase 2]\n\nFor now, let's continue!", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-python", "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Python, you'll need to know:\n- **BFS concept** - Level-by-level graph traversal\n- **Queue concept** - FIFO data structure for BFS\n- **Hash set** - Fast lookup for valid words\n\nDo you feel confident with these Python concepts?", "choices": [{"label": "Yes, I know all of them", "next": "problem-understanding"}, {"label": "No, please explain them", "next": "teach-prereqs-python"}, {"label": "I know some, not all", "next": "select-prereqs-python"}]},
    {"stepId": "teach-prereqs-python", "mentorSays": "I'll teach you the prerequisites you need. [Full interactive teaching will be added in Phase 2]\n\nFor now, let's continue with the lesson!", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-python", "mentorSays": "Which concepts would you like me to explain? [Individual selection will be added in Phase 2]\n\nFor now, let's continue!", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-java", "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Java, you'll need to know:\n- **BFS concept** - Level-by-level graph traversal\n- **Queue concept** - FIFO data structure for BFS\n- **Hash set** - Fast lookup for valid words\n\nDo you feel confident with these Java concepts?", "choices": [{"label": "Yes, I know all of them", "next": "problem-understanding"}, {"label": "No, please explain them", "next": "teach-prereqs-java"}, {"label": "I know some, not all", "next": "select-prereqs-java"}]},
    {"stepId": "teach-prereqs-java", "mentorSays": "I'll teach you the prerequisites you need. [Full interactive teaching will be added in Phase 2]\n\nFor now, let's continue with the lesson!", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-java", "mentorSays": "Which concepts would you like me to explain? [Individual selection will be added in Phase 2]\n\nFor now, let's continue!", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-cpp", "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in C++, you'll need to know:\n- **BFS concept** - Level-by-level graph traversal\n- **Queue concept** - FIFO data structure for BFS\n- **Hash set** - Fast lookup for valid words\n\nDo you feel confident with these C++ concepts?", "choices": [{"label": "Yes, I know all of them", "next": "problem-understanding"}, {"label": "No, please explain them", "next": "teach-prereqs-cpp"}, {"label": "I know some, not all", "next": "select-prereqs-cpp"}]},
    {"stepId": "teach-prereqs-cpp", "mentorSays": "I'll teach you the prerequisites you need. [Full interactive teaching will be added in Phase 2]\n\nFor now, let's continue with the lesson!", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-cpp", "mentorSays": "Which concepts would you like me to explain? [Individual selection will be added in Phase 2]\n\nFor now, let's continue!", "action": "continue", "next": "problem-understanding"},
    {"stepId": "prereq-check-ts", "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in TypeScript, you'll need to know:\n- **BFS concept** - Level-by-level graph traversal\n- **Queue concept** - FIFO data structure for BFS\n- **Hash set** - Fast lookup for valid words\n\nDo you feel confident with these TypeScript concepts?", "choices": [{"label": "Yes, I know all of them", "next": "problem-understanding"}, {"label": "No, please explain them", "next": "teach-prereqs-ts"}, {"label": "I know some, not all", "next": "select-prereqs-ts"}]},
    {"stepId": "teach-prereqs-ts", "mentorSays": "I'll teach you the prerequisites you need. [Full interactive teaching will be added in Phase 2]\n\nFor now, let's continue with the lesson!", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-ts", "mentorSays": "Which concepts would you like me to explain? [Individual selection will be added in Phase 2]\n\nFor now, let's continue!", "action": "continue", "next": "problem-understanding"},
    {
      "stepId": "problem-understanding",
      "mentorSays": "Perfect! Now let's understand what this problem asks for.\n\n**Imagine you're playing a word game** where you can change one letter at a time, and each intermediate word must be valid. What's the shortest sequence to transform one word into another?\n\nGiven:\n- `beginWord`: starting word\n- `endWord`: target word\n- `wordList`: valid intermediate words\n\nFind the **shortest transformation sequence** length. Return 0 if impossible.\n\nRules:\nâ€¢ Change only one letter per step\nâ€¢ Each intermediate word must be in wordList\nâ€¢ beginWord doesn't need to be in wordList\n\nExample:\n```\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n```\nOutput: `5` (hitâ†’hotâ†’dotâ†’dogâ†’cog)",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {"stepId": "thinking-challenge", "mentorSays": "What's the best way to find the shortest transformation sequence?\n\nThink about graph traversal...", "choices": [{"label": "Try all possible combinations recursively", "next": "wrong-choice"}, {"label": "Use BFS to explore level by level, finding shortest path", "next": "core-idea"}]},
    {"stepId": "wrong-choice", "mentorSays": "Pure recursion might find A path, but not necessarily the SHORTEST one!\n\nBFS explores level by level, guaranteeing the first time we reach the target is the shortest path in an unweighted graph.", "action": "next", "next": "core-idea"},
    {"stepId": "core-idea", "mentorSays": "The key insight is: **model this as an unweighted graph where BFS finds the shortest path**.\n\nEach word is a node. Two words are connected if they differ by exactly one letter.\n\nBFS Algorithm:\n1. Start with beginWord at distance 1\n2. For each word, try changing each letter to 'a'-'z'\n3. If the new word is in wordList, it's a valid neighbor\n4. Add valid neighbors to queue with distance + 1\n5. Remove visited words from set\n6. First time we reach endWord = shortest path!\n\nBFS guarantees shortest path in unweighted graphs!", "action": "next", "next": "walkthrough", "pseudocodeLineIds": ["ps1", "ps2", "ps3"]},
    {"stepId": "walkthrough", "mentorSays": "Let's trace BFS for \"hit\"â†’\"cog\":\n\n**Level 1:** Queue: [(hit, 1)]\n- Try hitâ†’hot (valid!) â†’ Queue: [(hot, 2)]\n- Remove \"hot\" from set\n\n**Level 2:** Process (hot, 2)\n- Try hotâ†’dot, hotâ†’lot (both valid!) â†’ Queue: [(dot, 3), (lot, 3)]\n\n**Level 3:** Process (dot, 3)\n- Try dotâ†’dog (valid!) â†’ Queue: [(lot, 3), (dog, 4)]\n\n**Level 4:** Process (dog, 4)  \n- Try dogâ†’cog âœ… **Found endWord!**\n- Return 5\n\nPath: hitâ†’hotâ†’dotâ†’dogâ†’cog (length 5)", "action": "next", "next": "pseudocode-step", "pseudocodeLineIds": ["ps1", "ps2", "ps3"]},
    {"stepId": "pseudocode-step", "mentorSays": "Here's our plan written as pseudocode:", "action": "next", "next": "coding-intro", "pseudocodeLineIds": ["ps1", "ps2", "ps3", "ps4", "ps5", "ps6", "ps7", "ps8"]},
    {"stepId": "coding-intro", "mentorSays": "Now let's translate this into JavaScript, building it step by step.\n\nRemember: we'll add just 1-3 lines at a time!", "action": "next", "next": "code-01"},
    {"stepId": "code-01", "mentorSays": "Check edge case and create word set.\n\n```javascript\nfunction ladderLength(beginWord, endWord, wordList) {\n  const wordSet = new Set(wordList);\n  if (!wordSet.has(endWord)) return 0;\n}\n```", "action": "next", "next": "code-02", "pseudocodeLineIds": ["ps1"], "example": "const wordSet = new Set(wordList);\nif (!wordSet.has(endWord)) return 0;"
    },
    {"stepId": "code-02", "mentorSays": "Initialize BFS queue.\n\n```javascript\nfunction ladderLength(beginWord, endWord, wordList) {\n  const wordSet = new Set(wordList);\n  if (!wordSet.has(endWord)) return 0;\n  \n  const queue = [[beginWord, 1]];\n}\n```", "action": "next", "next": "code-03", "pseudocodeLineIds": ["ps2"], "example": "const queue = [[beginWord, 1]];"
    },
    {"stepId": "code-03", "mentorSays": "BFS loop: process each word.\n\n```javascript\nfunction ladderLength(beginWord, endWord, wordList) {\n  const wordSet = new Set(wordList);\n  if (!wordSet.has(endWord)) return 0;\n  \n  const queue = [[beginWord, 1]];\n  \n  while (queue.length > 0) {\n    const [word, steps] = queue.shift();\n  }\n}\n```", "action": "next", "next": "code-04", "pseudocodeLineIds": ["ps3"], "example": "while (queue.length > 0) {\n  const [word, steps] = queue.shift();"
    },
    {"stepId": "code-04", "mentorSays": "Try changing each character position.\n\n```javascript\nfunction ladderLength(beginWord, endWord, wordList) {\n  const wordSet = new Set(wordList);\n  if (!wordSet.has(endWord)) return 0;\n  \n  const queue = [[beginWord, 1]];\n  \n  while (queue.length > 0) {\n    const [word, steps] = queue.shift();\n    \n    for (let i = 0; i < word.length; i++) {\n      for (let c = 97; c <= 122; c++) {\n        const newWord = word.slice(0, i) + String.fromCharCode(c) + word.slice(i + 1);\n      }\n    }\n  }\n}\n```", "action": "next", "next": "code-05", "pseudocodeLineIds": ["ps4"], "example": "for (let i = 0; i < word.length; i++) {\n  for (let c = 97; c <= 122; c++) {\n    const newWord = word.slice(0, i) + String.fromCharCode(c) + word.slice(i + 1);"
    },
    {"stepId": "code-05", "mentorSays": "Check if we reached endWord.\n\n```javascript\nfunction ladderLength(beginWord, endWord, wordList) {\n  const wordSet = new Set(wordList);\n  if (!wordSet.has(endWord)) return 0;\n  \n  const queue = [[beginWord, 1]];\n  \n  while (queue.length > 0) {\n    const [word, steps] = queue.shift();\n    \n    for (let i = 0; i < word.length; i++) {\n      for (let c = 97; c <= 122; c++) {\n        const newWord = word.slice(0, i) + String.fromCharCode(c) + word.slice(i + 1);\n        \n        if (newWord === endWord) return steps + 1;\n      }\n    }\n  }\n}\n```", "action": "next", "next": "code-06", "pseudocodeLineIds": ["ps5"], "example": "if (newWord === endWord) return steps + 1;"
    },
    {"stepId": "code-06", "mentorSays": "If valid word in set, add to queue and remove from set.\n\n```javascript\nfunction ladderLength(beginWord, endWord, wordList) {\n  const wordSet = new Set(wordList);\n  if (!wordSet.has(endWord)) return 0;\n  \n  const queue = [[beginWord, 1]];\n  \n  while (queue.length > 0) {\n    const [word, steps] = queue.shift();\n    \n    for (let i = 0; i < word.length; i++) {\n      for (let c = 97; c <= 122; c++) {\n        const newWord = word.slice(0, i) + String.fromCharCode(c) + word.slice(i + 1);\n        \n        if (newWord === endWord) return steps + 1;\n        \n        if (wordSet.has(newWord)) {\n          queue.push([newWord, steps + 1]);\n          wordSet.delete(newWord);\n        }\n      }\n    }\n  }\n  \n  return 0;\n}\n```", "action": "next", "next": "wrap-up", "pseudocodeLineIds": ["ps6", "ps7", "ps8"], "example": "if (wordSet.has(newWord)) {\n  queue.push([newWord, steps + 1]);\n  wordSet.delete(newWord);"
    },
    {"stepId": "wrap-up", "mentorSays": "Fantastic work! You've mastered **BFS for shortest paths** and **implicit graph construction**!\n\nKey concepts:\nâ€¢ BFS finds shortest path in unweighted graphs\nâ€¢ Nodes can be generated on-the-fly\nâ€¢ Removing visited nodes prevents cycles\n\nNext: **Longest Common Subsequence** - diving into 2D dynamic programming!\n\nYou're crushing it! ðŸ”¥", "action": "complete"}
  ]
}
