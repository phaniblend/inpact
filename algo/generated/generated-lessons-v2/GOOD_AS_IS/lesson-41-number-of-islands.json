{
  "id": "number-of-islands",
  "title": "Number of Islands",
  "pattern": "graph DFS/BFS (grid)",
  "difficulty": "medium",
  "language": "javascript",
  "status": "AI-GENERATED-V2-DIRECT",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 41,
    "tier": "ADVANCED",
    "lessonOrderTag": "ADVANCED-41",
    "introduces": [
      "graph-concept",
      "grid-as-graph",
      "DFS-on-grid",
      "visited-tracking",
      "connected-components"
    ],
    "assumesAlreadyTaught": [
      "arrays",
      "recursion-on-trees",
      "nested-loops"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "clone-graph"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Initialize island counter to 0"
    },
    {
      "id": "ps2",
      "text": "Loop through every cell in the grid"
    },
    {
      "id": "ps3",
      "text": "If cell is land ('1') and unvisited, found new island"
    },
    {
      "id": "ps4",
      "text": "Increment island counter"
    },
    {
      "id": "ps5",
      "text": "Use DFS to mark all connected land cells as visited"
    },
    {
      "id": "ps6",
      "text": "DFS explores up, down, left, right from current cell"
    },
    {
      "id": "ps7",
      "text": "Return total island count"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "Hey! Welcome to **Number of Islands** - your first graph problem!\n\nThis problem introduces you to **graphs represented as grids** and teaches you how to find **connected components** using depth-first search.\n\nYou'll learn:\nâ€¢ How a 2D grid can represent a graph\nâ€¢ Finding connected components with DFS\nâ€¢ Tracking visited cells to avoid infinite loops\n\nLet's dive in!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Before we dive into the problem, which programming language would you like to use?\n\nThis will help me make sure you have the right building blocks.",
      "choices": [
        {"label": "ðŸ’› JavaScript", "next": "prereq-check-js"},
        {"label": "ðŸ Python", "next": "prereq-check-python"},
        {"label": "â˜• Java", "next": "prereq-check-java"},
        {"label": "âš¡ C++", "next": "prereq-check-cpp"},
        {"label": "ðŸ’™ TypeScript", "next": "prereq-check-ts"}
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in JavaScript, you'll need to know:\n- **Arrays** - Working with 2D arrays (grids)\n- **Recursion on trees** - Similar pattern to tree DFS\n- **Nested loops** - Iterating through rows and columns\n\nDo you feel confident with these JavaScript concepts?",
      "choices": [
        {"label": "Yes, I know all of them", "next": "problem-understanding"},
        {"label": "No, please explain them", "next": "teach-prereqs-js"},
        {"label": "I know some, not all", "next": "select-prereqs-js"}
      ]
    },
    {"stepId": "teach-prereqs-js", "mentorSays": "I'll teach you the prerequisites you need. [Full interactive teaching will be added in Phase 2]\n\nFor now, let's continue with the lesson!", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-js", "mentorSays": "Which concepts would you like me to explain? [Individual selection will be added in Phase 2]\n\nFor now, let's continue!", "action": "continue", "next": "problem-understanding"},
    {
      "stepId": "prereq-check-python",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Python, you'll need to know:\n- **Arrays** - Working with 2D lists (grids)\n- **Recursion on trees** - Similar pattern to tree DFS\n- **Nested loops** - Iterating through rows and columns\n\nDo you feel confident with these Python concepts?",
      "choices": [
        {"label": "Yes, I know all of them", "next": "problem-understanding"},
        {"label": "No, please explain them", "next": "teach-prereqs-python"},
        {"label": "I know some, not all", "next": "select-prereqs-python"}
      ]
    },
    {"stepId": "teach-prereqs-python", "mentorSays": "I'll teach you the prerequisites you need. [Full interactive teaching will be added in Phase 2]\n\nFor now, let's continue with the lesson!", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-python", "mentorSays": "Which concepts would you like me to explain? [Individual selection will be added in Phase 2]\n\nFor now, let's continue!", "action": "continue", "next": "problem-understanding"},
    {
      "stepId": "prereq-check-java",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Java, you'll need to know:\n- **Arrays** - Working with 2D arrays (grids)\n- **Recursion on trees** - Similar pattern to tree DFS\n- **Nested loops** - Iterating through rows and columns\n\nDo you feel confident with these Java concepts?",
      "choices": [
        {"label": "Yes, I know all of them", "next": "problem-understanding"},
        {"label": "No, please explain them", "next": "teach-prereqs-java"},
        {"label": "I know some, not all", "next": "select-prereqs-java"}
      ]
    },
    {"stepId": "teach-prereqs-java", "mentorSays": "I'll teach you the prerequisites you need. [Full interactive teaching will be added in Phase 2]\n\nFor now, let's continue with the lesson!", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-java", "mentorSays": "Which concepts would you like me to explain? [Individual selection will be added in Phase 2]\n\nFor now, let's continue!", "action": "continue", "next": "problem-understanding"},
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in C++, you'll need to know:\n- **Arrays** - Working with 2D vectors (grids)\n- **Recursion on trees** - Similar pattern to tree DFS\n- **Nested loops** - Iterating through rows and columns\n\nDo you feel confident with these C++ concepts?",
      "choices": [
        {"label": "Yes, I know all of them", "next": "problem-understanding"},
        {"label": "No, please explain them", "next": "teach-prereqs-cpp"},
        {"label": "I know some, not all", "next": "select-prereqs-cpp"}
      ]
    },
    {"stepId": "teach-prereqs-cpp", "mentorSays": "I'll teach you the prerequisites you need. [Full interactive teaching will be added in Phase 2]\n\nFor now, let's continue with the lesson!", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-cpp", "mentorSays": "Which concepts would you like me to explain? [Individual selection will be added in Phase 2]\n\nFor now, let's continue!", "action": "continue", "next": "problem-understanding"},
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in TypeScript, you'll need to know:\n- **Arrays** - Working with 2D arrays (grids)\n- **Recursion on trees** - Similar pattern to tree DFS\n- **Nested loops** - Iterating through rows and columns\n\nDo you feel confident with these TypeScript concepts?",
      "choices": [
        {"label": "Yes, I know all of them", "next": "problem-understanding"},
        {"label": "No, please explain them", "next": "teach-prereqs-ts"},
        {"label": "I know some, not all", "next": "select-prereqs-ts"}
      ]
    },
    {"stepId": "teach-prereqs-ts", "mentorSays": "I'll teach you the prerequisites you need. [Full interactive teaching will be added in Phase 2]\n\nFor now, let's continue with the lesson!", "action": "continue", "next": "problem-understanding"},
    {"stepId": "select-prereqs-ts", "mentorSays": "Which concepts would you like me to explain? [Individual selection will be added in Phase 2]\n\nFor now, let's continue!", "action": "continue", "next": "problem-understanding"},
    {
      "stepId": "problem-understanding",
      "mentorSays": "Perfect! Now let's understand what this problem asks for.\n\n**Imagine you're looking at a map from above** - land is shown in green ('1') and water in blue ('0'). An island is any group of connected land cells (you can walk up, down, left, or right to connected land). How many separate islands are on the map?\n\nGiven a 2D grid where:\n- '1' represents land\n- '0' represents water\n\nCount the number of islands. An island is surrounded by water and formed by connecting adjacent lands horizontally or vertically.\n\nExample:\n```\ngrid = [\n  [\"1\",\"1\",\"0\"],\n  [\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\"]\n]\n```\nOutput: **2 islands**\n\nWhy? The top-left cluster of three 1's forms one island, and the bottom-right 1 forms another island.",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "How can we count separate islands efficiently?\n\nThink about how you'd mark regions on a map...",
      "choices": [
        {"label": "Check each cell, if it's land increment counter", "next": "wrong-choice"},
        {"label": "When we find unvisited land, use DFS to mark the entire island, then count", "next": "core-idea"}
      ]
    },
    {
      "stepId": "wrong-choice",
      "mentorSays": "Just counting '1's won't work - that counts all land cells, not separate islands!\n\nThe key is recognizing that each **connected component** is one island. When we find new land, we need to **mark all connected land** as part of the same island before moving on.",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "The key insight is: **each island is a connected component**. We use DFS to mark all cells of one island before counting the next one.\n\nAlgorithm:\n1. Loop through every cell in the grid\n2. When we find an unvisited land cell ('1'), we've found a **new island**\n3. Increment island counter\n4. Use **DFS to mark all connected land** as visited (change '1' to '0' or use visited array)\n5. DFS explores all 4 directions: up, down, left, right\n6. Continue until all cells are checked\n\nThe DFS ensures we don't count the same island multiple times!",
      "action": "next",
      "next": "walkthrough",
      "pseudocodeLineIds": ["ps1", "ps2", "ps3"]
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "Let's trace through the example grid:\n\n```\n[\"1\",\"1\",\"0\"]\n[\"1\",\"0\",\"0\"]\n[\"0\",\"0\",\"1\"]\n```\n\n- **Start at (0,0):** Found '1' â†’ **Island #1!** DFS marks (0,0), (0,1), (1,0) as visited\n- **Continue scanning:** (0,1) already visited, (0,2) is water\n- **Row 1:** (1,0) already visited, (1,1) is water, (1,2) is water  \n- **Row 2:** (2,0) is water, (2,1) is water\n- **Cell (2,2):** Found '1' â†’ **Island #2!** DFS marks (2,2) as visited\n- **Done!**\n\nFinal count: **2 islands**",
      "action": "next",
      "next": "pseudocode-step",
      "pseudocodeLineIds": ["ps1", "ps2", "ps3"]
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "Here's our plan written as pseudocode:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": ["ps1", "ps2", "ps3", "ps4", "ps5", "ps6", "ps7"]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now let's translate this into JavaScript, building it step by step.\n\nRemember: we'll add just 1-3 lines at a time!",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Start with the main function and edge case.\n\n```javascript\nfunction numIslands(grid) {\n  if (!grid || grid.length === 0) return 0;\n  let count = 0;\n}\n```",
      "action": "next",
      "next": "code-02",
      "pseudocodeLineIds": ["ps1"],
      "example": "if (!grid || grid.length === 0) return 0;\nlet count = 0;"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Define our DFS helper function.\n\n```javascript\nfunction numIslands(grid) {\n  if (!grid || grid.length === 0) return 0;\n  let count = 0;\n  \n  const dfs = (row, col) => {\n  };\n}\n```",
      "action": "next",
      "next": "code-03",
      "pseudocodeLineIds": ["ps5"],
      "example": "const dfs = (row, col) => {"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Add boundary checks and base cases for DFS.\n\n```javascript\nfunction numIslands(grid) {\n  if (!grid || grid.length === 0) return 0;\n  let count = 0;\n  \n  const dfs = (row, col) => {\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) return;\n    if (grid[row][col] === '0') return;\n  };\n}\n```",
      "action": "next",
      "next": "code-04",
      "pseudocodeLineIds": ["ps5"],
      "example": "if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) return;\nif (grid[row][col] === '0') return;"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Mark current cell as visited by changing it to '0'.\n\n```javascript\nfunction numIslands(grid) {\n  if (!grid || grid.length === 0) return 0;\n  let count = 0;\n  \n  const dfs = (row, col) => {\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) return;\n    if (grid[row][col] === '0') return;\n    \n    grid[row][col] = '0';\n  };\n}\n```",
      "action": "next",
      "next": "code-05",
      "pseudocodeLineIds": ["ps5"],
      "example": "grid[row][col] = '0';"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Explore all 4 directions: up, down, left, right.\n\n```javascript\nfunction numIslands(grid) {\n  if (!grid || grid.length === 0) return 0;\n  let count = 0;\n  \n  const dfs = (row, col) => {\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) return;\n    if (grid[row][col] === '0') return;\n    \n    grid[row][col] = '0';\n    dfs(row - 1, col);\n    dfs(row + 1, col);\n    dfs(row, col - 1);\n    dfs(row, col + 1);\n  };\n}\n```",
      "action": "next",
      "next": "code-06",
      "pseudocodeLineIds": ["ps6"],
      "example": "dfs(row - 1, col);\ndfs(row + 1, col);\ndfs(row, col - 1);\ndfs(row, col + 1);"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Loop through every cell in the grid.\n\n```javascript\nfunction numIslands(grid) {\n  if (!grid || grid.length === 0) return 0;\n  let count = 0;\n  \n  const dfs = (row, col) => {\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) return;\n    if (grid[row][col] === '0') return;\n    \n    grid[row][col] = '0';\n    dfs(row - 1, col);\n    dfs(row + 1, col);\n    dfs(row, col - 1);\n    dfs(row, col + 1);\n  };\n  \n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n    }\n  }\n}\n```",
      "action": "next",
      "next": "code-07",
      "pseudocodeLineIds": ["ps2"],
      "example": "for (let row = 0; row < grid.length; row++) {\n  for (let col = 0; col < grid[0].length; col++) {"
    },
    {
      "stepId": "code-07",
      "mentorSays": "When we find unvisited land, increment count and run DFS.\n\n```javascript\nfunction numIslands(grid) {\n  if (!grid || grid.length === 0) return 0;\n  let count = 0;\n  \n  const dfs = (row, col) => {\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) return;\n    if (grid[row][col] === '0') return;\n    \n    grid[row][col] = '0';\n    dfs(row - 1, col);\n    dfs(row + 1, col);\n    dfs(row, col - 1);\n    dfs(row, col + 1);\n  };\n  \n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      if (grid[row][col] === '1') {\n        count++;\n        dfs(row, col);\n      }\n    }\n  }\n}\n```",
      "action": "next",
      "next": "code-08",
      "pseudocodeLineIds": ["ps3", "ps4", "ps5"],
      "example": "if (grid[row][col] === '1') {\n  count++;\n  dfs(row, col);"
    },
    {
      "stepId": "code-08",
      "mentorSays": "Return the total island count!\n\n```javascript\nfunction numIslands(grid) {\n  if (!grid || grid.length === 0) return 0;\n  let count = 0;\n  \n  const dfs = (row, col) => {\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) return;\n    if (grid[row][col] === '0') return;\n    \n    grid[row][col] = '0';\n    dfs(row - 1, col);\n    dfs(row + 1, col);\n    dfs(row, col - 1);\n    dfs(row, col + 1);\n  };\n  \n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      if (grid[row][col] === '1') {\n        count++;\n        dfs(row, col);\n      }\n    }\n  }\n  \n  return count;\n}\n```",
      "action": "next",
      "next": "wrap-up",
      "pseudocodeLineIds": ["ps7"],
      "example": "return count;"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "Excellent work! You've mastered **graph traversal on grids** and **finding connected components**!\n\nKey takeaways:\nâ€¢ Grids are just graphs in disguise\nâ€¢ DFS helps us explore all connected cells\nâ€¢ Marking visited cells prevents counting the same island twice\n\nNext up: **Clone Graph** - where we'll work with explicit graph nodes and adjacency lists!\n\nYou're doing great! ðŸŽ‰",
      "action": "complete"
    }
  ]
}
