{
  "id": "middle-of-linked-list",
  "title": "Middle of the Linked List",
  "pattern": "fast-slow pointers",
  "difficulty": "easy",
  "language": "javascript",
  "status": "AI-GENERATED-V2-BATCH",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 21,
    "tier": "FOUNDATION",
    "lessonOrderTag": "FOUNDATION-21",
    "introduces": [
      "middle-node-return",
      "even-odd-handling"
    ],
    "assumesAlreadyTaught": [
      "linked-list-concept",
      "fast-slow-pointers"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "move-zeroes"
    ]
  },
  "problemStatement": {
    "description": "Find the middle node of a linked list. If there are two middle nodes (even length), return the second middle node.",
    "inputs": [
      "head: head node of a linked list (length 1 to 100)"
    ],
    "outputs": [
      "Node: the middle node of the linked list"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[3,4,5]",
        "explanation": "Middle node is 3. Fast-slow pointers: slow ends at node 3 when fast reaches end."
      },
      {
        "input": "head = [1,2,3,4,5,6]",
        "output": "[4,5,6]",
        "explanation": "Two middle nodes (3 and 4), return second one (4). Slow ends at node 4."
      },
      {
        "input": "head = [1]",
        "output": "[1]",
        "explanation": "Single node is the middle. Return head."
      }
    ],
    "constraints": [
      "Number of nodes in list is in range [1, 100]",
      "1 <= Node.val <= 100"
    ],
    "realWorldUse": [
      "Finding midpoint in linked lists",
      "Dividing lists for processing",
      "Linked list manipulation",
      "Foundation for other linked list algorithms"
    ]
  },
  "patternRecognition": {
    "whyThisPattern": "Fast-slow pointers efficiently find the middle in one pass. Fast moves 2 steps while slow moves 1 step, so when fast reaches the end, slow is at the middle.",
    "signalsToRecognize": [
      "SIGNAL 1: Problem asks to find middle of linked list â†’ think fast-slow pointers",
      "SIGNAL 2: Need O(1) space solution â†’ use two pointers instead of storing all nodes",
      "SIGNAL 3: Need to find middle without knowing length â†’ fast-slow pattern"
    ],
    "patternRules": [
      "If problem involves finding middle of linked list â†’ use fast-slow pointers",
      "When you see 'middle', 'center', or 'midpoint' in linked list context â†’ consider two pointers",
      "If need O(1) space â†’ avoid counting nodes first, use pointer chasing"
    ],
    "whyNotOtherApproaches": {
      "greedy": "Greedy doesn't apply - we need to find the middle, not make choices.",
      "bruteForce": "Counting nodes first then traversing to middle works but requires two passes. Fast-slow is one pass.",
      "alternative": "Storing all nodes in array works but uses O(n) space. Fast-slow uses O(1) space."
    }
  },
  "coreInvariant": {
    "statement": "When fast pointer reaches the end (null or last node), slow pointer is at the middle node. For even length, slow ends at the second middle node.",
    "explanation": "This invariant holds because fast moves twice as fast as slow. When fast has moved n steps (reaching end), slow has moved n/2 steps (reaching middle).",
    "whyItMatters": "This invariant guarantees correctness: we find the middle in one pass without knowing the list length beforehand, using only O(1) space."
  },
  "stateDefinition": {
    "states": [
      {
        "name": "slow",
        "meaning": "Slow pointer moving 1 step per iteration",
        "indexing": "Starts at head, moves: slow = slow.next"
      },
      {
        "name": "fast",
        "meaning": "Fast pointer moving 2 steps per iteration",
        "indexing": "Starts at head, moves: fast = fast.next.next"
      },
      {
        "name": "head",
        "meaning": "Starting node of linked list",
        "indexing": "Head of the list"
      }
    ],
    "baseCases": [
      "If head is null: return null",
      "If head.next is null: return head (single node)"
    ]
  },
  "transitionLogic": {
    "rules": [
      {
        "condition": "While fast != null and fast.next != null:",
        "transition": "slow = slow.next, fast = fast.next.next",
        "explanation": "Move slow one step, fast two steps. Fast moves twice as fast.",
        "example": "If slow at node 1, fast at node 1, after one iteration: slow at node 2, fast at node 3"
      },
      {
        "condition": "When loop exits (fast == null or fast.next == null):",
        "transition": "Return slow (points to middle node)",
        "explanation": "Fast reached end, slow is at middle. For even length, slow is at second middle.",
        "example": "For list [1,2,3,4,5], slow ends at node 3 (middle)"
      }
    ],
    "decisionTree": {
      "root": "Use fast-slow pointers to find middle",
      "branches": [
        "Initialize both at head",
        "Move slow 1 step, fast 2 steps per iteration",
        "When fast reaches end, slow is at middle",
        "Return slow"
      ]
    }
  },
  "walkthrough": {
    "example": "head = [1,2,3,4,5]",
    "steps": [
      {
        "step": 1,
        "description": "Initialize: slow = node 1, fast = node 1",
        "state": "slow = 1, fast = 1",
        "logic": "Start both pointers at head",
        "result": "Ready to find middle"
      },
      {
        "step": 2,
        "description": "Iteration 1: slow = 2, fast = 3",
        "state": "slow = node 2, fast = node 3",
        "logic": "Slow moves 1 step, fast moves 2 steps",
        "result": "slow != null, continue"
      },
      {
        "step": 3,
        "description": "Iteration 2: slow = 3, fast = 5",
        "state": "slow = node 3, fast = node 5",
        "logic": "Fast moves 2 steps (3â†’4â†’5), slow moves 1 step (2â†’3)",
        "result": "slow != null, continue"
      },
      {
        "step": 4,
        "description": "Check: fast.next = null, loop exits",
        "state": "slow = node 3, fast = node 5, fast.next = null",
        "logic": "Fast reached end, slow is at middle",
        "result": "Return slow = node 3"
      }
    ],
    "keyInsight": "Fast pointer moves twice as fast as slow, so when fast reaches the end (after n steps), slow has moved n/2 steps and is at the middle. This finds the middle in one pass without knowing the length."
  },
  "commonMistakes": [
    {
      "mistake": "Not checking fast.next before accessing fast.next.next",
      "symptom": "Null pointer exception when fast.next is null",
      "fix": "Check both fast != null and fast.next != null in loop condition",
      "example": "If fast is at last node, fast.next is null, accessing fast.next.next causes error"
    },
    {
      "mistake": "Returning wrong node for even-length lists",
      "symptom": "May return first middle instead of second middle",
      "fix": "Current algorithm correctly returns second middle. If need first middle, adjust loop condition.",
      "example": "For [1,2,3,4], algorithm returns node 3 (second middle), which is correct per problem statement"
    },
    {
      "mistake": "Not handling single node case",
      "symptom": "May not work correctly for list with one node",
      "fix": "Check if head.next is null, return head immediately",
      "example": "Single node [1] should return node 1"
    },
    {
      "mistake": "Using counter and two passes",
      "symptom": "Works but requires two passes, less efficient",
      "fix": "Use fast-slow pointers for one-pass solution",
      "example": "Counting nodes first, then traversing to middle requires two passes"
    },
    {
      "mistake": "Storing all nodes in array",
      "symptom": "Uses O(n) space unnecessarily",
      "fix": "Use fast-slow pointers for O(1) space solution",
      "example": "Array approach works but uses extra space"
    }
  ],
  "interviewTalkTrack": {
    "script": [
      "This is a fast-slow pointer problem to find the middle node.",
      "",
      "I'll use two pointers:",
      "- Initialize slow = head, fast = head",
      "- While fast != null and fast.next != null:",
      "  - slow = slow.next (move 1 step)",
      "  - fast = fast.next.next (move 2 steps)",
      "- Return slow (middle node)",
      "",
      "Time complexity: O(n) - single pass through list",
      "Space complexity: O(1) - only using two pointers",
      "",
      "Edge cases:",
      "- Single node: return head",
      "- Even length: returns second middle node (as specified)",
      "- The fast pointer moves twice as fast, so when it reaches end, slow is at middle"
    ]
  },
  "variants": {
    "easier": {
      "problem": "Middle of Linked List (return first middle for even length)",
      "approachChange": "For even length, return first middle instead of second",
      "solution": "Adjust loop condition or use different pointer logic to stop one step earlier"
    },
    "harder": {
      "problem": "Delete Middle Node of Linked List",
      "approachChange": "Find middle, then delete it. Need to track previous node.",
      "solution": "Use fast-slow to find middle, but also track prev pointer. After finding middle, set prev.next = slow.next to delete."
    }
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "If head is null or head.next is null: return head"
    },
    {
      "id": "ps2",
      "text": "Initialize slow = head, fast = head"
    },
    {
      "id": "ps3",
      "text": "While fast != null and fast.next != null:"
    },
    {
      "id": "ps4",
      "text": "  slow = slow.next"
    },
    {
      "id": "ps5",
      "text": "  fast = fast.next.next"
    },
    {
      "id": "ps6",
      "text": "Return slow (middle node)"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "Hey! Ready to tackle another cool linked list challenge? \n\nToday we're exploring how to find the middle of a linked list using the elegant **fast and slow pointers** pattern (also called the \"tortoise and hare\" technique). This builds perfectly on what you learned with palindrome detection!\n\nHere's what you'll master:\n\nâœ… **Two-pointer traversal** - Moving pointers at different speeds to solve problems efficiently  \nâœ… **Edge case handling** - Dealing with even vs odd length lists and empty inputs  \nâœ… **Optimal space usage** - Finding the middle in one pass without counting nodes first\n\nThis pattern is a game-changer you'll use in tons of linked list problems. Let's dive in!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Before we dive into the problem, which programming language would you like to use?\n\nThis will help me make sure you have the right building blocks.",
      "choices": [
        {
          "label": "ðŸ’› JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "ðŸ Python",
          "next": "prereq-check-python"
        },
        {
          "label": "â˜• Java",
          "next": "prereq-check-java"
        },
        {
          "label": "âš¡ C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "ðŸ’™ TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in JavaScript, you'll need to know:\n- **Linked-list-concept** - Understanding of linked list data structure with nodes containing data and next pointers\n- **Fast-slow-pointers** - Two-pointer technique where one pointer moves twice as fast as the other\n- **Pointer-traversal** - Ability to iterate through linked list using pointer references\n- **Linked-list-length** - Understanding how to determine or work with linked list size\n\nDo you feel confident with these JavaScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-js"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Python, you'll need to know:\n- **Linked-list-concept** - Understanding of linked list data structure with nodes containing data and next pointers\n- **Fast-slow-pointers** - Two-pointer technique where one pointer moves twice as fast as the other\n- **Pointer-traversal** - Ability to iterate through linked list using pointer references\n- **Linked-list-length** - Understanding how to determine or work with linked list size\n\nDo you feel confident with these Python concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-python"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Java, you'll need to know:\n- **Linked-list-concept** - Understanding of linked list data structure with nodes containing data and next pointers\n- **Fast-slow-pointers** - Two-pointer technique where one pointer moves twice as fast as the other\n- **Pointer-traversal** - Ability to iterate through linked list using pointer references\n- **Linked-list-length** - Understanding how to determine or work with linked list size\n\nDo you feel confident with these Java concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-java"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in C++, you'll need to know:\n- **Linked-list-concept** - Understanding of linked list data structure with nodes containing data and next pointers\n- **Fast-slow-pointers** - Two-pointer technique where one pointer moves twice as fast as the other\n- **Pointer-traversal** - Ability to iterate through linked list using pointer references\n- **Linked-list-length** - Understanding how to determine or work with linked list size\n\nDo you feel confident with these C++ concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in TypeScript, you'll need to know:\n- **Linked-list-concept** - Understanding of linked list data structure with nodes containing data and next pointers\n- **Fast-slow-pointers** - Two-pointer technique where one pointer moves twice as fast as the other\n- **Pointer-traversal** - Ability to iterate through linked list using pointer references\n- **Linked-list-length** - Understanding how to determine or work with linked list size\n\nDo you feel confident with these TypeScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "Perfect! Now let's understand what the Middle of the Linked List problem asks for.\n\nThink of finding the middle car in a moving train where you can only see one car at a time and move forward - you send two friends walking, one taking single steps and another taking double steps. When the faster friend reaches the end of the train, the slower friend will be standing exactly at the middle car.\n\n# Middle of the Linked List\n\nHey! So here's what we're trying to solve:\n\n**The Problem:**\nGiven a linked list, find and return the middle node. If there are two middle nodes (when the list has an even number of elements), return the second one.\n\n**Example:**\nLet's say we have: `1 â†’ 2 â†’ 3 â†’ 4 â†’ 5`\n\nThe answer would be the node containing `3`.\n\n**Why this works:**\n- We have 5 nodes total\n- The middle position is at index 2 (if we start counting from 0)\n- That's our node with value 3\n\nThink of it like this: if you lined up 5 people and asked \"who's in the middle?\", it'd be the 3rd person. Same idea here!\n\nFor an even-length example like `1 â†’ 2 â†’ 3 â†’ 4`, we'd return the node with `3` (the second of the two middle candidates), not `2`.\n\nThe tricky part? You typically can't just count the nodes ahead of time in a linked list - you have to traverse it to know its length. So the real challenge is finding an efficient way to identify the middle without making multiple passes through the list.",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "You need to find the middle node of a linked list in one pass. How would YOU approach this?",
      "choices": [
        {
          "label": "Count total nodes first, then traverse to position n/2",
          "next": "wrong-choice"
        },
        {
          "label": "Use two pointers: fast moves 2 steps, slow moves 1 step per iteration",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-choice",
      "mentorSays": "This requires two passes through the list - first to count all nodes, then to reach the middle position. While it works, it's inefficient and doesn't leverage the elegant mathematical relationship that can solve this in a single pass.",
      "action": "next",
      "next": "pattern-recognition"
    },
    {
      "stepId": "pattern-recognition",
      "mentorSays": "### Pattern Recognition: Fast-Slow Pointers (Tortoise and Hare)\n\n**This problem follows the \"fast-slow pointer\" pattern:**\n- **Fast pointer** moves 2 steps per iteration\n- **Slow pointer** moves 1 step per iteration\n- **When fast reaches end, slow is at middle**\n\n**Similar problems:**\n- Linked List Cycle (detect cycles using fast-slow)\n- Palindrome Linked List (find middle, then reverse)\n- Remove Nth Node From End (fast pointer creates gap)\n\n**Key insight:** If fast pointer moves twice as fast as slow pointer, when fast completes the full distance, slow has covered exactly half - the middle!",
      "action": "next",
      "next": "invariant"
    },
    {
      "stepId": "invariant",
      "mentorSays": "### Invariant: Slow Pointer is at Middle When Fast Reaches End\n\n**Invariant maintained throughout:**\n- **Distance relationship:** `fast` has traveled exactly twice the distance of `slow`\n- **Position relationship:** When `fast` is at position `2i`, `slow` is at position `i`\n- **Termination:** When `fast` reaches the end (null or last node), `slow` is at the middle\n\n**Why this works:**\n- Fast pointer moves 2 steps while slow moves 1 step\n- After `i` iterations: fast at position `2i`, slow at position `i`\n- When fast reaches end (position `n`), slow is at position `n/2` (the middle)\n- For even-length lists, slow ends at the second middle node\n\n**Invariant guarantee:** At any point during traversal, if fast has traveled distance `d`, slow has traveled distance `d/2`. When fast completes the full list (distance `n`), slow is at distance `n/2` (the middle).",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "The key insight is to use the **two-pointer technique** with a **fast pointer** moving 2 steps and a **slow pointer** moving 1 step per iteration. When the fast pointer reaches the end of the list, the slow pointer will be exactly at the **middle node** because it has traveled half the distance. This works because the fast pointer covers twice as much ground as the slow pointer, so by the time fast completes the full traversal, slow is positioned at the halfway point.",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "Let's trace through `1â†’2â†’3â†’4â†’5`:\n\n- Step 1: Initialize slow pointer at node 1, fast pointer at node 1\n- Step 2: Move slow to node 2, fast to node 3 (fast moves 2 steps)\n- Step 3: Move slow to node 3, fast to node 5 (fast moves 2 steps)\n- Step 4: Fast pointer reaches end, so slow pointer is at middle\n- Final answer: **3**",
      "action": "next",
      "next": "pseudocode-step",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "Here's our plan written as pseudocode:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now let's translate this into JavaScript, building it step by step.\n\nRemember: we'll add just 1-3 lines at a time!",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Initialize function signature and handle edge case\n\n```javascript\nfunction findMiddle(head) {\n    if (!head) return null;\n}\n```",
      "action": "next",
      "next": "code-02",
      "pseudocodeLineIds": [
        "ps1"
      ],
      "example": "function findMiddle(head) {\n    if (!head) return null;"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Initialize slow pointer at head\n\n```javascript\nfunction findMiddle(head) {\n    if (!head) return null;\n    let slow = head;\n}\n```",
      "action": "next",
      "next": "code-03",
      "pseudocodeLineIds": [
        "ps2"
      ],
      "example": "    let slow = head;"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Initialize fast pointer at head\n\n```javascript\nfunction findMiddle(head) {\n    if (!head) return null;\n    let slow = head;\n    let fast = head;\n}\n```",
      "action": "next",
      "next": "code-04",
      "pseudocodeLineIds": [
        "ps2"
      ],
      "example": "    let fast = head;"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Start while loop with condition for valid fast pointer\n\n```javascript\nfunction findMiddle(head) {\n    if (!head) return null;\n    let slow = head;\n    let fast = head;\n    \n    while (fast && fast.next) {\n    }\n}\n```",
      "action": "next",
      "next": "code-05",
      "pseudocodeLineIds": [
        "ps3"
      ],
      "example": "    while (fast && fast.next) {\n    }"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Move slow pointer one step forward\n\n```javascript\nfunction findMiddle(head) {\n    if (!head) return null;\n    let slow = head;\n    let fast = head;\n    \n    while (fast && fast.next) {\n        slow = slow.next;\n    }\n}\n```",
      "action": "next",
      "next": "code-06",
      "pseudocodeLineIds": [
        "ps4"
      ],
      "example": "        slow = slow.next;"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Move fast pointer two steps forward\n\n```javascript\nfunction findMiddle(head) {\n    if (!head) return null;\n    let slow = head;\n    let fast = head;\n    \n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n}\n```",
      "action": "next",
      "next": "code-07",
      "pseudocodeLineIds": [
        "ps4"
      ],
      "example": "        fast = fast.next.next;"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Return the middle node when fast reaches end\n\n```javascript\nfunction findMiddle(head) {\n    if (!head) return null;\n    let slow = head;\n    let fast = head;\n    \n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    \n    return slow;\n}\n```",
      "action": "next",
      "next": "common-mistakes",
      "pseudocodeLineIds": [
        "ps5"
      ],
      "example": "    return slow;"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "Great work mastering the fast-slow pointer technique! You've learned a powerful pattern that elegantly solves linked list problems by having two pointers move at different speeds. Next, we'll tackle move-zeroes where you'll apply array manipulation skills to rearrange elements efficiently.\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}