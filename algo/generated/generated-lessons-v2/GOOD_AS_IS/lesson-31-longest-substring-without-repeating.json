{
  "id": "longest-substring-without-repeating",
  "title": "Longest Substring Without Repeating Characters",
  "pattern": "sliding window (variable size)",
  "difficulty": "medium",
  "language": "javascript",
  "status": "AI-GENERATED-V2-BATCH",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 31,
    "tier": "INTERMEDIATE",
    "lessonOrderTag": "INTERMEDIATE-31",
    "introduces": [
      "sliding-window-concept",
      "variable-window",
      "character-set",
      "window-expansion-contraction"
    ],
    "assumesAlreadyTaught": [
      "strings",
      "hash-set",
      "loops",
      "Math.max"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "minimum-window-substring"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Initialize left pointer at 0, max length as 0, and empty set to track characters in current window"
    },
    {
      "id": "ps2",
      "text": "Loop through string with right pointer from 0 to end of string"
    },
    {
      "id": "ps3",
      "text": "While current character at right pointer exists in the character set, remove character at left pointer from set and increment left pointer"
    },
    {
      "id": "ps4",
      "text": "Add current character at right pointer to the character set"
    },
    {
      "id": "ps5",
      "text": "Update max length to be maximum of current max length and current window size (right - left + 1)"
    },
    {
      "id": "ps6",
      "text": "Continue to next iteration with right pointer"
    },
    {
      "id": "ps7",
      "text": "Return the maximum length found"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "Hey! Great job completing the counting-bits lesson! Now we're moving into an exciting new territory with sliding window problems, specifically the variable-size sliding window pattern. This technique is like having a flexible window that expands and contracts as you move through data to find optimal solutions - perfect for our \"Longest Substring Without Repeating Characters\" challenge!\n\nIn this lesson, you'll master three key skills:\n‚Ä¢ **Variable sliding window technique** - Learn how to dynamically adjust window boundaries based on conditions\n‚Ä¢ **Hash set optimization** - Use efficient data structures to track characters and detect duplicates in constant time  \n‚Ä¢ **Two-pointer coordination** - Skillfully manage left and right pointers to maintain valid window states\n\nThis pattern is incredibly powerful and you'll find yourself using it in countless string and array problems. You're building some serious problem-solving muscles here!\n\nLet's dive in!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Before we dive into the problem, which programming language would you like to use?\n\nThis will help me make sure you have the right building blocks.",
      "choices": [
        {
          "label": "üíõ JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "üêç Python",
          "next": "prereq-check-python"
        },
        {
          "label": "‚òï Java",
          "next": "prereq-check-java"
        },
        {
          "label": "‚ö° C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "üíô TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in JavaScript, you'll need to know:\n- **Sliding window** - Two-pointer technique to maintain a dynamic window of valid elements\n- **Hash set operations** - Using hash set for O(1) lookup, insertion, and deletion operations\n- **String indexing** - Accessing individual characters in a string using indices\n- **Two pointers** - Managing left and right pointers to expand and contract the current substring\n\nDo you feel confident with these JavaScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-js"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Python, you'll need to know:\n- **Sliding window** - Two-pointer technique to maintain a dynamic window of valid elements\n- **Hash set operations** - Using hash set for O(1) lookup, insertion, and deletion operations\n- **String indexing** - Accessing individual characters in a string using indices\n- **Two pointers** - Managing left and right pointers to expand and contract the current substring\n\nDo you feel confident with these Python concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-python"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Java, you'll need to know:\n- **Sliding window** - Two-pointer technique to maintain a dynamic window of valid elements\n- **Hash set operations** - Using hash set for O(1) lookup, insertion, and deletion operations\n- **String indexing** - Accessing individual characters in a string using indices\n- **Two pointers** - Managing left and right pointers to expand and contract the current substring\n\nDo you feel confident with these Java concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-java"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in C++, you'll need to know:\n- **Sliding window** - Two-pointer technique to maintain a dynamic window of valid elements\n- **Hash set operations** - Using hash set for O(1) lookup, insertion, and deletion operations\n- **String indexing** - Accessing individual characters in a string using indices\n- **Two pointers** - Managing left and right pointers to expand and contract the current substring\n\nDo you feel confident with these C++ concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in TypeScript, you'll need to know:\n- **Sliding window** - Two-pointer technique to maintain a dynamic window of valid elements\n- **Hash set operations** - Using hash set for O(1) lookup, insertion, and deletion operations\n- **String indexing** - Accessing individual characters in a string using indices\n- **Two pointers** - Managing left and right pointers to expand and contract the current substring\n\nDo you feel confident with these TypeScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "Perfect! Now let's understand what the Longest Substring Without Repeating Characters problem asks for.\n\nImagine you're packing a suitcase and want to fit the longest possible sequence of different clothing items without any duplicates. You start adding items one by one (shirt, pants, socks...), but as soon as you encounter a duplicate item, you remove everything up to and including the first occurrence of that duplicate, then continue packing. The sliding window technique mimics this process - expanding your suitcase contents when items are unique, and shrinking from the left when you hit a duplicate.\n\n# Longest Substring Without Repeating Characters\n\n## What are we trying to solve?\n\nYou're given a string, and you need to find the **length** of the longest substring that contains all unique characters - meaning no character appears more than once in that substring.\n\nThink of it like this: you're sliding a window across the string, trying to make it as wide as possible while keeping all the characters inside unique.\n\n## Let's walk through an example\n\nTake the string `s = \"abcabcbb\"`\n\nLet's see what happens as we examine different substrings:\n\n- `\"a\"` ‚Üí length 1 ‚úÖ (all unique)\n- `\"ab\"` ‚Üí length 2 ‚úÖ (all unique) \n- `\"abc\"` ‚Üí length 3 ‚úÖ (all unique)\n- `\"abca\"` ‚Üí length 4 ‚ùå ('a' repeats)\n\nSo we can't extend past \"abc\" without hitting a duplicate. Now we shift our window:\n\n- `\"bca\"` ‚Üí length 3 ‚úÖ (all unique)\n- `\"bcab\"` ‚Üí length 4 ‚ùå ('b' repeats)\n\nWe continue this process through the entire string. The longest valid substring we can find is **\"abc\"** (or \"bca\" or \"cab\" - they're all length 3), so our answer is **3**.\n\n## Why does this work?\n\nThe key insight is that we're looking for the **longest contiguous sequence** of characters where each character appears exactly once. The moment we encounter a duplicate, we know that particular substring is invalid, so we need to adjust our \"window\" and keep searching.\n\nThe answer isn't about finding unique characters in the entire string - it's about finding the longest stretch where no character repeats within that stretch.",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Given the string 'abcabcbb', you need to find the longest substring without repeating characters. You're at index 3 (second 'a') and your current window is 'abca'. What should you do next?",
      "choices": [
        {
          "label": "Start a completely new window from the current position, making the window just 'a'",
          "next": "wrong-choice"
        },
        {
          "label": "Contract the window from the left until the duplicate 'a' is removed, then continue expanding",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-choice",
      "mentorSays": "This approach restarts the search from scratch whenever a duplicate is found, losing valuable information. While it would eventually find a valid answer, it's inefficient because it doesn't utilize the fact that part of the current window (like 'bc') might still be valid for the next longest substring. This leads to O(n¬≤) time complexity instead of the optimal O(n).",
      "action": "next",
      "next": "pattern-recognition"
    },
    {
      "stepId": "pattern-recognition",
      "mentorSays": "### Pattern Recognition: Sliding Window (Variable Size)\n\n**This is a classic sliding window problem because:**\n\n1. **We need to find a contiguous subarray/substring** - The substring must be consecutive characters\n2. **The window size changes dynamically** - We expand when characters are unique, contract when duplicates appear\n3. **We're optimizing for maximum length** - We want the longest valid window\n\n**Signals that tell us to use sliding window:**\n- Problem asks for substring/subarray (contiguous sequence)\n- We need to track elements within a range\n- Window validity condition can be checked efficiently\n- We want to optimize (max/min) over all valid windows\n\n**2-3 bullet rules:**\n- If you see \"longest substring/subarray\" with a condition ‚Üí think sliding window\n- If the window validity can be checked in O(1) ‚Üí sliding window is likely optimal\n- If you need to expand/contract based on elements ‚Üí variable-size sliding window",
      "action": "next",
      "next": "invariant-definition"
    },
    {
      "stepId": "invariant-definition",
      "mentorSays": "### Core Invariant (CRITICAL)\n\n**Invariant:** At any point during iteration, the substring `s[left...right]` (inclusive) contains only unique characters.\n\n**Why this matters:**\n- The window `[left, right]` always represents a valid substring with no duplicates\n- When we expand right, we ensure the new character doesn't violate uniqueness\n- When we contract left, we remove characters until uniqueness is restored\n- This invariant guarantees we're always working with a valid candidate\n\n**Concrete example:**\n```\ns = \"abcabcbb\"\n\nAt right=2: left=0, window=\"abc\" ‚Üí all unique ‚úì (invariant holds)\nAt right=3: char='a' is duplicate ‚Üí move left to 1, window=\"bca\" ‚Üí all unique ‚úì (invariant restored)\n```\n\n**The invariant guides our algorithm:** We maintain a valid window at all times, only expanding when safe, and contracting when necessary.",
      "action": "next",
      "next": "state-definition"
    },
    {
      "stepId": "state-definition",
      "mentorSays": "### State Definition\n\n**State variables:**\n\n1. **`left`** - Left boundary of current window (inclusive)\n   - Range: [0, n-1]\n   - Represents: Start of current valid substring\n\n2. **`right`** - Right boundary of current window (inclusive)\n   - Range: [0, n-1]\n   - Represents: End of current valid substring\n\n3. **`seen`** - Hash map/set tracking characters in current window\n   - Key: character\n   - Value: last index where character appeared (or just presence for set)\n   - Purpose: O(1) duplicate detection\n\n4. **`maxLen`** - Maximum length found so far\n   - Range: [0, n]\n   - Represents: Answer we're optimizing for\n\n**Window validity condition:**\n- `seen` contains exactly `right - left + 1` unique characters\n- No character appears twice in `s[left...right]`\n\n**State transition:**\n- Expand: `right++`, add `s[right]` to `seen`\n- Contract: Remove `s[left]` from `seen`, `left++`",
      "action": "next",
      "next": "why-alternative-fails"
    },
    {
      "stepId": "why-alternative-fails",
      "mentorSays": "### Why Alternative Approaches Fail\n\n**Alternative 1: Brute Force - Check all substrings**\n```javascript\nfor (let i = 0; i < n; i++) {\n  for (let j = i; j < n; j++) {\n    // Check if s[i...j] has unique chars\n  }\n}\n```\n**Why it fails:**\n- Time complexity: O(n¬≥) - O(n¬≤) substrings √ó O(n) to check uniqueness\n- Redundant work: Checks overlapping substrings repeatedly\n- Doesn't leverage the fact that if `s[i...j]` is invalid, so is `s[i...j+1]`\n\n**Alternative 2: Restart window on duplicate**\n```javascript\n// When duplicate found, set left = right\n```\n**Why it fails:**\n- Loses valid characters: If `s[left...right-1]` is valid, we shouldn't discard it\n- Example: `\"abcabcbb\"` - when we see second 'a', we can keep 'bc' from previous window\n- Results in O(n¬≤) time instead of O(n)\n\n**Why sliding window works:**\n- Each character visited at most twice (once by right, once by left)\n- No redundant checks - we build on previous valid windows\n- Optimal O(n) time complexity",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "The key insight is to use a **sliding window** approach where you expand the right boundary while characters are unique, and contract from the left when a duplicate is found. This works because it maintains the **longest valid substring** at each step without redundantly checking all possible substrings. For example, in \"abcabcbb\", when you encounter the second 'a', you slide the left pointer past the first 'a' to start a new valid window, avoiding the need to restart from scratch. This **two-pointer technique** ensures O(n) time complexity by visiting each character at most twice.",
      "action": "next",
      "next": "walkthrough",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "Let's trace through `s=\"abcabcbb\"`:\n\n- Step 1: Initialize left=0, right=0, seen={}, maxLen=0\n- Step 2: right=0, char='a' not in seen, add 'a':0, maxLen=1, substring=\"a\"\n- Step 3: right=1, char='b' not in seen, add 'b':1, maxLen=2, substring=\"ab\"\n- Step 4: right=2, char='c' not in seen, add 'c':2, maxLen=3, substring=\"abc\"\n- Step 5: right=3, char='a' seen at index 0, move left=1, update 'a':3, maxLen=3\n- Step 6: right=4, char='b' seen at index 1, move left=2, update 'b':4, maxLen=3\n- Step 7: right=5, char='c' seen at index 2, move left=3, update 'c':5, maxLen=3\n- Step 8: right=6, char='b' seen at index 4, move left=5, update 'b':6, maxLen=3\n- Step 9: right=7, char='b' seen at index 6, move left=7, update 'b':7, maxLen=3\n- Final: **3 (substring \"abc\")**",
      "action": "next",
      "next": "pseudocode-step",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "Here's our plan written as pseudocode:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now let's translate this into JavaScript, building it step by step.\n\nRemember: we'll add just 1-3 lines at a time!",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Initialize function with parameters and set up tracking variables\n\n```javascript\nfunction lengthOfLongestSubstring(s) {\n    let maxLength = 0;\n    let left = 0;\n}\n```",
      "action": "next",
      "next": "code-02",
      "pseudocodeLineIds": [
        "ps1"
      ],
      "example": "function lengthOfLongestSubstring(s) {\n    let maxLength = 0;\n    let left = 0;\n}"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Create a Set to track unique characters in current window\n\n```javascript\nfunction lengthOfLongestSubstring(s) {\n    let maxLength = 0;\n    let left = 0;\n    let charSet = new Set();\n}\n```",
      "action": "next",
      "next": "code-03",
      "pseudocodeLineIds": [
        "ps2"
      ],
      "example": "    let charSet = new Set();"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Start main loop to expand window with right pointer\n\n```javascript\nfunction lengthOfLongestSubstring(s) {\n    let maxLength = 0;\n    let left = 0;\n    let charSet = new Set();\n    \n    for (let right = 0; right < s.length; right++) {\n    }\n}\n```",
      "action": "next",
      "next": "code-04",
      "pseudocodeLineIds": [
        "ps3"
      ],
      "example": "    for (let right = 0; right < s.length; right++) {\n    }"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Contract window from left while current character exists in set\n\n```javascript\nfunction lengthOfLongestSubstring(s) {\n    let maxLength = 0;\n    let left = 0;\n    let charSet = new Set();\n    \n    for (let right = 0; right < s.length; right++) {\n        while (charSet.has(s[right])) {\n            charSet.delete(s[left]);\n            left++;\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-05",
      "pseudocodeLineIds": [
        "ps4"
      ],
      "example": "        while (charSet.has(s[right])) {\n            charSet.delete(s[left]);\n            left++;\n        }"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Add current character to set to expand the unique window\n\n```javascript\nfunction lengthOfLongestSubstring(s) {\n    let maxLength = 0;\n    let left = 0;\n    let charSet = new Set();\n    \n    for (let right = 0; right < s.length; right++) {\n        while (charSet.has(s[right])) {\n            charSet.delete(s[left]);\n            left++;\n        }\n        charSet.add(s[right]);\n    }\n}\n```",
      "action": "next",
      "next": "code-06",
      "pseudocodeLineIds": [
        "ps5"
      ],
      "example": "        charSet.add(s[right]);"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Update maximum length with current window size\n\n```javascript\nfunction lengthOfLongestSubstring(s) {\n    let maxLength = 0;\n    let left = 0;\n    let charSet = new Set();\n    \n    for (let right = 0; right < s.length; right++) {\n        while (charSet.has(s[right])) {\n            charSet.delete(s[left]);\n            left++;\n        }\n        charSet.add(s[right]);\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n}\n```",
      "action": "next",
      "next": "code-07",
      "pseudocodeLineIds": [
        "ps6"
      ],
      "example": "        maxLength = Math.max(maxLength, right - left + 1);"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Return the maximum substring length found\n\n```javascript\nfunction lengthOfLongestSubstring(s) {\n    let maxLength = 0;\n    let left = 0;\n    let charSet = new Set();\n    \n    for (let right = 0; right < s.length; right++) {\n        while (charSet.has(s[right])) {\n            charSet.delete(s[left]);\n            left++;\n        }\n        charSet.add(s[right]);\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    \n    return maxLength;\n}\n```",
      "action": "next",
      "next": "common-mistakes",
      "pseudocodeLineIds": [
        "ps7"
      ],
      "example": "    return maxLength;"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "Great work mastering the sliding window technique with variable window sizes! You've successfully learned how to expand and contract your window dynamically to find optimal substrings, which is a crucial skill for many string problems. Next, we'll tackle the minimum window substring problem, where you'll apply these same principles to find the smallest window containing all required characters.\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}