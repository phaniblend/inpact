{
  "id": "remove-duplicates-sorted",
  "title": "Remove Duplicates from Sorted Array",
  "pattern": "slow-fast pointers (same direction)",
  "difficulty": "easy",
  "language": "javascript",
  "status": "AI-GENERATED-V2-BATCH",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 5,
    "tier": "FOUNDATION",
    "lessonOrderTag": "FOUNDATION-5",
    "introduces": [
      "slow-fast-pointers",
      "write-pointer",
      "read-pointer",
      "in-place-modification"
    ],
    "assumesAlreadyTaught": [
      "arrays",
      "loops",
      "comparison-operators"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "valid-palindrome"
    ]
  },
  "problemStatement": {
    "description": "Remove duplicates from a sorted array in-place, keeping only unique elements. Return the number of unique elements.",
    "inputs": [
      "nums: sorted array of integers in non-decreasing order (length 0 to 3*10^4)"
    ],
    "outputs": [
      "Integer k representing the number of unique elements. First k elements of nums should contain the unique elements in sorted order."
    ],
    "examples": [
      {
        "input": "nums = [1,1,2]",
        "output": "2, nums = [1,2,_]",
        "explanation": "Remove duplicate 1. Slow pointer at 0 (value 1), fast finds 2 at index 2. Copy 2 to index 1. Result: [1,2] with k=2."
      },
      {
        "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
        "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
        "explanation": "Keep first occurrence of each unique value. Slow tracks write position, fast scans. When fast finds new unique value, copy to slow position."
      },
      {
        "input": "nums = [1]",
        "output": "1, nums = [1]",
        "explanation": "Single element is already unique, return 1."
      }
    ],
    "constraints": [
      "0 <= nums.length <= 3 * 10^4",
      "-100 <= nums[i] <= 100",
      "nums is sorted in non-decreasing order"
    ],
    "realWorldUse": [
      "Database deduplication (removing duplicate records)",
      "Data cleaning in analytics pipelines",
      "Maintaining unique sorted collections",
      "Memory optimization in sorted data structures"
    ]
  },
  "patternRecognition": {
    "whyThisPattern": "The array is sorted, so duplicates are adjacent. The slow-fast pointer pattern allows us to filter duplicates in-place by using slow as a write pointer and fast as a read pointer, only copying when we find a new unique value.",
    "signalsToRecognize": [
      "SIGNAL 1: Sorted array with duplicates â†’ think slow-fast pointers",
      "SIGNAL 2: Need in-place modification without extra space â†’ two-pointer filtering",
      "SIGNAL 3: Remove/filter elements while maintaining order â†’ slow-fast pattern"
    ],
    "patternRules": [
      "If problem involves sorted array and removing/filtering â†’ use slow-fast pointers",
      "When you see 'remove duplicates', 'remove element', or 'filter' in sorted context â†’ consider slow-fast pattern",
      "If O(1) space constraint exists â†’ avoid creating new arrays, use in-place pointers"
    ],
    "whyNotOtherApproaches": {
      "greedy": "Greedy doesn't apply - there's no local optimal choice. We need to systematically process all elements.",
      "bruteForce": "Creating a new array and copying unique elements works but uses O(n) extra space. Slow-fast pointers achieve O(1) space.",
      "alternative": "Using Set to track seen elements works but uses O(n) space and doesn't leverage sorted property. Slow-fast pointers are optimal."
    }
  },
  "coreInvariant": {
    "statement": "All elements at indices [0..slow] are unique and sorted, with nums[slow] being the last unique element written.",
    "explanation": "This invariant holds because we only increment slow and write when nums[fast] != nums[slow], meaning we found a new unique value. Since the array is sorted, comparing with the last written element (nums[slow]) is sufficient to detect new unique values.",
    "whyItMatters": "This invariant guarantees correctness: after processing, nums[0..slow] contains all unique elements in sorted order. The value slow+1 is the count of unique elements."
  },
  "stateDefinition": {
    "states": [
      {
        "name": "slow",
        "meaning": "Write pointer tracking the next position for a unique element (0-indexed)",
        "indexing": "0-indexed, starts at 0 (first element is always unique)"
      },
      {
        "name": "fast",
        "meaning": "Read pointer scanning through the array to find next unique element (0-indexed)",
        "indexing": "0-indexed, starts at 1, iterates through array"
      },
      {
        "name": "nums",
        "meaning": "Sorted array being modified in-place",
        "indexing": "0-indexed array"
      }
    ],
    "baseCases": [
      "If nums.length == 0: return 0",
      "If nums.length == 1: return 1 (single element is unique)",
      "First element nums[0] is always unique, so slow starts at 0"
    ]
  },
  "transitionLogic": {
    "rules": [
      {
        "condition": "if nums[fast] != nums[slow]",
        "transition": "slow++, then nums[slow] = nums[fast]",
        "explanation": "We found a new unique element. Increment slow to next write position, then copy the unique value.",
        "example": "nums=[1,1,2], slow=0, fast=2: nums[2]=2 != nums[0]=1, so slow=1, nums[1]=2"
      },
      {
        "condition": "if nums[fast] == nums[slow]",
        "transition": "fast++ (skip duplicate, don't write)",
        "explanation": "Current element is duplicate of last written unique element. Skip it and continue scanning.",
        "example": "nums=[1,1,2], slow=0, fast=1: nums[1]=1 == nums[0]=1, so just fast++"
      }
    ],
    "decisionTree": {
      "root": "For each fast from 1 to n-1, compare nums[fast] with nums[slow]",
      "branches": [
        "If different: increment slow, copy nums[fast] to nums[slow]",
        "If same: skip (duplicate), continue to next fast",
        "After loop: return slow + 1 (count of unique elements)"
      ]
    }
  },
  "walkthrough": {
    "example": "nums = [0,0,1,1,1,2,2,3,3,4]",
    "steps": [
      {
        "step": 1,
        "description": "Initialize: slow = 0, fast = 1",
        "state": "slow = 0 (value 0), fast = 1, nums = [0,0,1,1,1,2,2,3,3,4]",
        "logic": "First element is always unique, slow tracks write position",
        "result": "Ready to scan for unique elements"
      },
      {
        "step": 2,
        "description": "fast=1: nums[1]=0 == nums[0]=0 (duplicate), skip",
        "state": "slow = 0, fast = 1, duplicate found",
        "logic": "Duplicate detected, don't write, just move fast forward",
        "result": "fast = 2"
      },
      {
        "step": 3,
        "description": "fast=2: nums[2]=1 != nums[0]=0 (new unique), slow++, copy",
        "state": "slow = 1, nums[1] = 1, fast = 2, nums = [0,1,1,1,1,2,2,3,3,4]",
        "logic": "New unique value found, write it at slow position",
        "result": "Unique elements: [0,1]"
      },
      {
        "step": 4,
        "description": "fast=3,4: nums[3]=1, nums[4]=1 == nums[1]=1 (duplicates), skip both",
        "state": "slow = 1, fast = 5",
        "logic": "Duplicates of last written element, skip",
        "result": "fast = 5"
      },
      {
        "step": 5,
        "description": "fast=5: nums[5]=2 != nums[1]=1 (new unique), slow++, copy",
        "state": "slow = 2, nums[2] = 2, fast = 5, nums = [0,1,2,1,1,2,2,3,3,4]",
        "logic": "New unique value found, write it",
        "result": "Unique elements: [0,1,2]"
      },
      {
        "step": 6,
        "description": "fast=6: nums[6]=2 == nums[2]=2 (duplicate), skip. fast=7: nums[7]=3 != nums[2]=2 (new unique), slow++, copy",
        "state": "slow = 3, nums[3] = 3, fast = 7, nums = [0,1,2,3,1,2,2,3,3,4]",
        "logic": "Continue scanning, write new unique values",
        "result": "Unique elements: [0,1,2,3]"
      },
      {
        "step": 7,
        "description": "fast=8: nums[8]=3 == nums[3]=3 (duplicate), skip. fast=9: nums[9]=4 != nums[3]=3 (new unique), slow++, copy",
        "state": "slow = 4, nums[4] = 4, fast = 9, nums = [0,1,2,3,4,2,2,3,3,4]",
        "logic": "Last unique element written",
        "result": "Unique elements: [0,1,2,3,4], return 5"
      }
    ],
    "keyInsight": "The slow pointer marks where to write the next unique element. The fast pointer scans ahead. Since the array is sorted, duplicates are adjacent, so comparing nums[fast] with nums[slow] (the last written unique element) is sufficient to detect new unique values."
  },
  "commonMistakes": [
    {
      "mistake": "Starting slow at 1 instead of 0",
      "symptom": "First element might be lost or incorrectly handled",
      "fix": "Always start slow = 0 because the first element is always unique and should be kept",
      "example": "For nums=[1,2,3], if slow starts at 1, you'd skip the first element 1"
    },
    {
      "mistake": "Comparing nums[fast] with nums[fast-1] instead of nums[slow]",
      "symptom": "May not correctly detect duplicates, especially when there are gaps",
      "fix": "Compare with nums[slow] (last written unique element), not with previous fast element",
      "example": "nums=[1,1,2,2]: comparing with fast-1 works here, but nums[slow] is more general and correct"
    },
    {
      "mistake": "Forgetting to increment slow before writing",
      "symptom": "Overwrites the last unique element instead of writing to next position",
      "fix": "Always do: slow++, then nums[slow] = nums[fast]",
      "example": "If you do nums[slow] = nums[fast] then slow++, you overwrite the last unique element"
    },
    {
      "mistake": "Returning slow instead of slow + 1",
      "symptom": "Off-by-one error - returns wrong count of unique elements",
      "fix": "Return slow + 1 because slow is 0-indexed (if slow=2, there are 3 unique elements at indices 0,1,2)",
      "example": "For [1,2,3], slow ends at 2, but there are 3 unique elements, so return 3 (slow+1)"
    },
    {
      "mistake": "Not handling empty array edge case",
      "symptom": "Error or wrong return value when array is empty",
      "fix": "Check if nums.length === 0 and return 0 immediately",
      "example": "Empty array should return 0, not proceed with the loop"
    }
  ],
  "interviewTalkTrack": {
    "script": [
      "This is a slow-fast pointer problem on a sorted array.",
      "",
      "I'll use two pointers:",
      "- slow pointer at 0 (first element is always unique)",
      "- fast pointer starting at 1, scanning through the array",
      "",
      "Algorithm:",
      "- For each fast from 1 to n-1:",
      "  - If nums[fast] != nums[slow]: new unique element found",
      "    - Increment slow",
      "    - Copy nums[fast] to nums[slow]",
      "  - Always increment fast",
      "- Return slow + 1 (count of unique elements)",
      "",
      "Time complexity: O(n) - single pass through array",
      "Space complexity: O(1) - only using two pointers, modifying in-place",
      "",
      "Edge cases:",
      "- Empty array: return 0",
      "- Single element: return 1",
      "- All duplicates: return 1"
    ]
  },
  "variants": {
    "easier": {
      "problem": "Remove Duplicates (unsorted array)",
      "approachChange": "Can't use slow-fast pointers efficiently. Need Set to track seen elements, or sort first then apply same technique.",
      "solution": "Use Set to track seen elements, or sort array first then use slow-fast pointer technique"
    },
    "harder": {
      "problem": "Remove Duplicates Allowing At Most 2 Occurrences",
      "approachChange": "Need to track count of occurrences, not just uniqueness. Compare nums[fast] with nums[slow-1] to allow at most 2 of same value.",
      "solution": "Modify condition: write if nums[fast] != nums[slow-1] (allows 2 occurrences) or if count < 2. More complex state tracking needed."
    }
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "If nums.length == 0, return 0"
    },
    {
      "id": "ps2",
      "text": "Initialize slow = 0 (first element is always unique)"
    },
    {
      "id": "ps3",
      "text": "For fast from 1 to nums.length - 1:"
    },
    {
      "id": "ps4",
      "text": "  If nums[fast] != nums[slow]:"
    },
    {
      "id": "ps5",
      "text": "    Increment slow: slow = slow + 1"
    },
    {
      "id": "ps6",
      "text": "    Copy element: nums[slow] = nums[fast]"
    },
    {
      "id": "ps7",
      "text": "Return slow + 1 (count of unique elements)"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "Hey! \n\nGreat work on mastering array rotation! Now let's tackle another essential array technique: removing duplicates from sorted arrays using the **two-pointer pattern with slow and fast pointers moving in the same direction**.\n\nThis pattern is incredibly powerful - you'll use one pointer to explore ahead (fast) while another tracks your current position for valid elements (slow). It's like having a scout that runs ahead to find good spots while you follow behind to set up camp!\n\nHere are 3 key skills you'll master:\nâ€¢ **In-place array modification** - Transform arrays without extra space\nâ€¢ **Two-pointer coordination** - Sync slow/fast pointers for optimal efficiency  \nâ€¢ **Duplicate detection logic** - Identify and handle duplicate elements systematically\n\nYou're building such strong problem-solving muscles! This technique will serve you well in countless coding challenges and real-world scenarios.\n\nLet's dive in!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Before we dive into the problem, which programming language would you like to use?\n\nThis will help me make sure you have the right building blocks.",
      "choices": [
        {
          "label": "ðŸ’› JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "ðŸ Python",
          "next": "prereq-check-python"
        },
        {
          "label": "â˜• Java",
          "next": "prereq-check-java"
        },
        {
          "label": "âš¡ C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "ðŸ’™ TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in JavaScript, you'll need to know:\n- **Two pointers** - Technique using two index variables to traverse array efficiently\n- **In place modification** - Modifying array elements without using extra space\n- **Array indexing** - Accessing and updating array elements by position\n- **Time complexity** - Understanding Big O notation for algorithm efficiency analysis\n\nDo you feel confident with these JavaScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-js"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Python, you'll need to know:\n- **Two pointers** - Technique using two index variables to traverse array efficiently\n- **In place modification** - Modifying array elements without using extra space\n- **Array indexing** - Accessing and updating array elements by position\n- **Time complexity** - Understanding Big O notation for algorithm efficiency analysis\n\nDo you feel confident with these Python concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-python"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Java, you'll need to know:\n- **Two pointers** - Technique using two index variables to traverse array efficiently\n- **In place modification** - Modifying array elements without using extra space\n- **Array indexing** - Accessing and updating array elements by position\n- **Time complexity** - Understanding Big O notation for algorithm efficiency analysis\n\nDo you feel confident with these Java concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-java"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in C++, you'll need to know:\n- **Two pointers** - Technique using two index variables to traverse array efficiently\n- **In place modification** - Modifying array elements without using extra space\n- **Array indexing** - Accessing and updating array elements by position\n- **Time complexity** - Understanding Big O notation for algorithm efficiency analysis\n\nDo you feel confident with these C++ concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in TypeScript, you'll need to know:\n- **Two pointers** - Technique using two index variables to traverse array efficiently\n- **In place modification** - Modifying array elements without using extra space\n- **Array indexing** - Accessing and updating array elements by position\n- **Time complexity** - Understanding Big O notation for algorithm efficiency analysis\n\nDo you feel confident with these TypeScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "Perfect! Now let's understand what the Remove Duplicates from Sorted Array problem asks for.\n\nImagine you're organizing your book collection on a shelf where books are already sorted alphabetically, but you notice some duplicates scattered throughout. You walk along the shelf with a \"keeper\" pointer, and whenever you find a book you don't already have in your final collection, you move it to the front section of the shelf right after your last unique book. By the end, all unique books are packed together at the beginning of the shelf, and you know exactly how many distinct titles you have.\n\n# Remove Duplicates from Sorted Array\n\n## What's the problem asking?\n\nYou're given a **sorted** array that contains duplicate numbers, and you need to remove all the duplicates **in-place** (meaning you can't create a new array). The tricky part? You need to modify the original array so that the first part contains only unique elements, and then return how many unique elements there are.\n\nThink of it like cleaning up a bookshelf - you want to keep only one copy of each book and push all the unique books to the front.\n\n## Here's how it works with an example:\n\nLet's say you start with: `[1, 1, 2, 2, 3]`\n\n**What you need to do:**\n- Remove duplicates in-place\n- Keep the unique elements at the beginning of the array\n- Return the count of unique elements\n\n**After processing:** `[1, 2, 3, ?, ?]`\n- The first 3 positions contain the unique elements\n- The remaining positions can contain anything (marked with `?`) - they don't matter\n- **Return:** `3` (because there are 3 unique elements)\n\n## Why does this approach work?\n\nThe key insight is that **the array is already sorted**! This means:\n\n1. **All duplicates are grouped together** - if you see a `1`, all other `1`s will be right next to it\n2. **You only need to compare adjacent elements** - if `arr[i] != arr[i-1]`, then you've found a new unique element\n3. **You can use two pointers** - one to scan through the array, another to track where to place the next unique element\n\nThe algorithm essentially says: \"Hey, I found a number I haven't seen yet in my 'clean' section, so let me add it to the front part of my array.\"\n\nSince it's sorted, once you pass all the `1`s, you'll never see another `1` again, so you don't need to worry about duplicates appearing later!",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "When removing duplicates from a sorted array [1,1,2,2,3] in-place, what should be the role of your two pointers to achieve O(1) space complexity?",
      "choices": [
        {
          "label": "Use two pointers moving in opposite directions - one from start, one from end - to swap duplicates with unique elements",
          "next": "wrong-choice"
        },
        {
          "label": "Use slow pointer to mark the write position for unique elements, fast pointer to scan and find the next different element",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-choice",
      "mentorSays": "This approach is flawed because in a sorted array, moving pointers from opposite ends doesn't help identify duplicates efficiently. Duplicates are adjacent in sorted arrays, and this bidirectional approach would disrupt the sorted order and create unnecessary complexity. You'd also lose track of which elements are duplicates since they're not necessarily at the ends.",
      "action": "next",
      "next": "pattern-recognition"
    },
    {
      "stepId": "pattern-recognition",
      "mentorSays": "### Pattern Recognition: Two Pointers for In-Place Filtering\n\n**This problem follows the \"slow-fast pointer\" pattern:**\n- **Slow pointer** - Tracks write position for valid elements\n- **Fast pointer** - Scans through array to find next unique element\n- **Sorted array property** - Duplicates are adjacent, enabling simple comparison\n- **In-place modification** - Overwrite array positions instead of creating new array\n\n**Similar problems:**\n- Remove Element (same two-pointer pattern)\n- Move Zeroes (similar filtering pattern)\n- Remove Duplicates from Sorted List (linked list version)\n\n**Key insight:** In sorted arrays, duplicates are adjacent. The slow pointer marks where to write the next unique element, and the fast pointer finds it by comparing with the last written element.",
      "action": "next",
      "next": "invariant"
    },
    {
      "stepId": "invariant",
      "mentorSays": "### Invariant: Elements Before Slow Pointer Are Unique and Sorted\n\n**Invariant maintained throughout:**\n- **Unique section:** All elements at indices [0..slow-1] are unique and sorted\n- **Last unique:** nums[slow-1] is the last unique element written\n- **Comparison basis:** We compare nums[fast] with nums[slow-1] to detect new unique values\n- **Write position:** Slow pointer is the next position to write a unique element\n\n**Why this works:**\n- Initially, slow=0, fast=1. First element is always unique.\n- When nums[fast] != nums[slow-1], we found a new unique element\n- Write it at position slow, then increment slow\n- Fast pointer always moves forward, ensuring we process all elements\n\n**Invariant guarantee:** After processing, elements at indices [0..slow-1] are all unique and in sorted order. The value of slow is the count of unique elements.",
      "action": "next",
      "next": "state-definition"
    },
    {
      "stepId": "state-definition",
      "mentorSays": "### State Definition: Two Pointer Filtering State\n\n**State variables:**\n- **`slow`** - Write pointer, tracks next position for unique element (starts at 0)\n- **`fast`** - Read pointer, scans through array (starts at 1)\n- **`nums`** - Sorted array being modified in-place\n\n**State transitions:**\n1. **Initialize:** slow = 0 (first element is always unique)\n2. **Loop:** For fast from 1 to n-1:\n   - If nums[fast] != nums[slow]: new unique element found\n   - Increment slow, copy nums[fast] to nums[slow]\n   - Increment fast\n3. **Result:** Return slow + 1 (number of unique elements)\n\n**State validity:** After loop, nums[0..slow] contains all unique elements in sorted order.",
      "action": "next",
      "next": "why-alternatives-fail"
    },
    {
      "stepId": "why-alternatives-fail",
      "mentorSays": "### Why Alternative Approaches Fail\n\n**Approach 1: Create New Array**\n- **Why it fails:** Uses O(n) extra space\n- **Issue:** Violates in-place requirement\n- **Better:** Two pointers use O(1) space\n\n**Approach 2: Use Set to Track Seen Elements**\n- **Why it fails:** Uses O(n) extra space for set\n- **Issue:** Doesn't leverage sorted property\n- **Better:** Sorted array allows comparison with last unique element\n\n**Approach 3: Remove Duplicates by Shifting**\n- **Why it fails:** O(nÂ²) time complexity\n- **Issue:** Removing element requires shifting all subsequent elements\n- **Better:** Two pointers overwrite in O(n) time\n\n**Our approach wins because:** Two pointers leverage the sorted property to remove duplicates in O(n) time with O(1) space. Comparing with the last written unique element is sufficient because duplicates are adjacent in sorted arrays.",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "The key insight is to use **two pointers** where the **slow pointer marks the write position** for unique elements while the **fast pointer scans through the array**. We only copy elements when `nums[fast] != nums[slow]`, then increment the slow pointer to the next write position. This works because in a sorted array, all duplicates are adjacent, so comparing with the last written unique element is sufficient to detect new unique values. For example, in `[1,1,2,2,3]`, when fast finds the first `2`, it differs from `nums[slow=0]=1`, so we write `2` at position `slow=1` and continue.",
      "action": "next",
      "next": "walkthrough",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "Let's trace through `[1,1,2,2,3]`:\n\n- Step 1: Initialize slow=0, fast=1; array=[1,1,2,2,3]\n- Step 2: nums[0]=1, nums[1]=1 (equal), move fast to 2\n- Step 3: nums[0]=1, nums[2]=2 (different), increment slow to 1, copy nums[2] to nums[1]; array=[1,2,2,2,3]\n- Step 4: nums[1]=2, nums[3]=2 (equal), move fast to 4\n- Step 5: nums[1]=2, nums[4]=3 (different), increment slow to 2, copy nums[4] to nums[2]; array=[1,2,3,2,3]\n- Step 6: fast reaches end of array\n- Final: **[1,2,3,...] return 3**",
      "action": "next",
      "next": "pseudocode-step",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "Here's our plan written as pseudocode:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now let's translate this into JavaScript, building it step by step.\n\nRemember: we'll add just 1-3 lines at a time!",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Initialize slow pointer to track the position where next unique element should be placed\n\n```javascript\nfunction removeDuplicates(nums) {\n    let slow = 0;\n}\n```",
      "action": "next",
      "next": "code-02",
      "pseudocodeLineIds": [
        "ps1"
      ],
      "example": "let slow = 0;"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Start fast pointer loop from index 1 to scan through the array\n\n```javascript\nfunction removeDuplicates(nums) {\n    let slow = 0;\n    for (let fast = 1; fast < nums.length; fast++) {\n    }\n}\n```",
      "action": "next",
      "next": "code-03",
      "pseudocodeLineIds": [
        "ps2"
      ],
      "example": "for (let fast = 1; fast < nums.length; fast++) {"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Check if current element is different from the last unique element at slow position\n\n```javascript\nfunction removeDuplicates(nums) {\n    let slow = 0;\n    for (let fast = 1; fast < nums.length; fast++) {\n        if (nums[fast] !== nums[slow]) {\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-04",
      "pseudocodeLineIds": [
        "ps3"
      ],
      "example": "if (nums[fast] !== nums[slow]) {"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Move slow pointer forward to next position for new unique element\n\n```javascript\nfunction removeDuplicates(nums) {\n    let slow = 0;\n    for (let fast = 1; fast < nums.length; fast++) {\n        if (nums[fast] !== nums[slow]) {\n            slow++;\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-05",
      "pseudocodeLineIds": [
        "ps4"
      ],
      "example": "slow++;"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Copy the unique element from fast position to slow position\n\n```javascript\nfunction removeDuplicates(nums) {\n    let slow = 0;\n    for (let fast = 1; fast < nums.length; fast++) {\n        if (nums[fast] !== nums[slow]) {\n            slow++;\n            nums[slow] = nums[fast];\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-06",
      "pseudocodeLineIds": [
        "ps5"
      ],
      "example": "nums[slow] = nums[fast];"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Return the count of unique elements (slow + 1 since slow is 0-indexed)\n\n```javascript\nfunction removeDuplicates(nums) {\n    let slow = 0;\n    for (let fast = 1; fast < nums.length; fast++) {\n        if (nums[fast] !== nums[slow]) {\n            slow++;\n            nums[slow] = nums[fast];\n        }\n    }\n    return slow + 1;\n}\n```",
      "action": "next",
      "next": "code-07",
      "pseudocodeLineIds": [
        "ps6"
      ],
      "example": "return slow + 1;"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Handle edge case: return 0 if array is empty (add at beginning)\n\n```javascript\nfunction removeDuplicates(nums) {\n    if (nums.length === 0) return 0;\n    let slow = 0;\n    for (let fast = 1; fast < nums.length; fast++) {\n        if (nums[fast] !== nums[slow]) {\n            slow++;\n            nums[slow] = nums[fast];\n        }\n    }\n    return slow + 1;\n}\n```",
      "action": "next",
      "next": "common-mistakes",
      "pseudocodeLineIds": [
        "ps7"
      ],
      "example": "if (nums.length === 0) return 0;"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "Great work mastering the \"Remove Duplicates from Sorted Array\" problem using the slow-fast pointer technique! You've demonstrated excellent understanding of how two pointers moving in the same direction can efficiently modify arrays in-place while maintaining sorted order. Next, we'll tackle the \"Valid Palindrome\" challenge, where you'll apply pointer skills in a new context by using two pointers moving from opposite ends toward each other.\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}