{
  "id": "serialize-deserialize-binary-tree",
  "title": "Serialize/Deserialize Binary Tree - Tree Serialization",
  "pattern": "tree-serialization",
  "difficulty": "hard",
  "language": "javascript",
  "status": "AI-GENERATED-V2-DIRECT",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 81,
    "tier": "COMPETITIVE",
    "lessonOrderTag": "COMPETITIVE-81",
    "introduces": [
      "tree-serialization",
      "tree-deserialization",
      "bfs-encoding"
    ],
    "assumesAlreadyTaught": [
      "binary-trees",
      "bfs",
      "dfs",
      "strings"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "binary-tree-maximum-path-sum"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Serialize: Use BFS to traverse tree level by level"
    },
    {
      "id": "ps2",
      "text": "For each node, add value to result (or 'null' if node is null)"
    },
    {
      "id": "ps3",
      "text": "Join values with delimiter (e.g., comma)"
    },
    {
      "id": "ps4",
      "text": "Deserialize: Split string by delimiter"
    },
    {
      "id": "ps5",
      "text": "Create root from first value"
    },
    {
      "id": "ps6",
      "text": "Use queue to rebuild tree level by level"
    },
    {
      "id": "ps7",
      "text": "For each parent, attach left and right children from array"
    },
    {
      "id": "ps8",
      "text": "Return reconstructed root"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "# Welcome to Serialize/Deserialize Binary Tree! ðŸŒ³\n\nReady for a challenging problem? You're about to learn how to convert trees to strings and back!\n\n## What You'll Master:\n\n- Converting tree structures to strings\n- Reconstructing trees from strings\n- BFS and DFS serialization strategies\n- Handling null nodes in serialization\n\nThis is used in databases, file systems, network transmission, and caching!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Which programming language would you like to use for this lesson?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "Python",
          "next": "prereq-check-python"
        },
        {
          "label": "Java",
          "next": "prereq-check-java"
        },
        {
          "label": "C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "To solve this in JavaScript, you'll need to know:\n\n- **Binary trees** and tree traversal\n- **BFS/DFS** algorithms\n- **String manipulation** (split, join)\n- **Queue data structure**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-js"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "To solve this in Python, you'll need to know:\n\n- **Binary trees** and tree traversal\n- **BFS/DFS** algorithms\n- **String manipulation** (split, join)\n- **deque from collections**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-python"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "To solve this in Java, you'll need to know:\n\n- **Binary trees** and tree traversal\n- **BFS/DFS** algorithms\n- **String manipulation** (split, join)\n- **LinkedList as Queue**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-java"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "To solve this in C++, you'll need to know:\n\n- **Binary trees** and tree traversal\n- **BFS/DFS** algorithms\n- **String manipulation** (stringstream)\n- **queue from STL**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "To solve this in TypeScript, you'll need to know:\n\n- **Binary trees** and tree traversal\n- **BFS/DFS** algorithms\n- **String manipulation** (split, join)\n- **Array as Queue**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "# The Problem: Serialize/Deserialize Binary Tree ðŸ’¾\n\n**Real-world analogy:** You're building a database that needs to save binary trees to disk and load them back later. When saving, you convert the tree to a string format. When loading, you reconstruct the tree from that string. This is like saving a family tree to a text file and being able to perfectly rebuild it!\n\n## The Challenge:\n\nDesign an algorithm to serialize and deserialize a binary tree.\n\n**Serialization** = converting a tree to a string representation\n**Deserialization** = converting a string back to the original tree structure\n\n## Example:\n```\nTree:\n    1\n   / \\\n  2   3\n     / \\\n    4   5\n\nSerialized: \"1,2,null,null,3,4,null,null,5,null,null\"\nor\nSerialized: \"1,2,3,null,null,4,5\" (level-order)\n\nDeserialize should reconstruct the exact same tree!\n```\n\n**Constraint:** Your serialize and deserialize methods should be inverses of each other.",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "# ðŸ¤” What Strategy Should We Use?\n\nThere are multiple approaches to serializing a tree.\n\n**Question:** Which traversal method makes serialization/deserialization easiest?",
      "choices": [
        {
          "label": "Inorder traversal - gives sorted values",
          "next": "wrong-inorder"
        },
        {
          "label": "Preorder DFS - easy to reconstruct root-first",
          "next": "alternative-preorder"
        },
        {
          "label": "Level-order BFS - natural left-to-right encoding",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-inorder",
      "mentorSays": "Inorder doesn't give enough information! Consider these two different trees:\n\n```\n  2          1\n /              \\\n1                2\n```\n\nBoth have inorder \"1,2\" but are completely different structures. We can't reconstruct uniquely!",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "alternative-preorder",
      "mentorSays": "Preorder DFS works great! It's actually a very good approach:\n\n```\nPreorder: root â†’ left â†’ right\nWith nulls: \"1,2,null,null,3,4,null,null,5,null,null\"\n```\n\nWe can reconstruct by reading values in preorder and building recursively.\n\nBut let me show you the BFS approach which is also elegant...",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "# The Key Insight: Level-Order BFS! ðŸ’¡\n\n**Level-order (BFS) serialization** is intuitive and efficient:\n\n## Serialization Strategy:\n\n1. **Use a queue** for level-order traversal\n2. **Visit nodes level by level** from left to right\n3. **Include null nodes** to preserve structure\n4. **Join with delimiter** (comma)\n\n## Example:\n```\nTree:\n    1\n   / \\\n  2   3\n     / \\\n    4   5\n\nLevel-order: [1, 2, 3, null, null, 4, 5, null, null, null, null]\nSerialized: \"1,2,3,null,null,4,5,null,null,null,null\"\n```\n\n## Deserialization Strategy:\n\n1. **Split string** into array of values\n2. **Create root** from first value\n3. **Use queue** to track parent nodes\n4. **For each parent**, attach next two values as children\n5. **Add non-null children** to queue\n\nBFS makes it natural to match parents with children!",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "# Let's Walk Through Serialization ðŸš¶\n\n```\nTree:\n    1\n   / \\\n  2   3\n       \\\n        4\n```\n\n**Serialize (BFS):**\n\n1. Queue: [1], result: []\n2. Process 1: result = [1], queue = [2, 3]\n3. Process 2: result = [1,2], queue = [3, null, null]\n4. Process 3: result = [1,2,3], queue = [null, null, null, 4]\n5. Process nulls: result = [1,2,3,null,null,null,4]\n6. Process 4: result = [1,2,3,null,null,null,4,null,null]\n\n**Final:** \"1,2,3,null,null,null,4,null,null\"\n\n**Deserialize:**\n\n1. Split: [\"1\",\"2\",\"3\",\"null\",\"null\",\"null\",\"4\",\"null\",\"null\"]\n2. Root: 1, queue = [1], index = 1\n3. Process 1: left=2, right=3, queue=[2,3], index=3\n4. Process 2: left=null, right=null, queue=[3], index=5\n5. Process 3: left=null, right=4, queue=[4], index=7\n6. Process 4: left=null, right=null, done!\n\n**Reconstructed tree matches original!**",
      "action": "next",
      "next": "pseudocode-step"
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "# Here's Our Battle Plan ðŸ“‹",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7",
        "ps8"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "# Time to Code! ðŸ’»\n\nWe'll implement both serialize and deserialize functions using BFS.",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Start with the serialize function:\n\n```javascript\nfunction serialize(root) {\n    if (!root) return \"\";\n    \n    const result = [];\n    const queue = [root];\n```\n\nHandle empty tree, then prepare for BFS.",
      "action": "next",
      "next": "code-02",
      "example": "function serialize(root) {\n    if (!root) return \"\";\n    \n    const result = [];\n    const queue = [root];"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Process nodes level by level:\n\n```javascript\n    while (queue.length > 0) {\n        const node = queue.shift();\n```\n\nDequeue the next node to process.",
      "action": "next",
      "next": "code-03",
      "example": "    while (queue.length > 0) {\n        const node = queue.shift();"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Add node value (or null) to result:\n\n```javascript\n        if (node) {\n            result.push(node.val);\n            queue.push(node.left);\n            queue.push(node.right);\n        } else {\n            result.push(null);\n        }\n```\n\nFor real nodes, add value and enqueue children. For null, just record it.",
      "action": "next",
      "next": "code-04",
      "example": "        if (node) {\n            result.push(node.val);\n            queue.push(node.left);\n            queue.push(node.right);\n        } else {\n            result.push(null);\n        }"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Return the serialized string:\n\n```javascript\n    }\n    return result.join(',');\n}\n```\n\nJoin all values with commas!",
      "action": "next",
      "next": "code-05",
      "example": "    }\n    return result.join(',');\n}"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Now for deserialize - start by parsing the string:\n\n```javascript\nfunction deserialize(data) {\n    if (!data) return null;\n    \n    const values = data.split(',');\n    const root = new TreeNode(parseInt(values[0]));\n    const queue = [root];\n    let i = 1;\n```\n\nCreate root and prepare to rebuild tree.",
      "action": "next",
      "next": "code-06",
      "example": "function deserialize(data) {\n    if (!data) return null;\n    \n    const values = data.split(',');\n    const root = new TreeNode(parseInt(values[0]));\n    const queue = [root];\n    let i = 1;"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Process each parent node:\n\n```javascript\n    while (queue.length > 0) {\n        const node = queue.shift();\n```",
      "action": "next",
      "next": "code-07",
      "example": "    while (queue.length > 0) {\n        const node = queue.shift();"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Attach left child:\n\n```javascript\n        if (values[i] !== 'null') {\n            node.left = new TreeNode(parseInt(values[i]));\n            queue.push(node.left);\n        }\n        i++;\n```\n\nIf not null, create node and enqueue it for its own children.",
      "action": "next",
      "next": "code-08",
      "example": "        if (values[i] !== 'null') {\n            node.left = new TreeNode(parseInt(values[i]));\n            queue.push(node.left);\n        }\n        i++;"
    },
    {
      "stepId": "code-08",
      "mentorSays": "Attach right child:\n\n```javascript\n        if (values[i] !== 'null') {\n            node.right = new TreeNode(parseInt(values[i]));\n            queue.push(node.right);\n        }\n        i++;\n    }\n```\n\nSame logic for right child!",
      "action": "next",
      "next": "code-09",
      "example": "        if (values[i] !== 'null') {\n            node.right = new TreeNode(parseInt(values[i]));\n            queue.push(node.right);\n        }\n        i++;\n    }"
    },
    {
      "stepId": "code-09",
      "mentorSays": "Return the reconstructed tree:\n\n```javascript\n    return root;\n}\n```\n\nComplete! The tree is rebuilt.",
      "action": "next",
      "next": "complexity-analysis",
      "example": "    return root;\n}"
    },
    {
      "stepId": "complexity-analysis",
      "mentorSays": "# Complexity Analysis ðŸ“Š\n\n## Serialization:\n**Time:** O(n) - visit each node once\n**Space:** O(n) - queue can hold up to n/2 nodes (last level)\n\n## Deserialization:\n**Time:** O(n) - process each value once\n**Space:** O(n) - queue and reconstructed tree\n\n## Overall:\nBoth operations are **linear** in the number of nodes!\n\n## Comparison with DFS Preorder:\n\n**BFS approach:**\n- Pro: Intuitive level-by-level\n- Pro: Easy to understand parent-child relationship\n- Con: May include trailing nulls\n\n**DFS Preorder:**\n- Pro: More compact (no trailing nulls)\n- Pro: Recursive elegance\n- Con: Slightly less intuitive\n\nBoth are O(n) and perfectly valid!",
      "action": "next",
      "next": "edge-cases"
    },
    {
      "stepId": "edge-cases",
      "mentorSays": "# Edge Cases ðŸŽ¯\n\n1. **Empty tree:** null â†’ \"\" â†’ null âœ“\n\n2. **Single node:** [1] â†’ \"1,null,null\" â†’ [1] âœ“\n\n3. **Left-skewed tree:**\n```\n    1\n   /\n  2\n /\n3\n```\nâ†’ \"1,2,null,3,null,null,null\" âœ“\n\n4. **Right-skewed tree:** Similar pattern\n\n5. **Complete tree:** All levels full\n\n6. **Negative values:** Works fine (use parseInt)\n\n7. **Large values:** String handles any integer\n\nOur solution handles all cases correctly!",
      "action": "next",
      "next": "optimization-note"
    },
    {
      "stepId": "optimization-note",
      "mentorSays": "# Optimization: Trim Trailing Nulls ðŸ”§\n\nOur serialization includes trailing nulls:\n```\n\"1,2,3,null,null,null,null\"\n```\n\nWe could trim them:\n```\n\"1,2,3\"\n```\n\n**Implementation:**\n```javascript\n// After building result array:\nwhile (result[result.length - 1] === null) {\n    result.pop();\n}\n```\n\n**Tradeoff:**\n- Saves space in serialized format\n- Deserialization needs to handle missing values\n- Slightly more complex logic\n\n**For clarity, we keep trailing nulls** - it makes deserialization simpler and the space difference is usually negligible!",
      "action": "next",
      "next": "common-mistakes"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "# Congratulations! ðŸŽ‰\n\nYou've mastered **tree serialization** - a critical skill for system design!\n\n## What You Learned:\n\nâœ… Converting trees to strings (serialization)\nâœ… Reconstructing trees from strings (deserialization)\nâœ… BFS level-order encoding\nâœ… Handling null nodes in tree structure\n\n## Next Steps:\n\nReady for more tree challenges? The next lesson is **Binary Tree Maximum Path Sum** - using post-order DFS to find optimal paths. It builds on your tree traversal knowledge!\n\nSerialization appears everywhere: caching, databases, network protocols, file systems!\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}