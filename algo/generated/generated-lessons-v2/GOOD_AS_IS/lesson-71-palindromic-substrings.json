{
  "id": "palindromic-substrings",
  "title": "Palindromic Substrings - Counting All Palindromes",
  "pattern": "expand-around-center-counting",
  "difficulty": "medium",
  "language": "javascript",
  "status": "AI-GENERATED-V2-DIRECT",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 71,
    "tier": "MASTERY-II",
    "lessonOrderTag": "MASTERY-II-71",
    "introduces": [
      "palindrome-counting",
      "center-expansion-variants"
    ],
    "assumesAlreadyTaught": [
      "expand-around-center",
      "strings",
      "palindromes"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "group-anagrams"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Initialize count = 0"
    },
    {
      "id": "ps2",
      "text": "For each possible center in string:"
    },
    {
      "id": "ps3",
      "text": "  Expand around center for odd-length palindromes"
    },
    {
      "id": "ps4",
      "text": "  Count palindromes while expanding"
    },
    {
      "id": "ps5",
      "text": "  Expand around center for even-length palindromes"
    },
    {
      "id": "ps6",
      "text": "  Count palindromes while expanding"
    },
    {
      "id": "ps7",
      "text": "Return total count"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "# Welcome to Palindromic Substrings! ðŸ”„\n\nReady to master palindrome counting? This builds on what you learned about finding the longest palindrome!\n\n## What You'll Master:\n\n- Counting all palindromic substrings\n- Advanced center expansion technique\n- Tracking counts during expansion\n- Handling both odd and even length palindromes\n\nThis pattern appears in string analysis, pattern matching, and DNA sequencing!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Which programming language would you like to use for this lesson?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "Python",
          "next": "prereq-check-python"
        },
        {
          "label": "Java",
          "next": "prereq-check-java"
        },
        {
          "label": "C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "To solve this in JavaScript, you'll need to know:\n\n- **String manipulation**\n- **Two pointers** technique\n- **Center expansion** pattern\n- **Basic counting logic**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-js"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "To solve this in Python, you'll need to know:\n\n- **String manipulation**\n- **Two pointers** technique\n- **Center expansion** pattern\n- **Basic counting logic**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-python"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "To solve this in Java, you'll need to know:\n\n- **String manipulation**\n- **Two pointers** technique\n- **Center expansion** pattern\n- **Basic counting logic**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-java"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "To solve this in C++, you'll need to know:\n\n- **String manipulation**\n- **Two pointers** technique\n- **Center expansion** pattern\n- **Basic counting logic**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "To solve this in TypeScript, you'll need to know:\n\n- **String manipulation**\n- **Two pointers** technique\n- **Center expansion** pattern\n- **Basic counting logic**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "# The Problem: Palindromic Substrings ðŸ”„\n\n**Real-world analogy:** You're analyzing DNA sequences to find all palindromic patterns (sequences that read the same forwards and backwards). Each palindrome might indicate a special genetic structure. You need to count ALL of them, not just find the longest!\n\n## The Challenge:\n\nGiven a string `s`, return the number of **palindromic substrings** in it.\n\nA substring is a contiguous sequence of characters. A string is palindromic if it reads the same backward as forward.\n\n## Example 1:\n```\nInput: s = \"abc\"\nOutput: 3\nExplanation: Three palindromic substrings: \"a\", \"b\", \"c\"\n```\n\n## Example 2:\n```\nInput: s = \"aaa\"\nOutput: 6\nExplanation: Six palindromic substrings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\"\n```\n\n**Key difference from previous lesson:** We're counting ALL palindromes, not finding the longest one!",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "# ðŸ¤” How Should We Count All Palindromes?\n\nWe could check every substring, but that's O(nÂ³)...\n\n**Question:** What's the key insight for efficiently counting all palindromes?",
      "choices": [
        {
          "label": "Check all substrings - O(nÂ³)",
          "next": "wrong-brute-force"
        },
        {
          "label": "Use DP to build up palindrome table - O(nÂ²) space",
          "next": "wrong-dp"
        },
        {
          "label": "Expand around each center, counting as we expand - O(nÂ²) time, O(1) space",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-brute-force",
      "mentorSays": "That would work but is very slow! With nÂ² possible substrings and O(n) to check each one, we get O(nÂ³).\n\nThere's a much smarter approach...",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "wrong-dp",
      "mentorSays": "DP works and is a valid approach! You'd build a table where `dp[i][j]` tells if substring from i to j is a palindrome.\n\nBut there's an even more space-efficient solution using the expansion technique...",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "# The Key Insight: Expand and Count! ðŸ’¡\n\n**Core idea:** Instead of finding the longest palindrome, we COUNT every palindrome we discover while expanding!\n\n## The Algorithm:\n\n1. **For each possible center** (n centers for odd-length, n-1 for even-length)\n2. **Expand outward** while characters match\n3. **Count each valid palindrome** we discover\n4. **Stop** when characters don't match\n\n## Why This Works:\n\n**Odd-length palindromes:** Center is a single character\n- \"aba\" expands from 'b'\n- Count: \"b\" (length 1), \"aba\" (length 3)\n\n**Even-length palindromes:** Center is between two characters\n- \"abba\" expands from between the two 'b's\n- Count: \"bb\" (length 2), \"abba\" (length 4)\n\n## Complexity:\n- **Time:** O(nÂ²) - n centers, O(n) expansion each\n- **Space:** O(1) - just counters!",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "# Let's Walk Through an Example ðŸš¶\n\n```\ns = \"aaa\"\n```\n\n**Odd-length palindromes (center = single char):**\n\nCenter at index 0 ('a'):\n- Expand: just 'a' â†’ count = 1\n- Try expand: out of bounds on left\n\nCenter at index 1 ('a'):\n- Expand: just 'a' â†’ count = 2\n- Expand: 'aa' matches? No, check indices 0 and 2: 'a' == 'a' âœ“ â†’ count = 3\n- Expand: 'aaa' â†’ count = 4\n- Try expand: out of bounds\n\nCenter at index 2 ('a'):\n- Expand: just 'a' â†’ count = 5\n- Try expand: out of bounds on right\n\n**Even-length palindromes (center = between chars):**\n\nCenter between index 0 and 1:\n- s[0] == s[1]? 'a' == 'a' âœ“ â†’ \"aa\" â†’ count = 6\n- Try expand: out of bounds on left\n\nCenter between index 1 and 2:\n- s[1] == s[2]? 'a' == 'a' âœ“ â†’ \"aa\" (different instance) â†’ count = 7? \n- Wait, we already counted this! Actually this is the second \"aa\"\n\nActually, let me recount properly:\n1. \"a\" at index 0\n2. \"a\" at index 1  \n3. \"a\" at index 2\n4. \"aa\" from indices 0-1\n5. \"aa\" from indices 1-2\n6. \"aaa\" from indices 0-2\n\n**Total: 6 palindromes** âœ“",
      "action": "next",
      "next": "pseudocode-step"
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "# Here's Our Battle Plan ðŸ“‹",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "# Time to Code! ðŸ’»\n\nWe'll create a helper function to expand and count, then use it for both odd and even-length palindromes.",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Start with the main function:\n\n```javascript\nfunction countSubstrings(s) {\n    let count = 0;\n```\n\nWe'll accumulate the total count of palindromes.",
      "action": "next",
      "next": "code-02",
      "example": "function countSubstrings(s) {\n    let count = 0;"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Create a helper function to expand around a center:\n\n```javascript\n    function expandAroundCenter(left, right) {\n        let localCount = 0;\n```\n\nThis will count palindromes for a specific center.",
      "action": "next",
      "next": "code-03",
      "example": "    function expandAroundCenter(left, right) {\n        let localCount = 0;"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Expand while characters match and we're in bounds:\n\n```javascript\n        while (left >= 0 && right < s.length && s[left] === s[right]) {\n            localCount++;\n            left--;\n            right++;\n        }\n```\n\nEach valid expansion is a palindrome!",
      "action": "next",
      "next": "code-04",
      "example": "        while (left >= 0 && right < s.length && s[left] === s[right]) {\n            localCount++;\n            left--;\n            right++;\n        }"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Return the count and close the helper:\n\n```javascript\n        return localCount;\n    }\n```",
      "action": "next",
      "next": "code-05",
      "example": "        return localCount;\n    }"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Iterate through each possible center:\n\n```javascript\n    for (let i = 0; i < s.length; i++) {\n```\n\nEach character can be a center for odd-length palindromes, and each gap can be a center for even-length.",
      "action": "next",
      "next": "code-06",
      "example": "    for (let i = 0; i < s.length; i++) {"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Count odd-length palindromes (center is single character):\n\n```javascript\n        count += expandAroundCenter(i, i);\n```\n\nStart with left = right = i.",
      "action": "next",
      "next": "code-07",
      "example": "        count += expandAroundCenter(i, i);"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Count even-length palindromes (center is between characters):\n\n```javascript\n        count += expandAroundCenter(i, i + 1);\n    }\n```\n\nStart with left = i, right = i + 1.",
      "action": "next",
      "next": "code-08",
      "example": "        count += expandAroundCenter(i, i + 1);\n    }"
    },
    {
      "stepId": "code-08",
      "mentorSays": "Return the total count:\n\n```javascript\n    return count;\n}\n```\n\nAnd we're done!",
      "action": "next",
      "next": "complexity-analysis",
      "example": "    return count;\n}"
    },
    {
      "stepId": "complexity-analysis",
      "mentorSays": "# Complexity Analysis ðŸ“Š\n\n## Time Complexity: O(nÂ²)\n- We have n possible centers for odd-length palindromes\n- We have n-1 possible centers for even-length palindromes\n- Total: 2n - 1 centers\n- Each expansion can go up to O(n) in the worst case (entire string is a palindrome)\n- Overall: O(n Ã— n) = O(nÂ²)\n\n## Space Complexity: O(1)\n- We only use a few variables (count, left, right)\n- No extra data structures needed!\n- Much better than the DP approach which uses O(nÂ²) space\n\n## Comparison with DP:\n\n**Expand Around Center:** O(nÂ²) time, O(1) space âœ“\n**DP Table:** O(nÂ²) time, O(nÂ²) space\n\nBoth have same time complexity, but expansion is more space-efficient!",
      "action": "next",
      "next": "edge-cases"
    },
    {
      "stepId": "edge-cases",
      "mentorSays": "# Edge Cases to Consider ðŸŽ¯\n\n1. **Single character:** \"a\" â†’ 1 palindrome\n\n2. **All same characters:** \"aaaa\" â†’ 10 palindromes\n   - 4 single chars + 3 pairs + 2 triples + 1 quad = 10\n   - Formula: n(n+1)/2\n\n3. **No repeated chars:** \"abcd\" â†’ 4 palindromes (just the individual chars)\n\n4. **Empty string:** \"\" â†’ 0 palindromes\n\n5. **Alternating pattern:** \"aba\" â†’ 4 palindromes (\"a\", \"b\", \"a\", \"aba\")\n\n6. **Nested palindromes:** \"abcba\" â†’ 7 palindromes\n\nOur solution handles all of these correctly!",
      "action": "next",
      "next": "optimization-note"
    },
    {
      "stepId": "optimization-note",
      "mentorSays": "# Advanced Optimization: Manacher's Algorithm ðŸš€\n\nFor counting/finding palindromes, there's an even faster algorithm: **Manacher's Algorithm**\n\n**Time Complexity:** O(n) - Linear time!\n**Space Complexity:** O(n)\n\nIt's quite complex but achieves linear time by:\n1. Transforming string to avoid odd/even cases\n2. Using previously computed palindrome info to skip redundant checks\n3. Maintaining a \"palindrome radius\" array\n\n**When to use:**\n- Our O(nÂ²) solution is perfectly fine for most interviews and real-world use\n- Manacher's is mainly for competitive programming or when n is huge\n- Our solution is much easier to understand and implement correctly\n\n**Stick with expansion for interviews** unless specifically asked to optimize further!",
      "action": "next",
      "next": "common-mistakes"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "# Congratulations! ðŸŽ‰\n\nYou've mastered **palindrome counting** using the expand-around-center technique!\n\n## What You Learned:\n\nâœ… Counting patterns instead of just finding them\nâœ… Handling both odd and even-length palindromes\nâœ… O(1) space solution with expansion\nâœ… When to use different palindrome algorithms\n\n## Next Steps:\n\nReady for a different challenge? The next lesson is **Group Anagrams** - using hashing to group strings efficiently. It's a completely different pattern but equally important for interviews!\n\nPalindrome problems are common - you now have multiple techniques in your toolkit!\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}