{
  "id": "binary-tree-inorder-traversal",
  "title": "Binary Tree Inorder Traversal",
  "pattern": "tree traversal (DFS - inorder)",
  "difficulty": "easy",
  "language": "javascript",
  "status": "AI-GENERATED-V2-BATCH",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 36,
    "tier": "INTERMEDIATE",
    "lessonOrderTag": "INTERMEDIATE-36",
    "introduces": [
      "binary-tree-concept",
      "tree-node",
      "inorder-traversal",
      "recursion-on-trees",
      "left-root-right"
    ],
    "assumesAlreadyTaught": [
      "recursion-concept",
      "arrays",
      "null-check"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "binary-tree-preorder-traversal"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Start with the root node of the binary tree"
    },
    {
      "id": "ps2",
      "text": "If current node is null, return (base case for recursion)"
    },
    {
      "id": "ps3",
      "text": "Recursively traverse the left subtree of current node"
    },
    {
      "id": "ps4",
      "text": "Visit and process the current node (add to result list)"
    },
    {
      "id": "ps5",
      "text": "Recursively traverse the right subtree of current node"
    },
    {
      "id": "ps6",
      "text": "Return the complete inorder traversal result"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "Hey! \n\nReady to explore the elegant world of binary trees? After mastering sliding windows with max-consecutive-ones-iii, we're shifting gears to dive into **Binary Tree Inorder Traversal** - one of the most fundamental tree traversal patterns you'll use again and again!\n\n**The Pattern: Tree Traversal (DFS - Inorder)**\nInorder traversal follows a beautiful \"left-root-right\" rhythm: visit the left subtree first, then process the current node, and finally explore the right subtree. This depth-first approach creates a systematic way to visit every node exactly once, and for binary search trees, it gives you nodes in sorted order - pretty cool, right?\n\n**3 Skills You'll Master:**\n1. **Recursive Tree Navigation** - Build intuition for thinking recursively about tree structures\n2. **Stack-Based Iterative Solutions** - Learn how to convert recursive logic into iterative code using stacks\n3. **Tree Traversal Foundation** - Establish the groundwork for preorder, postorder, and more complex tree algorithms\n\nThis is your gateway to understanding how trees work under the hood, and trust me, once this pattern clicks, you'll see trees everywhere in coding interviews and real-world applications. You've got this!\n\nLet's dive in!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Before we dive into the problem, which programming language would you like to use?\n\nThis will help me make sure you have the right building blocks.",
      "choices": [
        {
          "label": "üíõ JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "üêç Python",
          "next": "prereq-check-python"
        },
        {
          "label": "‚òï Java",
          "next": "prereq-check-java"
        },
        {
          "label": "‚ö° C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "üíô TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in JavaScript, you'll need to know:\n- **Binary tree structure** - Understanding of binary tree nodes with left and right child pointers\n- **Recursion concept** - Ability to write and understand recursive functions with base cases\n- **Tree traversal basics** - Knowledge of different tree traversal methods and their ordering\n- **Null check** - Understanding how to handle null/empty node references safely\n\nDo you feel confident with these JavaScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-js"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Python, you'll need to know:\n- **Binary tree structure** - Understanding of binary tree nodes with left and right child pointers\n- **Recursion concept** - Ability to write and understand recursive functions with base cases\n- **Tree traversal basics** - Knowledge of different tree traversal methods and their ordering\n- **Null check** - Understanding how to handle null/empty node references safely\n\nDo you feel confident with these Python concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-python"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Java, you'll need to know:\n- **Binary tree structure** - Understanding of binary tree nodes with left and right child pointers\n- **Recursion concept** - Ability to write and understand recursive functions with base cases\n- **Tree traversal basics** - Knowledge of different tree traversal methods and their ordering\n- **Null check** - Understanding how to handle null/empty node references safely\n\nDo you feel confident with these Java concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-java"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in C++, you'll need to know:\n- **Binary tree structure** - Understanding of binary tree nodes with left and right child pointers\n- **Recursion concept** - Ability to write and understand recursive functions with base cases\n- **Tree traversal basics** - Knowledge of different tree traversal methods and their ordering\n- **Null check** - Understanding how to handle null/empty node references safely\n\nDo you feel confident with these C++ concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in TypeScript, you'll need to know:\n- **Binary tree structure** - Understanding of binary tree nodes with left and right child pointers\n- **Recursion concept** - Ability to write and understand recursive functions with base cases\n- **Tree traversal basics** - Knowledge of different tree traversal methods and their ordering\n- **Null check** - Understanding how to handle null/empty node references safely\n\nDo you feel confident with these TypeScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "Perfect! Now let's understand what the Binary Tree Inorder Traversal problem asks for.\n\nImagine reading a family tree where you want to list all family members in age order within each generation. You'd start at any person, first go to their youngest descendant on the left side, then write down that person's name, then move to their parent, write that name, then go to the youngest on the right side - this left-root-right pattern naturally gives you everyone in sorted order, just like inorder traversal visits the leftmost node first, then the parent, then the right subtree.\n\n# Binary Tree Inorder Traversal\n\nHey! Let's break down this classic tree problem step by step.\n\n## What it's asking for\n\nYou're given the root of a binary tree, and you need to return the **inorder traversal** of its node values as a list.\n\nBut what exactly is \"inorder traversal\"? It's a specific way of visiting every node in a binary tree following this pattern:\n1. **Left** subtree first\n2. **Root** node \n3. **Right** subtree last\n\nThink of it as \"Left-Root-Right\" - that's your mantra!\n\n## Let's walk through the example\n\nGiven this tree structure where `root = [1, null, 2, 3]`:\n\n```\n    1\n     \\\n      2\n     /\n    3\n```\n\nThe expected output is `[1, 3, 2]`.\n\n## Why does this work?\n\nLet's trace through it step by step using our \"Left-Root-Right\" rule:\n\n**Starting at node 1:**\n- Left subtree of 1? There isn't one (null)\n- Root: Add **1** to our result ‚Üí `[1]`\n- Right subtree of 1? Yes, it's node 2\n\n**Now at node 2:**\n- Left subtree of 2? Yes, it's node 3\n- Let's go there first...\n\n**At node 3:**\n- Left subtree of 3? Nope (null)\n- Root: Add **3** to our result ‚Üí `[1, 3]`\n- Right subtree of 3? Nope (null)\n- Done with node 3, go back to node 2\n\n**Back at node 2:**\n- We already handled the left subtree (node 3)\n- Root: Add **2** to our result ‚Üí `[1, 3, 2]`\n- Right subtree of 2? Nope (null)\n\nAnd there you have it! `[1, 3, 2]`\n\nThe key insight is that inorder traversal always visits the leftmost nodes first, then works its way back up and to the right. It's like reading the tree from left to right if you imagine all the nodes projected onto a horizontal line.",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "You have a Binary Search Tree and need to retrieve all values in ascending order. Given the tree structure where each node has a value, left child, and right child, what is the most efficient approach to achieve this?",
      "choices": [
        {
          "label": "Perform level-order traversal (BFS) and then sort the collected values",
          "next": "wrong-choice"
        },
        {
          "label": "Perform inorder traversal (DFS): visit left subtree ‚Üí process root ‚Üí visit right subtree",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-choice",
      "mentorSays": "While this approach would eventually give you sorted values, it's inefficient because it ignores the inherent ordering property of BSTs. Level-order traversal visits nodes by depth level, which doesn't respect the BST's sorted structure, requiring an additional O(n log n) sorting step. This defeats the purpose of using a BST in the first place.",
      "action": "next",
      "next": "pattern-recognition"
    },
    {
      "stepId": "pattern-recognition",
      "mentorSays": "### Pattern Recognition: DFS Inorder Traversal (Left-Root-Right)\n\n**This problem follows the \"inorder DFS traversal\" pattern:**\n- **Left-Root-Right order** - Visit left subtree, process root, visit right subtree\n- **Recursive structure** - Natural recursion on tree structure\n- **Sorted output** - For BSTs, inorder produces sorted sequence\n\n**Similar problems:**\n- Binary Tree Preorder Traversal (Root-Left-Right)\n- Binary Tree Postorder Traversal (Left-Right-Root)\n- Validate Binary Search Tree (uses inorder property)\n\n**Key insight:** Inorder traversal follows the natural sorted order for BSTs. The recursive structure makes implementation elegant.",
      "action": "next",
      "next": "invariant"
    },
    {
      "stepId": "invariant",
      "mentorSays": "### Invariant: Result Contains Nodes in Inorder Sequence\n\n**Invariant maintained throughout:**\n- **Processing order:** For each node, we process left subtree ‚Üí node ‚Üí right subtree\n- **Result array:** Contains all processed nodes in inorder sequence\n- **BST property:** For BSTs, inorder traversal produces sorted sequence\n\n**Why this works:**\n- Left subtree contains all values < root\n- Right subtree contains all values > root\n- Processing left ‚Üí root ‚Üí right ensures sorted order\n\n**Invariant guarantee:** After processing a node and its subtrees, all nodes from the left subtree, the node itself, and the right subtree are in the result array in the correct inorder sequence.",
      "action": "next",
      "next": "state-definition"
    },
    {
      "stepId": "state-definition",
      "mentorSays": "### State Definition: Recursive Traversal State\n\n**State variables:**\n- **`result`** - Array accumulating node values in inorder order\n- **`node`** - Current node being processed\n- **Call stack** - Implicit state tracking recursion depth\n\n**State transitions:**\n1. **Base case:** If `node === null`, return (no processing needed)\n2. **Recursive case:**\n   - Process left subtree: `inorder(node.left, result)`\n   - Process current node: `result.push(node.val)`\n   - Process right subtree: `inorder(node.right, result)`\n\n**State validity:** Result is valid when all nodes are processed in left-root-right order.",
      "action": "next",
      "next": "why-alternatives-fail"
    },
    {
      "stepId": "why-alternatives-fail",
      "mentorSays": "### Why Alternative Approaches Fail\n\n**Approach 1: Level-Order Traversal + Sort**\n- **Why it fails:** O(n log n) time due to sorting\n- **Issue:** Ignores BST's inherent sorted structure\n- **Better:** Inorder traversal is O(n) and naturally sorted\n\n**Approach 2: Collect All Values Then Sort**\n- **Why it fails:** O(n log n) time, doesn't leverage tree structure\n- **Issue:** Works for any tree, but inefficient for BSTs\n- **Better:** Inorder traversal respects BST property\n\n**Approach 3: Iterative with Explicit Stack**\n- **Why it doesn't fail:** Actually works, but more complex\n- **Issue:** More code, harder to understand\n- **Better:** Recursive approach is simpler and more intuitive\n\n**Our approach wins because:** Recursive inorder traversal is simple, efficient (O(n)), and naturally produces sorted output for BSTs without additional sorting.",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "The key insight is that **inorder traversal** follows the pattern **Left ‚Üí Root ‚Üí Right**, which naturally produces elements in **sorted ascending order** for Binary Search Trees. This works because BST properties guarantee that all values in the left subtree are smaller than the root, and all values in the right subtree are larger. For example, in BST [2,1,3], inorder traversal visits: left child (1) ‚Üí root (2) ‚Üí right child (3) = [1,2,3]. The **recursive nature** ensures we fully explore each left subtree before processing any root or right nodes, maintaining the sorted sequence.",
      "action": "next",
      "next": "walkthrough",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "Let's trace through `root=[1,null,2,3]`:\n\n- Step 1: Start at root node 1, go left (null) - no left child, so visit node 1, add 1 to result: [1]\n- Step 2: Go right from node 1 to node 2, then go left to node 3\n- Step 3: At node 3, go left (null) - no left child, so visit node 3, add 3 to result: [1,3]\n- Step 4: Go right from node 3 (null) - no right child, backtrack to node 2\n- Step 5: Visit node 2, add 2 to result: [1,3,2]\n- Step 6: Go right from node 2 (null) - no right child, traversal complete\n- Final: **[1,3,2]**",
      "action": "next",
      "next": "pseudocode-step",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "Here's our plan written as pseudocode:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now let's translate this into JavaScript, building it step by step.\n\nRemember: we'll add just 1-3 lines at a time!",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Define the main function that takes a BST root and returns sorted array\n\n```javascript\nfunction inorderTraversal(root) {\n    \n}\n```",
      "action": "next",
      "next": "code-02",
      "pseudocodeLineIds": [
        "ps1"
      ],
      "example": "function inorderTraversal(root) {\n    \n}"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Initialize empty result array to store the sorted values\n\n```javascript\nfunction inorderTraversal(root) {\n    const result = [];\n}\n```",
      "action": "next",
      "next": "code-03",
      "pseudocodeLineIds": [
        "ps2"
      ],
      "example": "const result = [];"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Define helper function for recursive inorder traversal\n\n```javascript\nfunction inorderTraversal(root) {\n    const result = [];\n    \n    function inorder(node) {\n        \n    }\n}\n```",
      "action": "next",
      "next": "code-04",
      "pseudocodeLineIds": [
        "ps3"
      ],
      "example": "function inorder(node) {\n        \n}"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Add base case: return immediately if current node is null\n\n```javascript\nfunction inorderTraversal(root) {\n    const result = [];\n    \n    function inorder(node) {\n        if (!node) return;\n    }\n}\n```",
      "action": "next",
      "next": "code-05",
      "pseudocodeLineIds": [
        "ps4"
      ],
      "example": "if (!node) return;"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Recursively traverse left subtree first (smaller values)\n\n```javascript\nfunction inorderTraversal(root) {\n    const result = [];\n    \n    function inorder(node) {\n        if (!node) return;\n        inorder(node.left);\n    }\n}\n```",
      "action": "next",
      "next": "code-06",
      "pseudocodeLineIds": [
        "ps5"
      ],
      "example": "inorder(node.left);"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Process current root node by adding its value to result array\n\n```javascript\nfunction inorderTraversal(root) {\n    const result = [];\n    \n    function inorder(node) {\n        if (!node) return;\n        inorder(node.left);\n        result.push(node.val);\n    }\n}\n```",
      "action": "next",
      "next": "code-07",
      "pseudocodeLineIds": [
        "ps6"
      ],
      "example": "result.push(node.val);"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Recursively traverse right subtree last (larger values)\n\n```javascript\nfunction inorderTraversal(root) {\n    const result = [];\n    \n    function inorder(node) {\n        if (!node) return;\n        inorder(node.left);\n        result.push(node.val);\n        inorder(node.right);\n    }\n}\n```",
      "action": "next",
      "next": "code-08",
      "pseudocodeLineIds": [
        "ps7"
      ],
      "example": "inorder(node.right);"
    },
    {
      "stepId": "code-08",
      "mentorSays": "Start the traversal by calling helper function with root node\n\n```javascript\nfunction inorderTraversal(root) {\n    const result = [];\n    \n    function inorder(node) {\n        if (!node) return;\n        inorder(node.left);\n        result.push(node.val);\n        inorder(node.right);\n    }\n    \n    inorder(root);\n}\n```",
      "action": "next",
      "next": "code-09",
      "pseudocodeLineIds": [
        "ps8"
      ],
      "example": "inorder(root);"
    },
    {
      "stepId": "code-09",
      "mentorSays": "Return the result array containing all values in sorted order\n\n```javascript\nfunction inorderTraversal(root) {\n    const result = [];\n    \n    function inorder(node) {\n        if (!node) return;\n        inorder(node.left);\n        result.push(node.val);\n        inorder(node.right);\n    }\n    \n    inorder(root);\n    return result;\n}\n```",
      "action": "next",
      "next": "common-mistakes",
      "pseudocodeLineIds": [
        "ps9"
      ],
      "example": "return result;"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "Great work mastering binary tree inorder traversal! You've successfully implemented one of the fundamental tree traversal patterns using depth-first search, which visits nodes in left-root-right order. Next, we'll tackle binary tree preorder traversal, where you'll learn the root-left-right visiting pattern that's essential for many tree algorithms.\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}