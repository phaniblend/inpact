{
  "id": "max-consecutive-ones-iii",
  "title": "Max Consecutive Ones III",
  "pattern": "sliding window + constraint tracking",
  "difficulty": "medium",
  "language": "javascript",
  "status": "AI-GENERATED-V2-BATCH",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 35,
    "tier": "INTERMEDIATE",
    "lessonOrderTag": "INTERMEDIATE-35",
    "introduces": [
      "flip-counting",
      "constraint-based-window"
    ],
    "assumesAlreadyTaught": [
      "sliding-window-concept",
      "arrays",
      "Math.max"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "binary-tree-inorder-traversal"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Initialize left pointer at 0, zeros_flipped counter at 0, and max_length at 0"
    },
    {
      "id": "ps2",
      "text": "For each right pointer from 0 to end of array, expand the window"
    },
    {
      "id": "ps3",
      "text": "If current element is 0, increment zeros_flipped counter"
    },
    {
      "id": "ps4",
      "text": "While zeros_flipped exceeds k, contract window by moving left pointer right"
    },
    {
      "id": "ps5",
      "text": "If element at left pointer is 0 before moving, decrement zeros_flipped counter"
    },
    {
      "id": "ps6",
      "text": "Update max_length with maximum of current max_length and current window size"
    },
    {
      "id": "ps7",
      "text": "Return max_length as the maximum consecutive ones possible"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "Hey! Ready to master another powerful sliding window technique? After conquering longest-repeating-character-replacement, you're perfectly set up for \"Max Consecutive Ones III\"! \n\nThis problem follows the classic sliding window pattern with constraint tracking - you'll maintain a flexible window while keeping track of how many zeros you can flip to ones. It's the same expand-and-contract dance you know, but now you're managing a \"flip budget\" instead of character frequencies.\n\nHere are the 3 key skills you'll develop:\n‚Ä¢ **Constraint-based window management** - Learn to track and enforce limits within your sliding window\n‚Ä¢ **State transformation thinking** - Master the concept of \"flipping\" elements to optimize your window\n‚Ä¢ **Greedy window expansion** - Build intuition for when to grow vs. shrink your window based on constraints\n\nYou've got the sliding window foundation down pat, and this problem will sharpen your ability to handle constrained optimization scenarios. These skills transfer beautifully to many other array and string problems!\n\nLet's dive in!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Before we dive into the problem, which programming language would you like to use?\n\nThis will help me make sure you have the right building blocks.",
      "choices": [
        {
          "label": "üíõ JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "üêç Python",
          "next": "prereq-check-python"
        },
        {
          "label": "‚òï Java",
          "next": "prereq-check-java"
        },
        {
          "label": "‚ö° C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "üíô TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in JavaScript, you'll need to know:\n- **Sliding window concept** - Technique using two pointers to maintain a dynamic window over array elements\n- **Arrays** - Understanding array indexing, iteration, and element access patterns\n- **Two pointers** - Method using left and right pointers to track window boundaries\n- **Conditional logic** - Ability to handle window expansion and contraction based on constraints\n- **Math.max** - Finding maximum value to track the longest valid window size\n\nDo you feel confident with these JavaScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-js"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Python, you'll need to know:\n- **Sliding window concept** - Technique using two pointers to maintain a dynamic window over array elements\n- **Arrays** - Understanding array indexing, iteration, and element access patterns\n- **Two pointers** - Method using left and right pointers to track window boundaries\n- **Conditional logic** - Ability to handle window expansion and contraction based on constraints\n- **Math.max** - Finding maximum value to track the longest valid window size\n\nDo you feel confident with these Python concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-python"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Java, you'll need to know:\n- **Sliding window concept** - Technique using two pointers to maintain a dynamic window over array elements\n- **Arrays** - Understanding array indexing, iteration, and element access patterns\n- **Two pointers** - Method using left and right pointers to track window boundaries\n- **Conditional logic** - Ability to handle window expansion and contraction based on constraints\n- **Math.max** - Finding maximum value to track the longest valid window size\n\nDo you feel confident with these Java concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-java"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in C++, you'll need to know:\n- **Sliding window concept** - Technique using two pointers to maintain a dynamic window over array elements\n- **Arrays** - Understanding array indexing, iteration, and element access patterns\n- **Two pointers** - Method using left and right pointers to track window boundaries\n- **Conditional logic** - Ability to handle window expansion and contraction based on constraints\n- **Math.max** - Finding maximum value to track the longest valid window size\n\nDo you feel confident with these C++ concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in TypeScript, you'll need to know:\n- **Sliding window concept** - Technique using two pointers to maintain a dynamic window over array elements\n- **Arrays** - Understanding array indexing, iteration, and element access patterns\n- **Two pointers** - Method using left and right pointers to track window boundaries\n- **Conditional logic** - Ability to handle window expansion and contraction based on constraints\n- **Math.max** - Finding maximum value to track the longest valid window size\n\nDo you feel confident with these TypeScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "Perfect! Now let's understand what the Max Consecutive Ones III problem asks for.\n\nImagine you're organizing your bookshelf and want the longest possible section of upright books, but you're allowed to use at most K bookends to prop up fallen books. You'd use a sliding window approach - expand your section by adding more books and using bookends when needed, but shrink from the left when you've used too many bookends, always tracking the longest organized section you've achieved.\n\n# Max Consecutive Ones III - Problem Statement\n\n## What does it ask?\n\nYou're given a binary array (only 0s and 1s) and a number `k`. The question is: **what's the longest sequence of consecutive 1s you can create if you're allowed to flip at most `k` zeros to ones?**\n\nThink of it like this - you have a string of 0s and 1s, and you get `k` \"magic flips\" to turn any 0 into a 1. Your goal is to use these flips strategically to create the longest possible streak of 1s.\n\n## Let's walk through the example\n\nGiven: `nums = [1,1,1,0,0,0,1,1,1,1,0]` and `k = 2`\n\nLet me show you the array with positions:\n```\nIndex: 0 1 2 3 4 5 6 7 8 9 10\nValue: 1 1 1 0 0 0 1 1 1 1  0\n```\n\nSince we can flip 2 zeros, let's think about where to use them:\n\n**Option 1:** Flip the zeros at positions 3 and 4\n- Result: `[1,1,1,1,1,0,1,1,1,1,0]`\n- Best consecutive sequence: positions 0-4 = length 5\n\n**Option 2:** Flip the zeros at positions 5 and 10\n- Result: `[1,1,1,0,0,1,1,1,1,1,1]`\n- Best consecutive sequence: positions 5-10 = length 6 ‚úì\n\n**Option 3:** Flip zeros at positions 4 and 5\n- Result: `[1,1,1,0,1,1,1,1,1,1,0]`\n- Best consecutive sequence: positions 4-9 = length 6 ‚úì\n\nThe answer is **6** because that's the longest consecutive sequence of 1s we can achieve.\n\n## Why does this work?\n\nThe key insight is that we're looking for the **longest subarray that contains at most `k` zeros**. Once we find that subarray, we can flip all the zeros in it to get our answer.\n\nIn our example, the subarray from index 5 to 10 `[0,1,1,1,1,0]` contains exactly 2 zeros (our limit) and has length 6. When we flip those 2 zeros, we get 6 consecutive ones.\n\nThis transforms the problem from \"flip zeros optimally\" to \"find the longest window with at most k zeros\" - which is much easier to solve with techniques like sliding window!",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Given an array of 0s and 1s, you can flip at most k zeros to ones. To find the maximum length of consecutive 1s, what approach should you use?",
      "choices": [
        {
          "label": "Try all possible combinations of flipping k zeros and find the longest consecutive 1s sequence",
          "next": "wrong-choice"
        },
        {
          "label": "Use sliding window technique: expand right while tracking flipped zeros ‚â§ k, contract left when exceeded",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-choice",
      "mentorSays": "This brute force approach has exponential time complexity O(C(n,k) * n) where C(n,k) is combinations of choosing k zeros from n positions. While it would work for small inputs, it's inefficient because it doesn't leverage the fact that we're looking for a contiguous subarray - we don't need to try all possible combinations when we can use a sliding window to efficiently explore all valid subarrays.",
      "action": "next",
      "next": "pattern-recognition"
    },
    {
      "stepId": "pattern-recognition",
      "mentorSays": "### Pattern Recognition: Constraint-Based Sliding Window\n\n**This problem follows the \"at most k constraint\" sliding window pattern:**\n- **Variable window** - Window size can grow and shrink\n- **Constraint tracking** - Track count of zeros (or constraint violations)\n- **Expand-contract** - Expand when constraint satisfied, contract when violated\n\n**Similar problems:**\n- Longest Repeating Character Replacement (similar constraint pattern)\n- Subarray Product Less Than K (different constraint)\n- Minimum Window Substring (different optimization)\n\n**Key insight:** We're looking for the longest subarray with at most `k` zeros. Sliding window efficiently explores all such subarrays.",
      "action": "next",
      "next": "invariant"
    },
    {
      "stepId": "invariant",
      "mentorSays": "### Invariant: Window Contains At Most k Zeros\n\n**Invariant maintained throughout:**\n- **Window validity:** `zeroCount <= k` in current window\n- **zeroCount:** Number of zeros in window `[left, right]`\n- **maxLength:** Longest valid window seen so far\n\n**Why this works:**\n- A window is valid if it contains at most `k` zeros\n- We can flip all zeros in a valid window to get consecutive 1s\n- We expand when `zeroCount <= k`, contract when `zeroCount > k`\n\n**Invariant guarantee:** At each step, if the window is valid (`zeroCount <= k`), then we can flip all zeros in the window to create `window_size` consecutive 1s. The `maxLength` tracks the maximum such window size found.",
      "action": "next",
      "next": "state-definition"
    },
    {
      "stepId": "state-definition",
      "mentorSays": "### State Definition: Window State with Zero Count\n\n**State variables:**\n- **`left`** - Start index of current window\n- **`right`** - End index of current window\n- **`zeroCount`** - Number of zeros in current window\n- **`maxLength`** - Maximum valid window size seen so far\n\n**State transitions:**\n1. **Expand:** Add `nums[right]` to window\n   - If `nums[right] == 0`, increment `zeroCount`\n   - If `zeroCount <= k`, window is valid, update `maxLength`\n2. **Contract:** Remove `nums[left]` from window\n   - If `nums[left] == 0`, decrement `zeroCount`\n   - Continue until `zeroCount <= k`\n\n**State validity:** Window is valid when `zeroCount <= k`.",
      "action": "next",
      "next": "why-alternatives-fail"
    },
    {
      "stepId": "why-alternatives-fail",
      "mentorSays": "### Why Alternative Approaches Fail\n\n**Approach 1: Try All Combinations of Flipping k Zeros**\n- **Why it fails:** Exponential time O(C(n,k) * n)\n- **Issue:** Too many combinations, especially for large k\n- **Better:** Sliding window explores all valid subarrays in O(n) time\n\n**Approach 2: Greedy Flip First k Zeros**\n- **Why it fails:** Doesn't guarantee optimal contiguous subarray\n- **Issue:** May miss longer valid subarrays by making suboptimal choices\n- **Better:** Expand-contract strategy finds the maximum valid window\n\n**Approach 3: Precompute Zero Positions, Try All Ranges**\n- **Why it fails:** O(n¬≤) time complexity\n- **Issue:** Still need to check all ranges, inefficient\n- **Better:** Sliding window processes in single pass O(n)\n\n**Our approach wins because:** Sliding window efficiently explores all valid subarrays (at most k zeros) in a single pass, tracking the maximum length, achieving optimal O(n) time complexity.",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "The key insight is to use a **sliding window** approach where we track the count of **zeros flipped** within our current window. We **expand the right boundary** while the number of flipped zeros is ‚â§ k, and **contract the left boundary** when it exceeds k. This works because at any moment, our window represents the longest valid subarray ending at the current position, and by maintaining this invariant, we naturally find the global maximum. For example, with array [1,1,0,0,1,1,1,0,1,1] and k=2, we can flip the zeros at indices 2,3 to get 6 consecutive ones, which our sliding window discovers by expanding until it has flipped 2 zeros, then contracting when it would need to flip a third.",
      "action": "next",
      "next": "walkthrough",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "Let's trace through `nums=[1,1,1,0,0,0,1,1,1,1,0], k=2`:\n\n- Step 1: Initialize left=0, right=0, zeros_count=0, max_length=0\n- Step 2: right=0, nums[0]=1, zeros_count=0, window=[1], length=1, max_length=1\n- Step 3: right=1, nums[1]=1, zeros_count=0, window=[1,1], length=2, max_length=2\n- Step 4: right=2, nums[2]=1, zeros_count=0, window=[1,1,1], length=3, max_length=3\n- Step 5: right=3, nums[3]=0, zeros_count=1, window=[1,1,1,0], length=4, max_length=4\n- Step 6: right=4, nums[4]=0, zeros_count=2, window=[1,1,1,0,0], length=5, max_length=5\n- Step 7: right=5, nums[5]=0, zeros_count=3 > k, shrink window from left\n- Step 8: left=0‚Üí3, remove [1,1,1], zeros_count=2, window=[0,0,0], length=3\n- Step 9: right=6, nums[6]=1, zeros_count=2, window=[0,0,0,1], length=4\n- Step 10: right=7, nums[7]=1, zeros_count=2, window=[0,0,0,1,1], length=5\n- Step 11: right=8, nums[8]=1, zeros_count=2, window=[0,0,0,1,1,1], length=6, max_length=6\n- Step 12: right=9, nums[9]=1, zeros_count=2, window=[0,0,0,1,1,1,1], length=7, max_length=7\n- Step 13: right=10, nums[10]=0, zeros_count=3 > k, shrink window from left\n- Step 14: left=3‚Üí5, remove [0,0], zeros_count=1, window=[0,1,1,1,1,0], length=6\n\n**Final: 6 (flip 2 zeros)**",
      "action": "next",
      "next": "pseudocode-step",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "Here's our plan written as pseudocode:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now let's translate this into JavaScript, building it step by step.\n\nRemember: we'll add just 1-3 lines at a time!",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Initialize function and variables to track window boundaries and zero count\n\n```javascript\nfunction findMaxConsecutiveOnes(nums, k) {\n    let left = 0, right = 0, zeroCount = 0;\n}\n```",
      "action": "next",
      "next": "code-02",
      "pseudocodeLineIds": [
        "ps1"
      ],
      "example": "let left = 0, right = 0, zeroCount = 0;"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Initialize variable to track maximum window size found\n\n```javascript\nfunction findMaxConsecutiveOnes(nums, k) {\n    let left = 0, right = 0, zeroCount = 0;\n    let maxLength = 0;\n}\n```",
      "action": "next",
      "next": "code-03",
      "pseudocodeLineIds": [
        "ps1"
      ],
      "example": "let maxLength = 0;"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Start main loop to expand right boundary through entire array\n\n```javascript\nfunction findMaxConsecutiveOnes(nums, k) {\n    let left = 0, right = 0, zeroCount = 0;\n    let maxLength = 0;\n    \n    while (right < nums.length) {\n    }\n}\n```",
      "action": "next",
      "next": "code-04",
      "pseudocodeLineIds": [
        "ps2"
      ],
      "example": "while (right < nums.length) {"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Count zeros as we expand the window by incrementing zeroCount when encountering 0\n\n```javascript\nfunction findMaxConsecutiveOnes(nums, k) {\n    let left = 0, right = 0, zeroCount = 0;\n    let maxLength = 0;\n    \n    while (right < nums.length) {\n        if (nums[right] === 0) zeroCount++;\n    }\n}\n```",
      "action": "next",
      "next": "code-05",
      "pseudocodeLineIds": [
        "ps3"
      ],
      "example": "if (nums[right] === 0) zeroCount++;"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Contract window from left when zero flips exceed limit k\n\n```javascript\nfunction findMaxConsecutiveOnes(nums, k) {\n    let left = 0, right = 0, zeroCount = 0;\n    let maxLength = 0;\n    \n    while (right < nums.length) {\n        if (nums[right] === 0) zeroCount++;\n        \n        while (zeroCount > k) {\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-06",
      "pseudocodeLineIds": [
        "ps4"
      ],
      "example": "while (zeroCount > k) {"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Shrink window by moving left pointer and updating zero count\n\n```javascript\nfunction findMaxConsecutiveOnes(nums, k) {\n    let left = 0, right = 0, zeroCount = 0;\n    let maxLength = 0;\n    \n    while (right < nums.length) {\n        if (nums[right] === 0) zeroCount++;\n        \n        while (zeroCount > k) {\n            if (nums[left] === 0) zeroCount--;\n            left++;\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-07",
      "pseudocodeLineIds": [
        "ps4"
      ],
      "example": "if (nums[left] === 0) zeroCount--;\nleft++;"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Update maximum length with current valid window size\n\n```javascript\nfunction findMaxConsecutiveOnes(nums, k) {\n    let left = 0, right = 0, zeroCount = 0;\n    let maxLength = 0;\n    \n    while (right < nums.length) {\n        if (nums[right] === 0) zeroCount++;\n        \n        while (zeroCount > k) {\n            if (nums[left] === 0) zeroCount--;\n            left++;\n        }\n        \n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n}\n```",
      "action": "next",
      "next": "code-08",
      "pseudocodeLineIds": [
        "ps5"
      ],
      "example": "maxLength = Math.max(maxLength, right - left + 1);"
    },
    {
      "stepId": "code-08",
      "mentorSays": "Move right pointer to expand window for next iteration\n\n```javascript\nfunction findMaxConsecutiveOnes(nums, k) {\n    let left = 0, right = 0, zeroCount = 0;\n    let maxLength = 0;\n    \n    while (right < nums.length) {\n        if (nums[right] === 0) zeroCount++;\n        \n        while (zeroCount > k) {\n            if (nums[left] === 0) zeroCount--;\n            left++;\n        }\n        \n        maxLength = Math.max(maxLength, right - left + 1);\n        right++;\n    }\n}\n```",
      "action": "next",
      "next": "code-09",
      "pseudocodeLineIds": [
        "ps2"
      ],
      "example": "right++;"
    },
    {
      "stepId": "code-09",
      "mentorSays": "Return the maximum consecutive ones length found\n\n```javascript\nfunction findMaxConsecutiveOnes(nums, k) {\n    let left = 0, right = 0, zeroCount = 0;\n    let maxLength = 0;\n    \n    while (right < nums.length) {\n        if (nums[right] === 0) zeroCount++;\n        \n        while (zeroCount > k) {\n            if (nums[left] === 0) zeroCount--;\n            left++;\n        }\n        \n        maxLength = Math.max(maxLength, right - left + 1);\n        right++;\n    }\n    \n    return maxLength;\n}\n```",
      "action": "next",
      "next": "common-mistakes",
      "pseudocodeLineIds": [
        "ps6"
      ],
      "example": "return maxLength;"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "Great work mastering the sliding window with constraint tracking pattern in \"Max Consecutive Ones III\"! You've shown excellent skill in maintaining a flexible window while tracking the number of flips allowed, demonstrating how powerful this technique is for optimization problems. Next, we'll tackle \"Binary Tree Inorder Traversal\" where you'll explore tree traversal algorithms and deepen your understanding of recursive and iterative approaches to navigate binary tree structures.\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}