{
  "id": "cheapest-flights-k-stops",
  "title": "Cheapest Flights Within K Stops - Constrained Shortest Paths",
  "pattern": "bellman-ford-constrained",
  "difficulty": "medium",
  "language": "javascript",
  "status": "AI-GENERATED-V2-DIRECT",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 62,
    "tier": "MASTERY-I",
    "lessonOrderTag": "MASTERY-I-62",
    "introduces": [
      "bellman-ford",
      "constrained-shortest-path",
      "dynamic-programming-graphs"
    ],
    "assumesAlreadyTaught": [
      "dijkstra-algorithm",
      "graphs",
      "bfs"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "partition-equal-subset-sum"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Create a DP array where dp[i] = minimum cost to reach each city"
    },
    {
      "id": "ps2",
      "text": "Initialize all cities to infinity, source city to 0"
    },
    {
      "id": "ps3",
      "text": "For each stop from 0 to k:"
    },
    {
      "id": "ps4",
      "text": "  Create a temporary copy of current DP array"
    },
    {
      "id": "ps5",
      "text": "  For each flight [from, to, price]:"
    },
    {
      "id": "ps6",
      "text": "    If we can reach 'from' city:"
    },
    {
      "id": "ps7",
      "text": "      Update temp[to] = min(temp[to], dp[from] + price)"
    },
    {
      "id": "ps8",
      "text": "  Copy temp array back to dp"
    },
    {
      "id": "ps9",
      "text": "Return dp[destination], or -1 if still infinity"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "# Welcome to Cheapest Flights Within K Stops! ‚úàÔ∏è\n\nYou're about to learn a powerful variation of shortest path algorithms: **finding paths with constraints**.\n\n## What You'll Master:\n\n- Understanding the Bellman-Ford algorithm\n- Handling path constraints (maximum number of stops)\n- Dynamic programming on graphs\n- Real-world flight booking optimization\n\nThis technique is used in flight booking systems, network routing with hop limits, and resource-constrained pathfinding!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Which programming language would you like to use for this lesson?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "Python",
          "next": "prereq-check-python"
        },
        {
          "label": "Java",
          "next": "prereq-check-java"
        },
        {
          "label": "C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "To solve this in JavaScript, you'll need to know:\n\n- **Graph shortest paths** (Dijkstra's algorithm)\n- **Dynamic programming** basics\n- **Array operations** (copying, iterating)\n- **BFS concepts**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-js"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "To solve this in Python, you'll need to know:\n\n- **Graph shortest paths** (Dijkstra's algorithm)\n- **Dynamic programming** basics\n- **List operations** (copying, iterating)\n- **BFS concepts**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-python"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "To solve this in Java, you'll need to know:\n\n- **Graph shortest paths** (Dijkstra's algorithm)\n- **Dynamic programming** basics\n- **Arrays class** (copying, filling)\n- **BFS concepts**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-java"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "To solve this in C++, you'll need to know:\n\n- **Graph shortest paths** (Dijkstra's algorithm)\n- **Dynamic programming** basics\n- **Vector operations** (copying, filling)\n- **BFS concepts**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "To solve this in TypeScript, you'll need to know:\n\n- **Graph shortest paths** (Dijkstra's algorithm)\n- **Dynamic programming** basics\n- **Array operations** (copying, iterating)\n- **BFS concepts**\n\nDo you feel confident with these concepts?",
      "choices": [
        {
          "label": "Yes, I'm ready!",
          "next": "problem-understanding"
        },
        {
          "label": "No, I need a refresher",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "Show me what I need to review",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "# The Problem: Cheapest Flights Within K Stops üé´\n\n**Real-world analogy:** You're booking a flight and want the cheapest route, but you don't want too many layovers! You're willing to make at most K stops (connecting flights) to get from your source city to your destination. Some routes might be cheaper but require more stops - we need to find the best option within our constraint.\n\n## The Challenge:\n\nYou have `n` cities connected by flights. You're given:\n- `flights`: array where `flights[i] = [from, to, price]`\n- `src`: source city\n- `dst`: destination city  \n- `k`: maximum number of stops allowed\n\nFind the **cheapest price** from `src` to `dst` with at most `k` stops. Return `-1` if no such route exists.\n\n## Example:\n```\nn = 4\nflights = [[0,1,100], [1,2,100], [2,0,100], [1,3,600], [2,3,200]]\nsrc = 0, dst = 3, k = 1\n\nOutput: 700\n```\n\nPath: 0 ‚Üí 1 (cost 100) ‚Üí 3 (cost 600) = 700\nAlternative: 0 ‚Üí 1 ‚Üí 2 ‚Üí 3 would cost 400, but requires 2 stops (exceeds k=1)",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "# ü§î Why Can't We Use Dijkstra's?\n\nRemember Dijkstra's algorithm from the last lesson? It finds the absolute shortest path.\n\n**Question:** What's the problem with using Dijkstra's algorithm for this problem?",
      "choices": [
        {
          "label": "Dijkstra's doesn't work with negative weights",
          "next": "wrong-negative"
        },
        {
          "label": "Dijkstra's finds the shortest path by cost, but ignores the number of stops constraint",
          "next": "core-idea"
        },
        {
          "label": "Dijkstra's is too slow for this problem",
          "next": "wrong-slow"
        }
      ]
    },
    {
      "stepId": "wrong-negative",
      "mentorSays": "True, Dijkstra's doesn't handle negative weights! But that's not our issue here - all our flight prices are positive.\n\nThe real problem is different...",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "wrong-slow",
      "mentorSays": "Actually, Dijkstra's has good time complexity! That's not the issue.\n\nThe problem is about what it optimizes for versus what we need...",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "# The Key Insight: Bellman-Ford with Constraints üí°\n\nDijkstra's algorithm finds the **absolute cheapest** path, but we have a constraint: **at most k stops**.\n\nThe cheapest path might require too many stops! We need something that:\n1. Respects the maximum stops constraint\n2. Finds the cheapest path within that constraint\n\n## Enter Bellman-Ford (Modified):\n\n**Core idea:** Build up solutions layer by layer, where each layer represents one additional stop.\n\n- **DP approach:** `dp[i]` = cheapest way to reach city `i`\n- **Iterate k+1 times:** Each iteration adds one more potential stop\n- **Relaxation:** For each flight, if we can afford to take it, update the destination cost\n\n## Why This Works:\n\nAfter iteration 0: We know costs to reach cities with 0 stops (just source)\nAfter iteration 1: We know costs with at most 1 stop\nAfter iteration k: We know costs with at most k stops ‚úÖ",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "# Let's Walk Through an Example üö∂\n\n```\nflights = [[0,1,100], [1,2,100], [2,0,100], [1,3,600], [2,3,200]]\nsrc = 0, dst = 3, k = 1\n```\n\n**Initial:** dp = [0, ‚àû, ‚àû, ‚àû]\n\n**Iteration 0 (k=0, direct flights only):**\n- Process [0,1,100]: dp[1] = min(‚àû, 0+100) = 100\n- Process [1,2,100]: Can't use (city 1 unreachable at start)\n- Process [2,0,100]: Can't use\n- Process [1,3,600]: Can't use\n- Process [2,3,200]: Can't use\n- Result: dp = [0, 100, ‚àû, ‚àû]\n\n**Iteration 1 (k=1, one stop allowed):**\n- Use previous dp as baseline\n- Process [0,1,100]: dp[1] = min(100, 0+100) = 100 (same)\n- Process [1,2,100]: dp[2] = min(‚àû, 100+100) = 200 ‚úì\n- Process [2,0,100]: dp[0] = min(0, ‚àû+100) = 0 (same)\n- Process [1,3,600]: dp[3] = min(‚àû, 100+600) = 700 ‚úì\n- Process [2,3,200]: Can't use (city 2 was ‚àû before this iteration)\n- Result: dp = [0, 100, 200, 700]\n\n**Answer:** dp[3] = 700",
      "action": "next",
      "next": "pseudocode-step"
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "# Here's Our Battle Plan üìã\n\nLet's break down the Bellman-Ford approach:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7",
        "ps8",
        "ps9"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "# Time to Code! üíª\n\nWe'll build this solution step by step, using dynamic programming to respect our stop constraint.",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Let's start with the function signature and initialize our DP array:\n\n```javascript\nfunction findCheapestPrice(n, flights, src, dst, k) {\n    // Initialize costs to infinity, source to 0\n    let dp = new Array(n).fill(Infinity);\n    dp[src] = 0;\n```\n\nWe track the minimum cost to reach each city.",
      "action": "next",
      "next": "code-02",
      "example": "function findCheapestPrice(n, flights, src, dst, k) {\n    let dp = new Array(n).fill(Infinity);\n    dp[src] = 0;"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Now iterate k+1 times (0 stops, 1 stop, ..., k stops):\n\n```javascript\n    // k+1 iterations: allow up to k stops\n    for (let i = 0; i <= k; i++) {\n```\n\nEach iteration represents adding one more potential stop to our route.",
      "action": "next",
      "next": "code-03",
      "example": "    for (let i = 0; i <= k; i++) {"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Create a temporary copy of the current DP state:\n\n```javascript\n        const temp = [...dp];\n```\n\nThis is crucial! We need to use the previous iteration's values, not values we're updating in this iteration.",
      "action": "next",
      "next": "code-04",
      "example": "        const temp = [...dp];"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Process each flight and try to relax edges:\n\n```javascript\n        for (const [from, to, price] of flights) {\n```\n\nFor each flight, check if we can improve the cost to the destination.",
      "action": "next",
      "next": "code-05",
      "example": "        for (const [from, to, price] of flights) {"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Only update if we can actually reach the 'from' city:\n\n```javascript\n            if (dp[from] !== Infinity) {\n                temp[to] = Math.min(temp[to], dp[from] + price);\n            }\n```\n\nIf `dp[from]` is Infinity, we can't use this flight yet. Otherwise, we try to update the destination cost.",
      "action": "next",
      "next": "code-06",
      "example": "            if (dp[from] !== Infinity) {\n                temp[to] = Math.min(temp[to], dp[from] + price);\n            }"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Close the flights loop and copy temp back to dp:\n\n```javascript\n        }\n        dp = temp;\n    }\n```\n\nAfter processing all flights for this iteration, update our DP array for the next iteration.",
      "action": "next",
      "next": "code-07",
      "example": "        }\n        dp = temp;\n    }"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Finally, return the result:\n\n```javascript\n    return dp[dst] === Infinity ? -1 : dp[dst];\n}\n```\n\nIf the destination is still Infinity, it's unreachable within k stops. Otherwise, return the minimum cost!",
      "action": "next",
      "next": "complexity-analysis",
      "example": "    return dp[dst] === Infinity ? -1 : dp[dst];\n}"
    },
    {
      "stepId": "complexity-analysis",
      "mentorSays": "# Complexity Analysis üìä\n\n## Time Complexity: O(k √ó E)\n- k = maximum number of stops\n- E = number of flights (edges)\n- We iterate k+1 times, and in each iteration process all E flights\n\n## Space Complexity: O(n)\n- n = number of cities\n- We use two arrays of size n (dp and temp)\n- The temp array could be eliminated with careful indexing, but it makes the code clearer\n\n## Why This Works:\n\nBellman-Ford traditionally runs n-1 iterations to guarantee shortest paths. Here we run k+1 iterations because:\n- We only care about paths with at most k stops\n- Each iteration adds one more \"hop\" to our possible paths\n- This gives us exactly what we need while being efficient!",
      "action": "next",
      "next": "bellman-vs-dijkstra"
    },
    {
      "stepId": "bellman-vs-dijkstra",
      "mentorSays": "# Bellman-Ford vs Dijkstra ü§î\n\n**When to use Bellman-Ford:**\n- Negative edge weights (Dijkstra can't handle these)\n- Need to detect negative cycles\n- Have constraints on path length (like our k stops)\n- Simpler implementation\n\n**When to use Dijkstra:**\n- All edges are non-negative\n- Need absolute shortest path\n- Want better performance: O(E log V) vs O(V √ó E)\n\n**Our problem:** Even though edges are positive, we have a constraint (k stops) that makes Bellman-Ford the right choice!",
      "action": "next",
      "next": "alternative-approach"
    },
    {
      "stepId": "alternative-approach",
      "mentorSays": "# Alternative: Modified Dijkstra üéØ\n\nYou could also solve this with modified Dijkstra where state = (city, stops_used):\n\n```javascript\n// Priority queue with [cost, city, stops]\n// Track visited as [city][stops] pairs\n// More complex but also works!\n```\n\n**Tradeoffs:**\n- Dijkstra approach: Potentially faster with good heap\n- Bellman-Ford approach: Simpler code, easier to understand\n- Both are valid for interviews - choose what you're comfortable with!\n\nBellman-Ford is cleaner for this specific problem.",
      "action": "next",
      "next": "edge-cases"
    },
    {
      "stepId": "edge-cases",
      "mentorSays": "# Edge Cases to Consider üéØ\n\n1. **Source equals destination:** k = 0, already at destination ‚Üí return 0\n\n2. **No path exists:** Some cities unreachable ‚Üí return -1\n\n3. **k = 0:** Only direct flights allowed (no stops)\n\n4. **Cycles in graph:** Our algorithm handles these correctly (won't infinite loop)\n\n5. **Multiple flights same route:** Take the cheapest one (handled by min operation)\n\nOur implementation handles all these naturally!",
      "action": "next",
      "next": "common-mistakes"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "# Congratulations! üéâ\n\nYou've mastered **constrained shortest path** problems using Bellman-Ford!\n\n## What You Learned:\n\n‚úÖ Bellman-Ford algorithm for shortest paths\n‚úÖ Handling path constraints with dynamic programming\n‚úÖ When to choose Bellman-Ford over Dijkstra\n‚úÖ Building solutions layer by layer with DP\n\n## Next Steps:\n\nReady for a different type of challenge? The next lesson covers **Partition Equal Subset Sum** - a classic dynamic programming problem about dividing arrays. It's a different domain but uses similar DP thinking!\n\nKeep practicing shortest path problems - they're everywhere in real-world systems!\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}