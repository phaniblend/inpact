{
  "id": "trapping-rain-water",
  "title": "Trapping Rain Water",
  "pattern": "two pointers (max tracking)",
  "difficulty": "hard",
  "language": "javascript",
  "status": "AI-GENERATED-V2-BATCH",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 54,
    "tier": "EXPERT",
    "lessonOrderTag": "EXPERT-54",
    "introduces": [
      "water-trapping",
      "min-of-maxes",
      "pointer-convergence"
    ],
    "assumesAlreadyTaught": [
      "two-pointers",
      "Math.max",
      "Math.min"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "daily-temperatures"
    ]
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Initialize left = 0, right = array.length - 1, leftMax = 0, rightMax = 0, totalWater = 0"
    },
    {
      "id": "ps2",
      "text": "While left < right:"
    },
    {
      "id": "ps3",
      "text": "  If height[left] < height[right]:"
    },
    {
      "id": "ps4",
      "text": "    If height[left] >= leftMax: leftMax = height[left]"
    },
    {
      "id": "ps5",
      "text": "    Else: totalWater += (leftMax - height[left]), increment left"
    },
    {
      "id": "ps6",
      "text": "  Else:"
    },
    {
      "id": "ps7",
      "text": "    If height[right] >= rightMax: rightMax = height[right]"
    },
    {
      "id": "ps8",
      "text": "    Else: totalWater += (rightMax - height[right]), decrement right"
    },
    {
      "id": "ps9",
      "text": "Return totalWater"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "# INPACT Lesson: Trapping Rain Water\n\n## Opening\n\nHey! Ready for another classic two-pointer challenge? Today we're diving into \"Trapping Rain Water\" - a problem that beautifully builds on what you learned with the largest rectangle in histogram. \n\nInstead of finding maximum areas, we're now calculating how much water can be trapped between elevation bars after it rains. Think of it like having a series of walls of different heights - water will pool in the valleys between taller walls on either side.\n\n## Two Pointers Approach: Max Tracking Strategy\n\nThe key insight is using **two pointers with maximum tracking**:\n\n- **Left pointer** starts at the beginning, **right pointer** starts at the end\n- Track `left_max` and `right_max` - the tallest bars seen so far from each direction  \n- Move the pointer with the smaller maximum height inward\n- At each step, if current height is less than the maximum from that side, we can trap water\n- The amount trapped = `max_height - current_height`\n\nThe brilliant part: we only need to know the smaller of the two maximums to determine how much water can be trapped at any position!\n\n## Skills You'll Master\n\n1. **Bidirectional Maximum Tracking** - Maintaining running maximums from both ends simultaneously\n2. **Water Level Calculation** - Determining trapped water based on surrounding height constraints  \n3. **Pointer Movement Strategy** - Deciding which pointer to advance based on comparative maximum values\n\nLet's get started trapping some rain water!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Which programming language would you like to use?",
      "choices": [
        {
          "label": "üíõ JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "üêç Python",
          "next": "prereq-check-python"
        },
        {
          "label": "‚òï Java",
          "next": "prereq-check-java"
        },
        {
          "label": "‚ö° C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "üíô TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "To solve this in JavaScript, you'll need:\n- **Array_traversal** - Understanding how to iterate through arrays and access elements by index\n- **Prefix_suffix_arrays** - Knowledge of precomputing maximum values from left and right using auxiliary arrays\n- **Stack_operations** - Familiarity with stack data structure for maintaining elements in specific order\n- **Dynamic_programming_concepts** - Understanding optimal substructure and how previous computations affect current decisions\n\nConfident with these?",
      "choices": [
        {
          "label": "Yes, I know all",
          "next": "problem-understanding"
        },
        {
          "label": "No, explain",
          "next": "teach-prereqs-js"
        },
        {
          "label": "Some, not all",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "To solve this in Python, you'll need:\n- **Array_traversal** - Understanding how to iterate through arrays and access elements by index\n- **Prefix_suffix_arrays** - Knowledge of precomputing maximum values from left and right using auxiliary arrays\n- **Stack_operations** - Familiarity with stack data structure for maintaining elements in specific order\n- **Dynamic_programming_concepts** - Understanding optimal substructure and how previous computations affect current decisions\n\nConfident with these?",
      "choices": [
        {
          "label": "Yes, I know all",
          "next": "problem-understanding"
        },
        {
          "label": "No, explain",
          "next": "teach-prereqs-python"
        },
        {
          "label": "Some, not all",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "To solve this in Java, you'll need:\n- **Array_traversal** - Understanding how to iterate through arrays and access elements by index\n- **Prefix_suffix_arrays** - Knowledge of precomputing maximum values from left and right using auxiliary arrays\n- **Stack_operations** - Familiarity with stack data structure for maintaining elements in specific order\n- **Dynamic_programming_concepts** - Understanding optimal substructure and how previous computations affect current decisions\n\nConfident with these?",
      "choices": [
        {
          "label": "Yes, I know all",
          "next": "problem-understanding"
        },
        {
          "label": "No, explain",
          "next": "teach-prereqs-java"
        },
        {
          "label": "Some, not all",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "To solve this in C++, you'll need:\n- **Array_traversal** - Understanding how to iterate through arrays and access elements by index\n- **Prefix_suffix_arrays** - Knowledge of precomputing maximum values from left and right using auxiliary arrays\n- **Stack_operations** - Familiarity with stack data structure for maintaining elements in specific order\n- **Dynamic_programming_concepts** - Understanding optimal substructure and how previous computations affect current decisions\n\nConfident with these?",
      "choices": [
        {
          "label": "Yes, I know all",
          "next": "problem-understanding"
        },
        {
          "label": "No, explain",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "Some, not all",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "To solve this in TypeScript, you'll need:\n- **Array_traversal** - Understanding how to iterate through arrays and access elements by index\n- **Prefix_suffix_arrays** - Knowledge of precomputing maximum values from left and right using auxiliary arrays\n- **Stack_operations** - Familiarity with stack data structure for maintaining elements in specific order\n- **Dynamic_programming_concepts** - Understanding optimal substructure and how previous computations affect current decisions\n\nConfident with these?",
      "choices": [
        {
          "label": "Yes, I know all",
          "next": "problem-understanding"
        },
        {
          "label": "No, explain",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "Some, not all",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "Imagine you're looking at a row of concrete barriers of different heights along a highway after a heavy rainstorm. Water gets trapped in the valleys between taller barriers, forming puddles that can't flow away until the barrier height drops low enough. The amount of trapped rainwater depends on how the heights of adjacent barriers create natural \"containers\" that hold water at different levels.\n\n# Trapping Rain Water\n\nHey! So imagine you're looking at a cross-section view of some terrain with different heights, kind of like a bar chart. When it rains, water gets trapped in the valleys between the higher areas.\n\n## The Problem\nGiven an array of non-negative integers representing the height of terrain at each position, calculate how much rainwater can be trapped after it rains.\n\nThink of it this way: water can only be trapped if there are \"walls\" (higher terrain) on both sides to contain it. The water level at any position will be determined by the shorter of the two containing walls.\n\n## Example\nLet's walk through this step by step with `height = [0,1,0,2,1,0,1,3,2,1,2,1]`:\n\n```\n     3 |       ‚ñà\n     2 |   ‚ñà   ‚ñà ~ ‚ñà ~\n     1 | ‚ñà ~ ‚ñà ~ ‚ñà ‚ñà ~ ‚ñà ‚ñà\n     0 ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà\n       0 1 2 3 4 5 6 7 8 9 10 11\n```\n\nWhere `‚ñà` represents terrain and `~` represents trapped water.\n\nLet's see where water gets trapped:\n- Position 2: Height is 0, bounded by height 1 on left and height 2 on right ‚Üí traps 1 unit\n- Position 4: Height is 1, bounded by height 2 on left and height 3 on right ‚Üí traps 1 unit  \n- Position 5: Height is 0, bounded by height 2 on left and height 3 on right ‚Üí traps 2 units\n- Position 9: Height is 1, bounded by height 3 on left and height 2 on right ‚Üí traps 1 unit\n- Position 10: Height is 2, bounded by height 3 on left and height 2 on right ‚Üí traps 0 units (water would flow out)\n\nWait, let me recalculate position 10: it's bounded by height 2 on the right, so it can't trap water above its own height of 2.\n\nActually, position 9 traps 1 unit (water level 2, terrain height 1).\n\n**Total: 1 + 1 + 2 + 1 + 1 = 6 units** ‚ú®\n\nThe key insight is that for each position, the water level equals the minimum of the maximum heights to its left and right, minus the terrain height at that position.",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "You have an array representing elevation heights [0,1,0,2,1,0,1,3,2,1,2,1]. How would you efficiently calculate the total rainwater that can be trapped?",
      "choices": [
        {
          "label": "For each position, scan left and right to find max heights, then calculate water = min(leftMax, rightMax) - height",
          "next": "wrong-choice"
        },
        {
          "label": "Use two pointers from both ends, maintaining maxLeft and maxRight, moving the pointer with smaller max toward center",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-choice",
      "mentorSays": "While this approach is conceptually correct, it's inefficient with O(n¬≤) time complexity. For each of the n positions, you're scanning through potentially all other positions to find the maximum heights on both sides, leading to redundant calculations.",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "The key insight is that **water level at any position is determined by the minimum of the maximum heights on both sides** - water can only be trapped up to the height of the shorter \"wall.\" Using **two pointers** from both ends, we can efficiently track the maximum heights seen so far from left and right sides. This works because when we have a smaller maximum on one side, we know that side will be the limiting factor for water level, allowing us to **calculate trapped water incrementally** without needing to pre-compute all left and right maximums. The algorithm processes each position once while maintaining the invariant that water trapped = **min(leftMax, rightMax) - currentHeight**.",
      "action": "next",
      "next": "visual-valley-explanation"
    },
    {
      "stepId": "visual-valley-explanation",
      "mentorSays": "### Visual Valley Explanation: Why min(left, right) Works\n\n**Proof intuition:**\n\nImagine a valley with walls on both sides:\n\n```\n    5 |     ‚ñà\n    4 |   ‚ñà ‚ñà\n    3 | ‚ñà ‚ñà ‚ñà\n    2 | ‚ñà ‚ñà ‚ñà\n    1 | ‚ñà ‚ñà ‚ñà\n      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n     left  pos  right\n```\n\n**At position `pos`:**\n- Left wall height = 3\n- Right wall height = 5\n- **Water level = min(3, 5) = 3**\n\n**Why?**\n- Water can only rise to the **shorter wall** (3)\n- If it rose to 4 or 5, it would overflow past the left wall (height 3)\n- The shorter wall is the **limiting factor**\n\n**Visual proof:**\n```\n    5 |     ‚ñà\n    4 |   ‚ñà ‚ñà  ‚Üê Water can't reach here (left wall too short)\n    3 | ‚ñà~‚ñà~‚ñà  ‚Üê Water level stops here\n    2 | ‚ñà~‚ñà~‚ñà\n    1 | ‚ñà~‚ñà~‚ñà\n```\n\n**This prevents memorization-only learning** - you understand WHY the formula works, not just that it works.",
      "action": "next",
      "next": "pattern-recognition",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "pattern-recognition",
      "mentorSays": "### Pattern Recognition: Two Pointers with Max Tracking\n\n**This problem follows the \"two pointers with max tracking\" pattern:**\n- **Two pointers** - One from left, one from right\n- **Max tracking** - Track maximum heights seen from each side\n- **Greedy processing** - Process the side with smaller max first\n- **Incremental calculation** - Calculate water trapped at each position\n\n**Similar problems:**\n- Container With Most Water (similar two-pointer approach)\n- Trapping Rain Water (same problem)\n- Largest Rectangle in Histogram (different but related)\n\n**Key insight:** The side with the smaller maximum is the limiting factor. By processing that side, we can calculate trapped water without needing to know the full picture from the other side.",
      "action": "next",
      "next": "invariant"
    },
    {
      "stepId": "invariant",
      "mentorSays": "### Invariant: Processed Positions Have Correct Water Calculation\n\n**Invariant maintained throughout:**\n- **Left max tracking:** leftMax is the maximum height seen from left side\n- **Right max tracking:** rightMax is the maximum height seen from right side\n- **Water calculation:** For processed positions, water = min(leftMax, rightMax) - height[i]\n- **Pointer movement:** We move the pointer with smaller max toward center\n\n**Why this works:**\n- Initially, leftMax = 0, rightMax = 0\n- When leftMax < rightMax, left side is limiting factor\n- We can calculate water at left position: min(leftMax, rightMax) - height[left]\n- After processing, we update leftMax and move left pointer\n- Same logic applies when rightMax < leftMax\n\n**Invariant guarantee:** After processing a position, its water calculation is correct. When pointers meet, all positions have been processed and total water is calculated.",
      "action": "next",
      "next": "state-definition"
    },
    {
      "stepId": "state-definition",
      "mentorSays": "### State Definition: Two Pointer Water Trapping State\n\n**State variables:**\n- **`left`** - Left pointer (starts at 0)\n- **`right`** - Right pointer (starts at n-1)\n- **`leftMax`** - Maximum height seen from left side\n- **`rightMax`** - Maximum height seen from right side\n- **`water`** - Total water trapped so far\n\n**State transitions:**\n1. **Initialize:** left = 0, right = n-1, leftMax = 0, rightMax = 0, water = 0\n2. **Loop:** While left < right:\n   - If height[left] < height[right]:\n     - leftMax = max(leftMax, height[left])\n     - water += leftMax - height[left]\n     - left++\n   - Else:\n     - rightMax = max(rightMax, height[right])\n     - water += rightMax - height[right]\n     - right--\n3. **Result:** Return water\n\n**State validity:** After loop, water contains total trapped water.",
      "action": "next",
      "next": "why-alternatives-fail"
    },
    {
      "stepId": "why-alternatives-fail",
      "mentorSays": "### Why Alternative Approaches Fail\n\n**Approach 1: For Each Position, Find Left and Right Max**\n- **Why it fails:** O(n¬≤) time complexity\n- **Issue:** For each position, scan all positions to find maxes\n- **Better:** Two pointers track maxes incrementally, O(n) time\n\n**Approach 2: Precompute Left and Right Max Arrays**\n- **Why it doesn't fail:** Actually works, but uses O(n) extra space\n- **Issue:** Requires two additional arrays\n- **Better:** Two pointers use O(1) space\n\n**Approach 3: Use Stack**\n- **Why it doesn't fail:** Works, but more complex\n- **Issue:** More code, harder to understand\n- **Better:** Two pointers is simpler and equally efficient\n\n**Our approach wins because:** Two pointers with max tracking calculates trapped water in O(n) time with O(1) space. The greedy approach (process smaller max side) ensures correctness while maintaining efficiency.",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "Let's trace through the \"Trapping Rain Water\" problem step by step using the two-pointer approach.\n\n**Input:** height = [0,1,0,2,1,0,1,3,2,1,2,1]\n\n**Setup:**\n- Left pointer: left = 0\n- Right pointer: right = 11\n- Left max height seen so far: left_max = 0\n- Right max height seen so far: right_max = 0\n- Water trapped: water = 0\n\n**Step-by-step trace:**\n\n**Step 1:** left=0, right=11\n- height[0]=0, height[11]=1\n- Since height[left] ‚â§ height[right], process left side\n- left_max = max(0, 0) = 0\n- water += left_max - height[0] = 0 - 0 = 0\n- Move left pointer: left = 1\n\n**Step 2:** left=1, right=11\n- height[1]=1, height[11]=1\n- Since height[left] ‚â§ height[right], process left side\n- left_max = max(0, 1) = 1\n- water += left_max - height[1] = 1 - 1 = 0\n- Move left pointer: left = 2\n\n**Step 3:** left=2, right=11\n- height[2]=0, height[11]=1\n- Since height[left] ‚â§ height[right], process left side\n- left_max = max(1, 0) = 1\n- water += left_max - height[2] = 1 - 0 = 1\n- Total water = 1, Move left pointer: left = 3\n\n**Step 4:** left=3, right=11\n- height[3]=2, height[11]=1\n- Since height[left] > height[right], process right side\n- right_max = max(0, 1) = 1\n- water += right_max - height[11] = 1 - 1 = 0\n- Move right pointer: right = 10\n\n**Step 5:** left=3, right=10\n- height[3]=2, height[10]=2\n- Since height[left] ‚â§ height[right], process left side\n- left_max = max(1, 2) = 2\n- water += left_max - height[3] = 2 - 2 = 0\n- Move left pointer: left = 4\n\n**Step 6:** left=4, right=10\n- height[4]=1, height[10]=2\n- Since height[left] ‚â§ height[right], process left side\n- left_max = max(2, 1) = 2\n- water += left_max - height[4] = 2 - 1 = 1\n- Total water = 2, Move left pointer: left = 5\n\n**Step 7:** left=5, right=10\n- height[5]=0, height[10]=2\n- Since height[left] ‚â§ height[right], process left side\n- left_max = max(2, 0) = 2\n- water += left_max - height[5] = 2 - 0 = 2\n- Total water = 4, Move left pointer: left = 6\n\n**Step 8:** left=6, right=10\n- height[6]=1, height[10]=2\n- Since height[left] ‚â§ height[right], process left side\n- left_max = max(2, 1) = 2\n- water += left_max - height[6] = 2 - 1 = 1\n- Total water = 5, Move left pointer: left = 7\n\n**Step 9:** left=7, right=10\n- height[7]=3, height[10]=2\n- Since height[left] > height[right], process right side\n- right_max = max(1, 2) = 2\n- water += right_max - height[10] = 2 - 2 = 0\n- Move right pointer: right = 9\n\n**Step 10:** left=7, right=9\n- height[7]=3, height[9]=1\n- Since height[left] > height[right], process right side\n- right_max = max(2, 1) = 2\n- water += right_max - height[9] = 2 - 1 = 1\n- Total water = 6, Move right pointer: right = 8\n\n**Step 11:** left=7, right=8\n- height[7]=3, height[8]=2\n- Since height[left] > height[right], process right side\n- right_max = max(2, 2) = 2\n- water += right_max - height[8] = 2 - 2 = 0\n- Move right pointer: right = 7\n\n**Step 12:** left=7, right=7\n- Pointers meet, algorithm terminates\n\n**6 units of water**",
      "action": "next",
      "next": "pseudocode-step",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "Here's our plan as pseudocode:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7",
        "ps8",
        "ps9"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now JavaScript, step by step.\n\n1-3 lines at a time!",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Initialize function with height array parameter\n\n```javascript\nfunction trap(height) {\n\n}\n```",
      "action": "next",
      "next": "code-02",
      "pseudocodeLineIds": [],
      "example": "function trap(height) {\n\n}"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Set up two pointers at start and end of array\n\n```javascript\nfunction trap(height) {\n    let left = 0, right = height.length - 1;\n}\n```",
      "action": "next",
      "next": "code-03",
      "pseudocodeLineIds": [],
      "example": "    let left = 0, right = height.length - 1;"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Initialize variables to track maximum heights on left and right sides\n\n```javascript\nfunction trap(height) {\n    let left = 0, right = height.length - 1;\n    let leftMax = 0, rightMax = 0;\n}\n```",
      "action": "next",
      "next": "code-04",
      "pseudocodeLineIds": [],
      "example": "    let leftMax = 0, rightMax = 0;"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Initialize water counter variable\n\n```javascript\nfunction trap(height) {\n    let left = 0, right = height.length - 1;\n    let leftMax = 0, rightMax = 0;\n    let water = 0;\n}\n```",
      "action": "next",
      "next": "code-05",
      "pseudocodeLineIds": [],
      "example": "    let water = 0;"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Start main loop while left pointer is less than right pointer\n\n```javascript\nfunction trap(height) {\n    let left = 0, right = height.length - 1;\n    let leftMax = 0, rightMax = 0;\n    let water = 0;\n    \n    while (left < right) {\n        \n    }\n}\n```",
      "action": "next",
      "next": "code-06",
      "pseudocodeLineIds": [],
      "example": "    while (left < right) {\n        \n    }"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Check if left height is smaller than right height to determine which side to process\n\n```javascript\nfunction trap(height) {\n    let left = 0, right = height.length - 1;\n    let leftMax = 0, rightMax = 0;\n    let water = 0;\n    \n    while (left < right) {\n        if (height[left] < height[right]) {\n            \n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-07",
      "pseudocodeLineIds": [],
      "example": "        if (height[left] < height[right]) {\n            \n        }"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Process left side: update leftMax or add trapped water\n\n```javascript\nfunction trap(height) {\n    let left = 0, right = height.length - 1;\n    let leftMax = 0, rightMax = 0;\n    let water = 0;\n    \n    while (left < right) {\n        if (height[left] < height[right]) {\n            height[left] >= leftMax ? leftMax = height[left] : water += leftMax - height[left];\n            left++;\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-08",
      "pseudocodeLineIds": [],
      "example": "            height[left] >= leftMax ? leftMax = height[left] : water += leftMax - height[left];\n            left++;"
    },
    {
      "stepId": "code-08",
      "mentorSays": "Add else clause for processing right side\n\n```javascript\nfunction trap(height) {\n    let left = 0, right = height.length - 1;\n    let leftMax = 0, rightMax = 0;\n    let water = 0;\n    \n    while (left < right) {\n        if (height[left] < height[right]) {\n            height[left] >= leftMax ? leftMax = height[left] : water += leftMax - height[left];\n            left++;\n        } else {\n            \n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-09",
      "pseudocodeLineIds": [],
      "example": "        } else {\n            \n        }"
    },
    {
      "stepId": "code-09",
      "mentorSays": "Process right side: update rightMax or add trapped water\n\n```javascript\nfunction trap(height) {\n    let left = 0, right = height.length - 1;\n    let leftMax = 0, rightMax = 0;\n    let water = 0;\n    \n    while (left < right) {\n        if (height[left] < height[right]) {\n            height[left] >= leftMax ? leftMax = height[left] : water += leftMax - height[left];\n            left++;\n        } else {\n            height[right] >= rightMax ? rightMax = height[right] : water += rightMax - height[right];\n            right--;\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-10",
      "pseudocodeLineIds": [],
      "example": "            height[right] >= rightMax ? rightMax = height[right] : water += rightMax - height[right];\n            right--;"
    },
    {
      "stepId": "code-10",
      "mentorSays": "Return the total amount of trapped water\n\n```javascript\nfunction trap(height) {\n    let left = 0, right = height.length - 1;\n    let leftMax = 0, rightMax = 0;\n    let water = 0;\n    \n    while (left < right) {\n        if (height[left] < height[right]) {\n            height[left] >= leftMax ? leftMax = height[left] : water += leftMax - height[left];\n            left++;\n        } else {\n            height[right] >= rightMax ? rightMax = height[right] : water += rightMax - height[right];\n            right--;\n        }\n    }\n    \n    return water;\n}\n```",
      "action": "next",
      "next": "common-mistakes",
      "pseudocodeLineIds": [],
      "example": "    return water;"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "üéâ Outstanding work conquering \"Trapping Rain Water\" with the two pointers and max tracking approach - you've mastered one of the most elegant dynamic programming optimizations! Your ability to visualize water levels and efficiently track maximums from both directions shows real algorithmic maturity.\n\nNow let's channel that momentum into \"Daily Temperatures\" where you'll explore the powerful stack-based monotonic pattern - another beautiful technique that will expand your problem-solving toolkit even further!\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}