{
  "id": "linked-list-cycle",
  "title": "Linked List Cycle",
  "pattern": "fast-slow pointers (Floyd's algorithm)",
  "difficulty": "easy",
  "language": "javascript",
  "status": "AI-GENERATED-V2-BATCH",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 17,
    "tier": "FOUNDATION",
    "lessonOrderTag": "FOUNDATION-17",
    "introduces": [
      "linked-list-concept",
      "node-structure",
      "next-pointer",
      "cycle-detection"
    ],
    "assumesAlreadyTaught": [
      "loops",
      "pointers-concept"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "reverse-linked-list"
    ]
  },
  "problemStatement": {
    "description": "Determine if a linked list has a cycle. A cycle exists if some node in the list can be reached again by continuously following the next pointer.",
    "inputs": [
      "head: head node of a linked list (can be null, length 0 to 10^4)"
    ],
    "outputs": [
      "Boolean: true if cycle exists, false otherwise"
    ],
    "examples": [
      {
        "input": "head = [3,2,0,-4] with cycle at index 1",
        "output": "true",
        "explanation": "List has cycle: -4 points back to node 2. Fast and slow pointers will meet at some node in the cycle."
      },
      {
        "input": "head = [1,2] with cycle at index 0",
        "output": "true",
        "explanation": "List has cycle: 2 points back to node 1. Pointers will meet."
      },
      {
        "input": "head = [1] with no cycle",
        "output": "false",
        "explanation": "Single node, no cycle. Fast pointer reaches null, no meeting occurs."
      }
    ],
    "constraints": [
      "Number of nodes in list is in range [0, 10^4]",
      "-10^5 <= Node.val <= 10^5"
    ],
    "realWorldUse": [
      "Detecting infinite loops in programs",
      "Memory leak detection",
      "Cycle detection in graphs",
      "Floyd's cycle detection algorithm applications"
    ]
  },
  "patternRecognition": {
    "whyThisPattern": "Floyd's cycle detection algorithm uses two pointers moving at different speeds. If a cycle exists, the fast pointer will eventually meet the slow pointer. This is mathematically guaranteed and uses O(1) space.",
    "signalsToRecognize": [
      "SIGNAL 1: Problem asks to detect cycle or loop â†’ think Floyd's algorithm",
      "SIGNAL 2: Need O(1) space solution â†’ use two pointers instead of hash set",
      "SIGNAL 3: Linked list or sequence with potential cycle â†’ fast-slow pointer pattern"
    ],
    "patternRules": [
      "If problem involves cycle detection â†’ use Floyd's algorithm (fast-slow pointers)",
      "When you see 'cycle', 'loop', or 'repeated' in linked list context â†’ consider two pointers",
      "If O(1) space needed â†’ avoid hash set, use pointer chasing"
    ],
    "whyNotOtherApproaches": {
      "greedy": "Greedy doesn't apply - we need to detect cycles, not make choices.",
      "bruteForce": "Using hash set to track visited nodes works but uses O(n) space. Floyd's algorithm uses O(1) space.",
      "alternative": "Marking nodes as visited works but modifies the list. Two pointers don't modify anything."
    }
  },
  "coreInvariant": {
    "statement": "If a cycle exists, the fast pointer will eventually meet the slow pointer within the cycle. If no cycle exists, the fast pointer will reach null before meeting slow.",
    "explanation": "This invariant holds because fast moves 2 steps while slow moves 1 step per iteration, so fast gains 1 step per iteration on slow. In a cycle, this gap will eventually close to 0, causing them to meet. If no cycle, fast reaches null first.",
    "whyItMatters": "This invariant guarantees correctness: the algorithm terminates in O(n) time, either detecting a cycle (pointers meet) or confirming no cycle (fast reaches null)."
  },
  "stateDefinition": {
    "states": [
      {
        "name": "slow",
        "meaning": "Slow pointer moving 1 step per iteration",
        "indexing": "Starts at head, moves: slow = slow.next"
      },
      {
        "name": "fast",
        "meaning": "Fast pointer moving 2 steps per iteration",
        "indexing": "Starts at head, moves: fast = fast.next.next"
      },
      {
        "name": "head",
        "meaning": "Starting node of linked list",
        "indexing": "Can be null (empty list)"
      }
    ],
    "baseCases": [
      "If head is null: return false (empty list has no cycle)",
      "If head.next is null: return false (single node has no cycle)"
    ]
  },
  "transitionLogic": {
    "rules": [
      {
        "condition": "While fast != null and fast.next != null:",
        "transition": "slow = slow.next, fast = fast.next.next",
        "explanation": "Move slow one step, fast two steps. Fast moves twice as fast as slow.",
        "example": "If slow at node A, fast at node B, after one iteration: slow at node B, fast at node D"
      },
      {
        "condition": "If slow == fast:",
        "transition": "return true (cycle detected)",
        "explanation": "Pointers met, which only happens if there's a cycle.",
        "example": "If slow and fast both point to same node, cycle exists"
      },
      {
        "condition": "If loop exits (fast == null or fast.next == null):",
        "transition": "return false (no cycle)",
        "explanation": "Fast reached end of list without meeting slow, so no cycle.",
        "example": "Fast reaches null, list has end, no cycle"
      }
    ],
    "decisionTree": {
      "root": "Initialize both pointers at head, then move at different speeds",
      "branches": [
        "If fast == null or fast.next == null: return false (no cycle)",
        "Move slow one step, fast two steps",
        "If slow == fast: return true (cycle detected)",
        "Continue until cycle detected or end reached"
      ]
    }
  },
  "walkthrough": {
    "example": "head = [3,2,0,-4] with cycle: -4 â†’ 2",
    "steps": [
      {
        "step": 1,
        "description": "Initialize: slow = node 3, fast = node 3",
        "state": "slow = 3, fast = 3, both at head",
        "logic": "Start both pointers at head",
        "result": "Ready to detect cycle"
      },
      {
        "step": 2,
        "description": "Iteration 1: slow = 2, fast = 0",
        "state": "slow = node 2, fast = node 0",
        "logic": "Slow moves 1 step, fast moves 2 steps",
        "result": "slow != fast, continue"
      },
      {
        "step": 3,
        "description": "Iteration 2: slow = 0, fast = 2 (fast went: 0 â†’ -4 â†’ 2)",
        "state": "slow = node 0, fast = node 2",
        "logic": "Fast entered cycle, now both in cycle",
        "result": "slow != fast, continue"
      },
      {
        "step": 4,
        "description": "Iteration 3: slow = -4, fast = -4 (fast went: 2 â†’ 0 â†’ -4)",
        "state": "slow = node -4, fast = node -4",
        "logic": "Fast caught up to slow, they meet!",
        "result": "slow == fast, return true"
      }
    ],
    "keyInsight": "Fast pointer moves twice as fast as slow, so it gains 1 step per iteration. In a cycle, fast will eventually catch up to slow. This is guaranteed to happen within O(n) time, making it an efficient O(1) space solution."
  },
  "commonMistakes": [
    {
      "mistake": "Not checking fast.next before accessing fast.next.next",
      "symptom": "Null pointer exception when fast.next is null",
      "fix": "Check both fast != null and fast.next != null in loop condition",
      "example": "If fast is at last node, fast.next is null, accessing fast.next.next causes error"
    },
    {
      "mistake": "Initializing pointers incorrectly",
      "symptom": "May miss cycle or cause infinite loop",
      "fix": "Both slow and fast should start at head",
      "example": "If slow starts at head.next, algorithm may not work correctly"
    },
    {
      "mistake": "Using hash set instead of two pointers",
      "symptom": "Works but uses O(n) space unnecessarily",
      "fix": "Use Floyd's algorithm for O(1) space solution",
      "example": "Hash set tracks all visited nodes, uses extra space"
    },
    {
      "mistake": "Not handling empty list or single node",
      "symptom": "Error or wrong answer for edge cases",
      "fix": "Check if head is null or head.next is null, return false",
      "example": "Empty list or single node cannot have cycle"
    },
    {
      "mistake": "Moving pointers in wrong order",
      "symptom": "May not detect cycle correctly",
      "fix": "Always move slow first, then fast, then check if they meet",
      "example": "If you check before moving, you might miss the meeting point"
    }
  ],
  "interviewTalkTrack": {
    "script": [
      "This is Floyd's cycle detection algorithm using two pointers.",
      "",
      "I'll use fast and slow pointers:",
      "- Initialize slow = head, fast = head",
      "- While fast != null and fast.next != null:",
      "  - slow = slow.next (move 1 step)",
      "  - fast = fast.next.next (move 2 steps)",
      "  - If slow == fast: return true (cycle detected)",
      "- Return false (no cycle)",
      "",
      "Time complexity: O(n) - fast pointer visits each node at most once",
      "Space complexity: O(1) - only using two pointers",
      "",
      "Edge cases:",
      "- Empty list: return false",
      "- Single node: return false",
      "- The algorithm is mathematically proven to detect cycles"
    ]
  },
  "variants": {
    "easier": {
      "problem": "Linked List Cycle (return cycle start node)",
      "approachChange": "After detecting cycle, find where cycle starts using additional pointer logic",
      "solution": "After fast and slow meet, move one pointer to head, move both one step at a time until they meet. Meeting point is cycle start."
    },
    "harder": {
      "problem": "Find Duplicate Number (array version)",
      "approachChange": "Array with numbers 1 to n, one duplicate. Treat array as linked list (nums[i] points to nums[nums[i]]), find cycle.",
      "solution": "Use Floyd's algorithm on the array treated as linked list. Cycle exists because duplicate creates a loop."
    }
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "If head is null or head.next is null: return false"
    },
    {
      "id": "ps2",
      "text": "Initialize slow = head, fast = head"
    },
    {
      "id": "ps3",
      "text": "While fast != null and fast.next != null:"
    },
    {
      "id": "ps4",
      "text": "  slow = slow.next"
    },
    {
      "id": "ps5",
      "text": "  fast = fast.next.next"
    },
    {
      "id": "ps6",
      "text": "  If slow == fast: return true"
    },
    {
      "id": "ps7",
      "text": "Return false (no cycle)"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "Hey! Ready to tackle one of the most elegant algorithms in computer science? Today we're exploring **Linked List Cycle** detection using the fast-slow pointer pattern, also known as Floyd's Cycle Detection Algorithm (or the \"tortoise and hare\" approach).\n\nYou'll master the art of using two pointers moving at different speeds to detect cycles in linked lists - it's like having one runner go twice as fast as another on a track, and if there's a loop, they'll eventually meet!\n\nHere are the 3 key skills you'll walk away with:\n\n1. **Implement Floyd's Algorithm** - Use fast and slow pointers to detect cycles efficiently\n2. **Find Cycle Starting Points** - Locate exactly where a cycle begins in a linked list\n3. **Optimize Space Complexity** - Solve cycle problems in O(1) space instead of using hash sets\n\nThis pattern shows up everywhere in coding interviews and real-world applications, from detecting infinite loops to memory leak detection. Let's dive in!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Before we dive into the problem, which programming language would you like to use?\n\nThis will help me make sure you have the right building blocks.",
      "choices": [
        {
          "label": "ðŸ’› JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "ðŸ Python",
          "next": "prereq-check-python"
        },
        {
          "label": "â˜• Java",
          "next": "prereq-check-java"
        },
        {
          "label": "âš¡ C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "ðŸ’™ TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in JavaScript, you'll need to know:\n- **Two-pointers** - Technique using two pointers moving at different speeds to traverse data structures\n- **Linked-list-traversal** - Understanding how to navigate through linked list nodes using pointer references\n- **Cycle-detection-theory** - Mathematical concept of detecting cycles in sequences using Floyd's algorithm\n- **Pointer-manipulation** - Ability to move and compare pointer positions in linked data structures\n\nDo you feel confident with these JavaScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-js"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Python, you'll need to know:\n- **Two-pointers** - Technique using two pointers moving at different speeds to traverse data structures\n- **Linked-list-traversal** - Understanding how to navigate through linked list nodes using pointer references\n- **Cycle-detection-theory** - Mathematical concept of detecting cycles in sequences using Floyd's algorithm\n- **Pointer-manipulation** - Ability to move and compare pointer positions in linked data structures\n\nDo you feel confident with these Python concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-python"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Java, you'll need to know:\n- **Two-pointers** - Technique using two pointers moving at different speeds to traverse data structures\n- **Linked-list-traversal** - Understanding how to navigate through linked list nodes using pointer references\n- **Cycle-detection-theory** - Mathematical concept of detecting cycles in sequences using Floyd's algorithm\n- **Pointer-manipulation** - Ability to move and compare pointer positions in linked data structures\n\nDo you feel confident with these Java concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-java"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in C++, you'll need to know:\n- **Two-pointers** - Technique using two pointers moving at different speeds to traverse data structures\n- **Linked-list-traversal** - Understanding how to navigate through linked list nodes using pointer references\n- **Cycle-detection-theory** - Mathematical concept of detecting cycles in sequences using Floyd's algorithm\n- **Pointer-manipulation** - Ability to move and compare pointer positions in linked data structures\n\nDo you feel confident with these C++ concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in TypeScript, you'll need to know:\n- **Two-pointers** - Technique using two pointers moving at different speeds to traverse data structures\n- **Linked-list-traversal** - Understanding how to navigate through linked list nodes using pointer references\n- **Cycle-detection-theory** - Mathematical concept of detecting cycles in sequences using Floyd's algorithm\n- **Pointer-manipulation** - Ability to move and compare pointer positions in linked data structures\n\nDo you feel confident with these TypeScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "Perfect! Now let's understand what the Linked List Cycle problem asks for.\n\nImagine you're following a hiking trail with a friend, where you walk at normal pace while your friend jogs ahead at double speed - if there's a loop in the trail that circles back, your faster friend will eventually catch up and meet you again from behind, but if the trail ends at a destination, you'll both reach it without ever meeting.\n\n# Linked List Cycle Problem\n\n## What it's asking\n\nYou're given the head of a linked list, and you need to figure out if there's a **cycle** in it. A cycle means that somewhere in the list, a node points back to a previous node instead of pointing to `null`, creating an endless loop.\n\nReturn `true` if there's a cycle, `false` if there isn't.\n\n## Example\n\nLet's say you have this linked list:\n```\n1 â†’ 2 â†’ 3 â†’ 4 â†’ 2 (points back to the node with value 2)\n```\n\n**Answer: `true`**\n\n## Why this example works\n\nHere's what's happening step by step:\n\n1. Start at node `1` â†’ go to node `2`\n2. From node `2` â†’ go to node `3` \n3. From node `3` â†’ go to node `4`\n4. From node `4` â†’ **uh oh!** Instead of pointing to `null` (end of list), it points back to the node containing `2`\n5. Now you're stuck in an infinite loop: `2 â†’ 3 â†’ 4 â†’ 2 â†’ 3 â†’ 4 â†’ 2...`\n\nSince we can get trapped in this loop and never reach the end of the list, there's definitely a cycle present, so we return `true`.\n\nIf the last node pointed to `null` instead, we'd return `false` because we could traverse the entire list without getting stuck.",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "You need to detect if a linked list has a cycle. How would YOU approach this problem?",
      "choices": [
        {
          "label": "Use a HashSet to store visited nodes - if we see a node again, there's a cycle",
          "next": "wrong-choice"
        },
        {
          "label": "Use two pointers: fast moves 2 steps, slow moves 1 step - if there's a cycle, they'll eventually meet",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-choice",
      "mentorSays": "While this works correctly, it uses O(n) extra space to store potentially all nodes. The problem can be solved more elegantly with O(1) space complexity.",
      "action": "next",
      "next": "pattern-recognition"
    },
    {
      "stepId": "pattern-recognition",
      "mentorSays": "### Pattern Recognition: Floyd's Cycle Detection (Two Pointers)\n\n**This problem follows the \"Floyd's cycle detection\" pattern:**\n- **Two pointers** - Fast and slow pointers moving at different speeds\n- **Relative speed** - Fast moves 2 steps, slow moves 1 step (relative speed = 1)\n- **Cycle detection** - If cycle exists, pointers will eventually meet\n- **O(1) space** - No extra data structures needed\n\n**Similar problems:**\n- Linked List Cycle II (find cycle start)\n- Middle of Linked List (two pointers)\n- Find Duplicate Number (cycle detection in array)\n\n**Key insight:** Floyd's algorithm uses the mathematical property that if there's a cycle, a fast pointer will eventually catch up to a slow pointer. The relative speed of 1 step per iteration guarantees convergence.",
      "action": "next",
      "next": "invariant"
    },
    {
      "stepId": "invariant",
      "mentorSays": "### Invariant: Fast Pointer Closes Gap by 1 Per Iteration\n\n**Invariant maintained throughout:**\n- **Relative speed:** Fast pointer moves 2 steps, slow moves 1 step (gap closes by 1 per iteration)\n- **Cycle detection:** If cycle exists, fast will eventually meet slow\n- **No cycle:** If no cycle, fast reaches null before meeting slow\n- **Convergence:** In cycle of length L, fast catches slow within L iterations\n\n**Why this works:**\n- If no cycle: fast reaches null, return false\n- If cycle exists: fast enters cycle first, then slow enters\n- Once both in cycle, fast gains 1 step per iteration on slow\n- Eventually, fast catches slow (they meet)\n\n**Invariant guarantee:** After at most n iterations (where n is list length), either fast reaches null (no cycle) or fast meets slow (cycle detected). The algorithm terminates in O(n) time.",
      "action": "next",
      "next": "state-definition"
    },
    {
      "stepId": "state-definition",
      "mentorSays": "### State Definition: Two Pointer Cycle Detection State\n\n**State variables:**\n- **`slow`** - Slow pointer moving 1 step per iteration\n- **`fast`** - Fast pointer moving 2 steps per iteration\n- **`head`** - Starting node of linked list\n\n**State transitions:**\n1. **Initialize:** slow = head, fast = head\n2. **Loop:** While fast and fast.next exist:\n   - Move slow: slow = slow.next\n   - Move fast: fast = fast.next.next\n   - If slow == fast: return true (cycle detected)\n3. **Result:** If loop exits, return false (no cycle)\n\n**State validity:** Cycle detected when slow == fast. No cycle when fast reaches null.",
      "action": "next",
      "next": "why-alternatives-fail"
    },
    {
      "stepId": "why-alternatives-fail",
      "mentorSays": "### Why Alternative Approaches Fail\n\n**Approach 1: Use HashSet to Track Visited Nodes**\n- **Why it fails:** Uses O(n) extra space\n- **Issue:** Need to store all nodes in worst case\n- **Better:** Floyd's algorithm uses O(1) space\n\n**Approach 2: Mark Nodes as Visited**\n- **Why it fails:** Modifies the list structure\n- **Issue:** Requires changing node properties, not always allowed\n- **Better:** Two pointers don't modify the list\n\n**Approach 3: Count Steps and Check for Loop**\n- **Why it fails:** Doesn't work for all cycle configurations\n- **Issue:** May not detect cycles correctly\n- **Better:** Floyd's algorithm is mathematically proven to work\n\n**Our approach wins because:** Floyd's cycle detection algorithm finds cycles in O(n) time with O(1) space, which is optimal. The two-pointer approach is elegant and doesn't require extra space or list modification.",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "The key insight is to use **two pointers** moving at different speeds - a **fast pointer** that moves 2 steps and a **slow pointer** that moves 1 step per iteration. If a cycle exists, the fast pointer will eventually \"lap\" the slow pointer and they will meet at some node within the cycle. This works because the **relative speed** between the pointers is 1 step per iteration, so the fast pointer closes the gap by 1 position each time until they converge. If no cycle exists, the fast pointer will simply reach the end of the list.",
      "action": "next",
      "next": "circular-track-analogy"
    },
    {
      "stepId": "circular-track-analogy",
      "mentorSays": "### Circular Track Analogy (Floyd's Algorithm)\n\n**Imagine two runners on a circular track:**\n\n- **Slow runner (tortoise):** Moves 1 step at a time\n- **Fast runner (hare):** Moves 2 steps at a time\n\n**If there's a cycle:**\n- The fast runner will eventually \"lap\" the slow runner\n- They'll meet at the same node â†’ cycle detected!\n\n**If there's no cycle:**\n- The fast runner reaches the end (null) first\n- They never meet â†’ no cycle\n\n**Why this works:**\n- In a cycle, the fast pointer gains 1 step per iteration on the slow pointer\n- Eventually, the gap closes and they meet\n- This is guaranteed to happen within O(n) time\n\n**Example:**\n```\nList: 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 3 (cycle back to 3)\n\nSlow: 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 3\nFast: 1 â†’ 3 â†’ 5 â†’ 3 â†’ 5 â†’ 3\n\nThey meet at node 3 â†’ cycle detected!\n```\n\n**This makes Floyd's algorithm stick** - the visual analogy helps understand why fast/slow pointers work.",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "Let's trace through `1â†’2â†’3â†’4â†’2 (cycle)`:\n\n- Step 1: Initialize slow and fast pointers at head (node 1)\n- Step 2: Move slow to node 2, fast to node 3\n- Step 3: Move slow to node 3, fast to node 2 (follows cycle back)\n- Step 4: Move slow to node 4, fast to node 4\n- Step 5: Pointers meet at node 4 - cycle detected!\n- Final answer: **true**",
      "action": "next",
      "next": "pseudocode-step",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "Here's our plan written as pseudocode:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now let's translate this into JavaScript, building it step by step.\n\nRemember: we'll add just 1-3 lines at a time!",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Initialize function with basic structure and handle null edge case\n\n```javascript\nfunction hasCycle(head) {\n    if (!head || !head.next) return false;\n}\n```",
      "action": "next",
      "next": "code-02",
      "pseudocodeLineIds": [
        "ps1"
      ],
      "example": "function hasCycle(head) {\n    if (!head || !head.next) return false;\n}"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Initialize slow pointer starting at head\n\n```javascript\nfunction hasCycle(head) {\n    if (!head || !head.next) return false;\n    let slow = head;\n}\n```",
      "action": "next",
      "next": "code-03",
      "pseudocodeLineIds": [
        "ps2"
      ],
      "example": "    let slow = head;"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Initialize fast pointer starting one step ahead\n\n```javascript\nfunction hasCycle(head) {\n    if (!head || !head.next) return false;\n    let slow = head;\n    let fast = head.next;\n}\n```",
      "action": "next",
      "next": "code-04",
      "pseudocodeLineIds": [
        "ps2"
      ],
      "example": "    let fast = head.next;"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Create main loop that continues while fast and fast.next exist\n\n```javascript\nfunction hasCycle(head) {\n    if (!head || !head.next) return false;\n    let slow = head;\n    let fast = head.next;\n    while (fast && fast.next) {\n    }\n}\n```",
      "action": "next",
      "next": "code-05",
      "pseudocodeLineIds": [
        "ps3"
      ],
      "example": "    while (fast && fast.next) {\n    }"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Check if pointers meet - if so, cycle detected\n\n```javascript\nfunction hasCycle(head) {\n    if (!head || !head.next) return false;\n    let slow = head;\n    let fast = head.next;\n    while (fast && fast.next) {\n        if (slow === fast) return true;\n    }\n}\n```",
      "action": "next",
      "next": "code-06",
      "pseudocodeLineIds": [
        "ps4"
      ],
      "example": "        if (slow === fast) return true;"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Move slow pointer one step forward\n\n```javascript\nfunction hasCycle(head) {\n    if (!head || !head.next) return false;\n    let slow = head;\n    let fast = head.next;\n    while (fast && fast.next) {\n        if (slow === fast) return true;\n        slow = slow.next;\n    }\n}\n```",
      "action": "next",
      "next": "code-07",
      "pseudocodeLineIds": [
        "ps5"
      ],
      "example": "        slow = slow.next;"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Move fast pointer two steps forward\n\n```javascript\nfunction hasCycle(head) {\n    if (!head || !head.next) return false;\n    let slow = head;\n    let fast = head.next;\n    while (fast && fast.next) {\n        if (slow === fast) return true;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n}\n```",
      "action": "next",
      "next": "code-08",
      "pseudocodeLineIds": [
        "ps5"
      ],
      "example": "        fast = fast.next.next;"
    },
    {
      "stepId": "code-08",
      "mentorSays": "Return false when loop exits (no cycle found)\n\n```javascript\nfunction hasCycle(head) {\n    if (!head || !head.next) return false;\n    let slow = head;\n    let fast = head.next;\n    while (fast && fast.next) {\n        if (slow === fast) return true;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return false;\n}\n```",
      "action": "next",
      "next": "common-mistakes",
      "pseudocodeLineIds": [
        "ps6"
      ],
      "example": "    return false;"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "Great work mastering the fast-slow pointers technique with Floyd's Cycle Detection Algorithm! You've learned how to elegantly detect cycles in linked lists using two pointers moving at different speeds - a fundamental pattern that appears in many advanced problems. Next, we'll tackle reverse-linked-list, where you'll master the essential skill of manipulating pointer directions to reverse the flow of a linked list.\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}