{
  "id": "valid-parentheses",
  "title": "Valid Parentheses",
  "pattern": "stack (bracket matching)",
  "difficulty": "easy",
  "language": "javascript",
  "status": "AI-GENERATED-V2-BATCH",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 14,
    "tier": "FOUNDATION",
    "lessonOrderTag": "FOUNDATION-14",
    "introduces": [
      "stack-concept",
      "push-method",
      "pop-method",
      "LIFO-principle",
      "bracket-matching"
    ],
    "assumesAlreadyTaught": [
      "strings",
      "arrays",
      "loops",
      "objects"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "climbing-stairs"
    ]
  },
  "problemStatement": {
    "description": "Determine if a string containing only parentheses, brackets, and braces is valid. Valid means every opening bracket has a matching closing bracket of the same type, and they are closed in the correct order.",
    "inputs": [
      "s: string containing only '(', ')', '{', '}', '[', ']' (length 1 to 10^4)"
    ],
    "outputs": [
      "Boolean: true if string is valid, false otherwise"
    ],
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true",
        "explanation": "Opening '(' matches closing ')'. Stack: push '(', pop '(', stack empty â†’ valid."
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true",
        "explanation": "All brackets properly matched. Stack: push '(', pop ')', push '[', pop ']', push '{', pop '}', stack empty â†’ valid."
      },
      {
        "input": "s = \"(]\"",
        "output": "false",
        "explanation": "Opening '(' doesn't match closing ']'. Stack: push '(', pop '(' but expected ')', mismatch â†’ invalid."
      },
      {
        "input": "s = \"([)]\"",
        "output": "false",
        "explanation": "Brackets are interleaved incorrectly. Stack: push '(', push '[', pop '[' matches ']', but then ')' doesn't match '(' (wrong order)."
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of only '(', ')', '{', '}', '[' and ']'"
    ],
    "realWorldUse": [
      "Code syntax validation (checking if brackets are balanced)",
      "Expression parsing and evaluation",
      "XML/JSON validation",
      "Compiler design (parsing nested structures)"
    ]
  },
  "patternRecognition": {
    "whyThisPattern": "Parentheses must be closed in Last-In-First-Out (LIFO) order - the most recently opened bracket must be closed first. A stack naturally implements LIFO, making it perfect for this problem.",
    "signalsToRecognize": [
      "SIGNAL 1: Problem involves matching nested/paired elements â†’ think stack",
      "SIGNAL 2: Need LIFO behavior (last opened, first closed) â†’ stack is ideal",
      "SIGNAL 3: Bracket matching, parentheses validation, or nested structures â†’ stack pattern"
    ],
    "patternRules": [
      "If problem involves matching pairs in nested order â†’ use stack",
      "When you see 'valid parentheses', 'bracket matching', or 'nested structures' â†’ consider stack",
      "If LIFO order is required â†’ stack is the natural data structure"
    ],
    "whyNotOtherApproaches": {
      "greedy": "Greedy doesn't apply - we need to match brackets in specific nested order, not make local choices.",
      "bruteForce": "Checking all possible pairings is complex. Stack provides O(n) solution with clear logic.",
      "alternative": "Counting brackets doesn't work - '([)]' has correct counts but wrong order. Stack preserves order."
    }
  },
  "coreInvariant": {
    "statement": "The stack contains only unmatched opening brackets, with the top being the most recently opened bracket that needs to be closed next.",
    "explanation": "This invariant holds because we push opening brackets and pop when we find matching closing brackets. The stack naturally maintains the order of opening brackets, ensuring we match them in LIFO order.",
    "whyItMatters": "This invariant guarantees correctness: when we see a closing bracket, it must match the top of the stack (most recent opening). If stack is empty when we see a closing bracket, or if stack is not empty at the end, the string is invalid."
  },
  "stateDefinition": {
    "states": [
      {
        "name": "stack",
        "meaning": "Stack storing unmatched opening brackets",
        "indexing": "LIFO structure, top is most recent opening bracket"
      },
      {
        "name": "s",
        "meaning": "String being validated",
        "indexing": "0-indexed string"
      },
      {
        "name": "char",
        "meaning": "Current character being processed",
        "indexing": "Character from string s"
      }
    ],
    "baseCases": [
      "If string is empty: return true (empty string is valid)",
      "If string length is odd: return false (cannot have balanced brackets)"
    ]
  },
  "transitionLogic": {
    "rules": [
      {
        "condition": "If char is opening bracket ('(', '[', '{'):",
        "transition": "stack.push(char)",
        "explanation": "Push opening bracket onto stack to track it for future matching",
        "example": "s=\"()\", char='(': push '(' onto stack"
      },
      {
        "condition": "If char is closing bracket (')', ']', '}'):",
        "transition": "If stack is empty: return false. Else: pop from stack and check if it matches",
        "explanation": "Closing bracket must match most recent opening. If stack empty, no opening to match â†’ invalid.",
        "example": "s=\"()\", char=')': pop '(', matches ')' â†’ valid"
      },
      {
        "condition": "If popped bracket doesn't match closing bracket:",
        "transition": "return false (mismatch)",
        "explanation": "Bracket types must match: '(' with ')', '[' with ']', '{' with '}'",
        "example": "s=\"(]\", char=']': pop '(', but '(' doesn't match ']' â†’ invalid"
      },
      {
        "condition": "After processing all characters:",
        "transition": "return stack.isEmpty() (true if empty, false if not)",
        "explanation": "All brackets should be matched. If stack not empty, there are unmatched opening brackets.",
        "example": "s=\"(\": stack has '(', not empty â†’ invalid"
      }
    ],
    "decisionTree": {
      "root": "For each character, check if it's opening or closing",
      "branches": [
        "If opening: push onto stack",
        "If closing: check if stack empty (invalid), else pop and check match (invalid if mismatch)",
        "After all characters: return true if stack empty, false otherwise"
      ]
    }
  },
  "walkthrough": {
    "example": "s = \"()[]{}\"",
    "steps": [
      {
        "step": 1,
        "description": "Initialize: stack = []",
        "state": "stack = [], i = 0, s[0] = '('",
        "logic": "Start with empty stack",
        "result": "Ready to process"
      },
      {
        "step": 2,
        "description": "i=0: '(' is opening, push onto stack",
        "state": "stack = ['('], i = 0",
        "logic": "Opening bracket, track it",
        "result": "stack = ['(']"
      },
      {
        "step": 3,
        "description": "i=1: ')' is closing, pop '(', matches â†’ valid",
        "state": "stack = [], i = 1",
        "logic": "Closing bracket matches top of stack",
        "result": "stack = []"
      },
      {
        "step": 4,
        "description": "i=2: '[' is opening, push onto stack",
        "state": "stack = ['['], i = 2",
        "logic": "Another opening bracket",
        "result": "stack = ['[']"
      },
      {
        "step": 5,
        "description": "i=3: ']' is closing, pop '[', matches â†’ valid",
        "state": "stack = [], i = 3",
        "logic": "Brackets match",
        "result": "stack = []"
      },
      {
        "step": 6,
        "description": "i=4: '{' is opening, push. i=5: '}' is closing, pop '{', matches â†’ valid",
        "state": "stack = [], i = 5",
        "logic": "All brackets matched",
        "result": "stack = [], return true"
      }
    ],
    "keyInsight": "Stack naturally implements LIFO order required for bracket matching. The most recently opened bracket (top of stack) must be closed first. This ensures proper nesting and prevents interleaving like '([)]'."
  },
  "commonMistakes": [
    {
      "mistake": "Not checking if stack is empty before popping",
      "symptom": "Runtime error when closing bracket appears without matching opening",
      "fix": "Always check if stack is empty before popping. If empty, return false immediately.",
      "example": "s=\")()\": first char is ')', stack is empty â†’ return false, don't try to pop"
    },
    {
      "mistake": "Not checking if stack is empty at the end",
      "symptom": "Wrong answer for strings like \"((\" (unmatched openings)",
      "fix": "After processing all characters, return true only if stack is empty",
      "example": "s=\"((\": stack has 2 '(', not empty â†’ return false"
    },
    {
      "mistake": "Using wrong matching logic (checking counts instead of order)",
      "symptom": "Incorrectly validates '([)]' as valid (has correct counts but wrong order)",
      "fix": "Use stack to preserve order. Don't just count brackets - match them in LIFO order.",
      "example": "Counting: '([)]' has 1 '(', 1 ')', 1 '[', 1 ']' â†’ seems valid, but order is wrong"
    },
    {
      "mistake": "Not handling all three bracket types correctly",
      "symptom": "May mix up bracket types, e.g., matching '(' with ']'",
      "fix": "Create mapping: {')': '(', ']': '[', '}': '{'} to check if popped bracket matches",
      "example": "When see ')', pop and check if popped is '(', not '[' or '{'"
    },
    {
      "mistake": "Using array instead of stack (works but less semantic)",
      "symptom": "Works but code is less clear about LIFO intent",
      "fix": "Use proper stack operations (push/pop) or array with push/pop methods to make intent clear",
      "example": "stack.push() and stack.pop() are clearer than array manipulation"
    }
  ],
  "interviewTalkTrack": {
    "script": [
      "This is a stack-based bracket matching problem.",
      "",
      "I'll use a stack to track opening brackets:",
      "- Initialize empty stack",
      "- For each character in string:",
      "  - If opening bracket: push onto stack",
      "  - If closing bracket:",
      "    - If stack empty: return false",
      "    - Pop from stack, check if it matches closing bracket",
      "    - If mismatch: return false",
      "- After processing: return true if stack empty, false otherwise",
      "",
      "Time complexity: O(n) - single pass through string",
      "Space complexity: O(n) - stack may store all opening brackets in worst case",
      "",
      "Edge cases:",
      "- Empty string: return true",
      "- Single bracket: return false",
      "- Only opening brackets: return false (stack not empty)",
      "- Only closing brackets: return false (stack empty when closing found)"
    ]
  },
  "variants": {
    "easier": {
      "problem": "Valid Parentheses (only one type)",
      "approachChange": "Only '(' and ')' brackets, simpler matching logic",
      "solution": "Same stack approach but simpler - no need for bracket type mapping"
    },
    "harder": {
      "problem": "Remove Invalid Parentheses",
      "approachChange": "Need to remove minimum brackets to make valid. Use backtracking with pruning.",
      "solution": "Generate all possible removals, check validity. Optimize with pruning: track invalid count, remove brackets that cause invalidity."
    }
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Initialize stack = []"
    },
    {
      "id": "ps2",
      "text": "Create mapping: map = {')': '(', ']': '[', '}': '{'}"
    },
    {
      "id": "ps3",
      "text": "For each character c in s:"
    },
    {
      "id": "ps4",
      "text": "  If c is opening bracket: stack.push(c)"
    },
    {
      "id": "ps5",
      "text": "  Else (closing bracket):"
    },
    {
      "id": "ps6",
      "text": "    If stack is empty: return false"
    },
    {
      "id": "ps7",
      "text": "    If stack.pop() != map[c]: return false"
    },
    {
      "id": "ps8",
      "text": "Return stack.length == 0"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "Hey! Great job conquering the merge-sorted-array challenge! Now we're moving into an exciting new territory with \"Valid Parentheses\" - a classic problem that introduces you to the powerful **stack pattern** for bracket matching.\n\nThis problem is all about determining if brackets, parentheses, and braces are properly paired and nested - just like checking if your code's syntax is correct! We'll use a stack data structure to track opening brackets and match them with their corresponding closing brackets as we scan through the string.\n\nHere are 3 key skills you'll master:\nâ€¢ **Stack fundamentals** - Learn when and how to use this essential \"last in, first out\" data structure\nâ€¢ **Pattern recognition** - Identify bracket matching scenarios and apply the stack approach confidently  \nâ€¢ **String validation** - Build robust logic to verify proper nesting and pairing of characters\n\nThis pattern appears everywhere in programming - from syntax parsing to expression evaluation - so you're building a truly valuable skill that will serve you well beyond coding interviews!\n\nLet's dive in!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Before we dive into the problem, which programming language would you like to use?\n\nThis will help me make sure you have the right building blocks.",
      "choices": [
        {
          "label": "ðŸ’› JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "ðŸ Python",
          "next": "prereq-check-python"
        },
        {
          "label": "â˜• Java",
          "next": "prereq-check-java"
        },
        {
          "label": "âš¡ C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "ðŸ’™ TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in JavaScript, you'll need to know:\n- **Stack data structure** - Understanding stack operations (push, pop, peek) and LIFO principle\n- **String traversal** - Iterating through string characters using loops\n- **Character matching** - Comparing and matching corresponding opening and closing bracket characters\n- **Conditional logic** - Using if-else statements to handle different bracket types and validation cases\n\nDo you feel confident with these JavaScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-js"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Python, you'll need to know:\n- **Stack data structure** - Understanding stack operations (push, pop, peek) and LIFO principle\n- **String traversal** - Iterating through string characters using loops\n- **Character matching** - Comparing and matching corresponding opening and closing bracket characters\n- **Conditional logic** - Using if-else statements to handle different bracket types and validation cases\n\nDo you feel confident with these Python concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-python"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Java, you'll need to know:\n- **Stack data structure** - Understanding stack operations (push, pop, peek) and LIFO principle\n- **String traversal** - Iterating through string characters using loops\n- **Character matching** - Comparing and matching corresponding opening and closing bracket characters\n- **Conditional logic** - Using if-else statements to handle different bracket types and validation cases\n\nDo you feel confident with these Java concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-java"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in C++, you'll need to know:\n- **Stack data structure** - Understanding stack operations (push, pop, peek) and LIFO principle\n- **String traversal** - Iterating through string characters using loops\n- **Character matching** - Comparing and matching corresponding opening and closing bracket characters\n- **Conditional logic** - Using if-else statements to handle different bracket types and validation cases\n\nDo you feel confident with these C++ concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in TypeScript, you'll need to know:\n- **Stack data structure** - Understanding stack operations (push, pop, peek) and LIFO principle\n- **String traversal** - Iterating through string characters using loops\n- **Character matching** - Comparing and matching corresponding opening and closing bracket characters\n- **Conditional logic** - Using if-else statements to handle different bracket types and validation cases\n\nDo you feel confident with these TypeScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "Perfect! Now let's understand what the Valid Parentheses problem asks for.\n\nImagine you're packing nested containers for moving - first you put small boxes inside medium boxes, then medium boxes inside large boxes. To pack properly, every container you open must be closed in reverse order: if you open largeâ†’mediumâ†’small containers, you must close them smallâ†’mediumâ†’large. The algorithm works like your packing checklist - using a stack to track which containers are still open, ensuring each closing container matches the most recently opened one.\n\n# Valid Parentheses Problem\n\nHey! So this problem is asking you to check if a string of parentheses is \"valid\" - meaning they're properly opened and closed in the right order.\n\n## What does \"valid\" mean?\n\nA string is valid when:\n1. **Every opening bracket has a matching closing bracket**\n2. **They're closed in the correct order** (no crossing over)\n3. **The types match** - `(` matches with `)`, `[` matches with `]`, `{` matches with `}`\n\n## Example: `\"{[]}\"`\n\nLet's trace through why `\"{[]}\"` returns `true`:\n\n```\n\"{[]}\"\n ^     Start with opening curly brace {\n  ^    Then opening square bracket [\n   ^   Then closing square bracket ] - this matches the [ we just opened âœ“\n    ^  Finally closing curly brace } - this matches the { from the beginning âœ“\n```\n\nIt works because we're closing brackets in the reverse order we opened them - like putting on clothes and then taking them off! You put on socks then shoes, so you take off shoes then socks.\n\n## Why this matters\n\nThe key insight is that valid parentheses follow a **\"last opened, first closed\"** pattern. That's why a stack data structure is perfect here - it naturally handles this last-in-first-out behavior.\n\n**Invalid example:** `\"([)]\"` \n- We open `(` then `[`, but then we try to close `)` before closing the `[` - that's crossing over and breaks the rule!\n\nMake sense? The problem is basically asking you to be a syntax checker for brackets!",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "You're checking if a string of parentheses like '({[]})' is valid. When you encounter a closing bracket ']', what should your algorithm do to determine if the parentheses are properly matched?",
      "choices": [
        {
          "label": "Count how many opening brackets '[' appeared earlier in the string and decrement the counter",
          "next": "wrong-choice"
        },
        {
          "label": "Pop the most recent opening bracket from a stack and verify it matches the closing bracket ']'",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-choice",
      "mentorSays": "This approach fails because it doesn't track the order of brackets. For example, '([)]' would incorrectly appear valid since it has equal counts of each bracket type, but the brackets are actually interleaved incorrectly. Counting doesn't preserve the nested structure required for valid parentheses.",
      "action": "next",
      "next": "pattern-recognition"
    },
    {
      "stepId": "pattern-recognition",
      "mentorSays": "### Pattern Recognition: Stack-Based Matching\n\n**This problem follows the \"last opened, first closed\" pattern:**\n- **Stack data structure** - Perfect for LIFO (Last-In-First-Out) behavior\n- **Matching pairs** - Each closing bracket must match the most recently opened bracket\n- **Nested structure** - Brackets can be nested, but must close in reverse order\n\n**Similar problems:**\n- Valid Parentheses II (with wildcards)\n- Remove Invalid Parentheses (backtracking variant)\n- Decode String (nested structures)\n- Basic Calculator (expression parsing)\n\n**Key insight:** The stack naturally handles the \"last opened, first closed\" requirement - when we see a closing bracket, it must match the top of the stack (most recently opened).",
      "action": "next",
      "next": "invariant"
    },
    {
      "stepId": "invariant",
      "mentorSays": "### Invariant: Stack Contains Unmatched Opening Brackets\n\n**Invariant maintained throughout:**\n- **Stack** contains only opening brackets that haven't been matched yet\n- **Order:** The top of the stack is the most recently opened bracket\n- **Matching rule:** A closing bracket must match the bracket at the top of the stack\n\n**Why this works:**\n- Opening brackets are pushed onto the stack\n- Closing brackets pop from the stack and must match the popped bracket\n- If stack is empty when we see a closing bracket, it's invalid\n- If stack is not empty at the end, we have unmatched opening brackets\n\n**Invariant guarantee:** After processing character `i`, the stack contains all unmatched opening brackets from `s[0..i]`, in order of opening (most recent on top).",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "The key insight is to use a **stack data structure** to track opening brackets and **match them with their corresponding closing brackets** in reverse order. This works because parentheses must be closed in the **Last-In-First-Out (LIFO)** order - the most recently opened bracket must be closed first. For example, in `\"([{}])\"`, we push `(`, `[`, `{`, then when we see `}` we pop and match it with `{`, continue popping to match `]` with `[`, and finally `)` with `(`. The string is valid only if all brackets match and the stack is empty at the end.",
      "action": "next",
      "next": "walkthrough",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "Let's trace through `\"{[]}\"`:\n- Step 1: Initialize empty stack, start with first character '{'\n- Step 2: '{' is opening bracket, push onto stack â†’ stack: ['{']\n- Step 3: '[' is opening bracket, push onto stack â†’ stack: ['{', '[']\n- Step 4: ']' is closing bracket, pop '[' from stack (they match) â†’ stack: ['{']\n- Step 5: '}' is closing bracket, pop '{' from stack (they match) â†’ stack: []\n- Step 6: Finished processing all characters, stack is empty\n- Final: **true**",
      "action": "next",
      "next": "pseudocode-step",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "Here's our plan written as pseudocode:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now let's translate this into JavaScript, building it step by step.\n\nRemember: we'll add just 1-3 lines at a time!",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Create function signature and initialize empty stack array\n\n```javascript\nfunction isValid(s) {\n    const stack = [];\n}\n```",
      "action": "next",
      "next": "code-02",
      "pseudocodeLineIds": [
        "ps1"
      ],
      "example": "function isValid(s) {\n    const stack = [];\n}"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Create mapping object for bracket pairs\n\n```javascript\nfunction isValid(s) {\n    const stack = [];\n    const pairs = { ')': '(', '}': '{', ']': '[' };\n}\n```",
      "action": "next",
      "next": "code-03",
      "pseudocodeLineIds": [
        "ps2"
      ],
      "example": "    const pairs = { ')': '(', '}': '{', ']': '[' };"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Start for loop to iterate through each character\n\n```javascript\nfunction isValid(s) {\n    const stack = [];\n    const pairs = { ')': '(', '}': '{', ']': '[' };\n    \n    for (let char of s) {\n    }\n}\n```",
      "action": "next",
      "next": "code-04",
      "pseudocodeLineIds": [
        "ps3"
      ],
      "example": "    for (let char of s) {\n    }"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Check if character is opening bracket and push to stack\n\n```javascript\nfunction isValid(s) {\n    const stack = [];\n    const pairs = { ')': '(', '}': '{', ']': '[' };\n    \n    for (let char of s) {\n        if (char === '(' || char === '{' || char === '[') {\n            stack.push(char);\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-05",
      "pseudocodeLineIds": [
        "ps4"
      ],
      "example": "        if (char === '(' || char === '{' || char === '[') {\n            stack.push(char);\n        }"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Handle closing brackets - check if stack is empty first\n\n```javascript\nfunction isValid(s) {\n    const stack = [];\n    const pairs = { ')': '(', '}': '{', ']': '[' };\n    \n    for (let char of s) {\n        if (char === '(' || char === '{' || char === '[') {\n            stack.push(char);\n        } else {\n            if (stack.length === 0) return false;\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-06",
      "pseudocodeLineIds": [
        "ps5"
      ],
      "example": "        } else {\n            if (stack.length === 0) return false;"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Pop from stack and check if it matches the closing bracket\n\n```javascript\nfunction isValid(s) {\n    const stack = [];\n    const pairs = { ')': '(', '}': '{', ']': '[' };\n    \n    for (let char of s) {\n        if (char === '(' || char === '{' || char === '[') {\n            stack.push(char);\n        } else {\n            if (stack.length === 0) return false;\n            if (stack.pop() !== pairs[char]) return false;\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-07",
      "pseudocodeLineIds": [
        "ps6"
      ],
      "example": "            if (stack.pop() !== pairs[char]) return false;"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Return true only if stack is empty (all brackets matched)\n\n```javascript\nfunction isValid(s) {\n    const stack = [];\n    const pairs = { ')': '(', '}': '{', ']': '[' };\n    \n    for (let char of s) {\n        if (char === '(' || char === '{' || char === '[') {\n            stack.push(char);\n        } else {\n            if (stack.length === 0) return false;\n            if (stack.pop() !== pairs[char]) return false;\n        }\n    }\n    \n    return stack.length === 0;\n}\n```",
      "action": "next",
      "next": "common-mistakes",
      "pseudocodeLineIds": [
        "ps7"
      ],
      "example": "    return stack.length === 0;"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "Great work mastering the Valid Parentheses problem! You've successfully implemented the classic stack-based bracket matching pattern, which is fundamental for parsing and validation tasks. Next, we'll tackle the Climbing Stairs problem, where you'll explore dynamic programming concepts to find optimal ways to reach your destination.\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}