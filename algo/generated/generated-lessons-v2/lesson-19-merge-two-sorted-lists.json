{
  "id": "merge-two-sorted-lists",
  "title": "Merge Two Sorted Lists",
  "pattern": "merge pattern",
  "difficulty": "easy",
  "language": "javascript",
  "status": "AI-GENERATED-V2-BATCH",
  "standardsVersion": "lessonStandards.v2-inpact",
  "curriculum": {
    "lessonNumber": 19,
    "tier": "FOUNDATION",
    "lessonOrderTag": "FOUNDATION-19",
    "introduces": [
      "dummy-head-technique",
      "tail-pointer",
      "list-comparison"
    ],
    "assumesAlreadyTaught": [
      "linked-list-concept",
      "comparison-operators"
    ],
    "prerequisiteCheckRequired": true,
    "nextRecommended": [
      "palindrome-linked-list"
    ]
  },
  "problemStatement": {
    "description": "Merge two sorted linked lists into one sorted linked list. Return the head of the merged list.",
    "inputs": [
      "list1: head of first sorted linked list (can be null)",
      "list2: head of second sorted linked list (can be null)"
    ],
    "outputs": [
      "Node: head of the merged sorted linked list"
    ],
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]",
        "explanation": "Compare heads: 1==1, take first 1. Compare: 1<2, take second 1. Compare: 2<3, take 2. Continue merging."
      },
      {
        "input": "list1 = [], list2 = [0]",
        "output": "[0]",
        "explanation": "list1 is empty, return list2."
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]",
        "explanation": "Both empty, return null."
      }
    ],
    "constraints": [
      "Number of nodes in both lists is in range [0, 50]",
      "-100 <= Node.val <= 100",
      "Both list1 and list2 are sorted in non-decreasing order"
    ],
    "realWorldUse": [
      "Merging sorted data structures",
      "Database merge operations",
      "Combining sorted sequences",
      "Linked list manipulation"
    ]
  },
  "patternRecognition": {
    "whyThisPattern": "Since both lists are sorted, we can merge them by comparing the current heads and always choosing the smaller value. The dummy node technique simplifies edge cases.",
    "signalsToRecognize": [
      "SIGNAL 1: Problem asks to merge sorted linked lists â†’ think two-pointer merge",
      "SIGNAL 2: Both lists are sorted â†’ compare heads, choose smaller",
      "SIGNAL 3: Need to handle edge cases â†’ use dummy node technique"
    ],
    "patternRules": [
      "If problem involves merging sorted sequences â†’ use two-pointer merge",
      "When you see 'merge sorted', 'combine sorted', or 'two sorted lists' â†’ consider merge pattern",
      "If need to simplify edge cases â†’ use dummy node as anchor"
    ],
    "whyNotOtherApproaches": {
      "greedy": "Actually uses greedy approach - at each step, choose the smaller head. This is the greedy merge pattern.",
      "bruteForce": "Creating new list and finding minimum repeatedly is O(nÂ²). Two-pointer merge is O(n) and optimal.",
      "alternative": "Converting to arrays, merging, then converting back works but is inefficient. Direct merge is better."
    }
  },
  "coreInvariant": {
    "statement": "The merged list built from dummy.next is always sorted, and current points to the last node in the merged list. At each step, we attach the smaller of the two current heads.",
    "explanation": "This invariant holds because both input lists are sorted, so comparing heads and choosing the smaller value guarantees the merged list remains sorted. The dummy node provides a consistent starting point.",
    "whyItMatters": "This invariant guarantees correctness: after processing, the merged list contains all elements from both lists in sorted order, with dummy.next pointing to the head."
  },
  "stateDefinition": {
    "states": [
      {
        "name": "dummy",
        "meaning": "Dummy node serving as anchor for the merged list",
        "indexing": "Created node with value 0, dummy.next will be the result head"
      },
      {
        "name": "current",
        "meaning": "Pointer to the last node in the merged list",
        "indexing": "Starts at dummy, moves as we attach nodes"
      },
      {
        "name": "list1",
        "meaning": "Current head of first sorted list",
        "indexing": "Moves forward as we take nodes from it"
      },
      {
        "name": "list2",
        "meaning": "Current head of second sorted list",
        "indexing": "Moves forward as we take nodes from it"
      }
    ],
    "baseCases": [
      "If list1 is null: return list2",
      "If list2 is null: return list1",
      "If both null: return null"
    ]
  },
  "transitionLogic": {
    "rules": [
      {
        "condition": "While list1 != null and list2 != null:",
        "transition": "Compare list1.val and list2.val, attach smaller to current.next, advance that list",
        "explanation": "Always choose the smaller head to maintain sorted order. Attach it to merged list and move forward.",
        "example": "If list1.val=1, list2.val=2: attach list1, then list1 = list1.next"
      },
      {
        "condition": "After main loop, if list1 != null:",
        "transition": "current.next = list1 (attach remaining nodes from list1)",
        "explanation": "One list exhausted, attach remaining nodes from the other list (they're already sorted).",
        "example": "If list1 has remaining nodes, attach them all at once"
      },
      {
        "condition": "After main loop, if list2 != null:",
        "transition": "current.next = list2 (attach remaining nodes from list2)",
        "explanation": "Same as above, attach remaining from list2.",
        "example": "If list2 has remaining nodes, attach them all at once"
      }
    ],
    "decisionTree": {
      "root": "Compare current heads of both lists",
      "branches": [
        "If list1.val <= list2.val: attach list1, list1 = list1.next",
        "Else: attach list2, list2 = list2.next",
        "After loop: attach remaining nodes from non-empty list",
        "Return dummy.next (head of merged list)"
      ]
    }
  },
  "walkthrough": {
    "example": "list1 = [1,2,4], list2 = [1,3,4]",
    "steps": [
      {
        "step": 1,
        "description": "Initialize: dummy = new Node(0), current = dummy",
        "state": "dummy = 0, current = dummy, list1 = 1â†’2â†’4, list2 = 1â†’3â†’4",
        "logic": "Create dummy node as anchor",
        "result": "Ready to merge"
      },
      {
        "step": 2,
        "description": "Compare: list1.val=1, list2.val=1, attach list1, current = node 1",
        "state": "dummyâ†’1, current = node 1, list1 = 2â†’4, list2 = 1â†’3â†’4",
        "logic": "Equal values, take from list1",
        "result": "Merged: [1]"
      },
      {
        "step": 3,
        "description": "Compare: list1.val=2, list2.val=1, attach list2, current = node 1 (from list2)",
        "state": "dummyâ†’1â†’1, current = node 1 (list2), list1 = 2â†’4, list2 = 3â†’4",
        "logic": "list2.val is smaller, attach it",
        "result": "Merged: [1,1]"
      },
      {
        "step": 4,
        "description": "Compare: list1.val=2, list2.val=3, attach list1, current = node 2",
        "state": "dummyâ†’1â†’1â†’2, current = node 2, list1 = 4, list2 = 3â†’4",
        "logic": "list1.val is smaller",
        "result": "Merged: [1,1,2]"
      },
      {
        "step": 5,
        "description": "Compare: list1.val=4, list2.val=3, attach list2, current = node 3",
        "state": "dummyâ†’1â†’1â†’2â†’3, current = node 3, list1 = 4, list2 = 4",
        "logic": "list2.val is smaller",
        "result": "Merged: [1,1,2,3]"
      },
      {
        "step": 6,
        "description": "Compare: list1.val=4, list2.val=4, attach list1, current = node 4",
        "state": "dummyâ†’1â†’1â†’2â†’3â†’4, current = node 4, list1 = null, list2 = 4",
        "logic": "Equal values, take from list1",
        "result": "Merged: [1,1,2,3,4]"
      },
      {
        "step": 7,
        "description": "list1 is null, attach remaining: current.next = list2",
        "state": "dummyâ†’1â†’1â†’2â†’3â†’4â†’4, list2 exhausted",
        "logic": "Attach remaining nodes from list2",
        "result": "Return dummy.next = [1,1,2,3,4,4]"
      }
    ],
    "keyInsight": "The dummy node technique simplifies edge cases by providing a consistent starting point. By always comparing the current heads and choosing the smaller value, we maintain sorted order. Attaching remaining nodes at the end handles unequal list lengths efficiently."
  },
  "commonMistakes": [
    {
      "mistake": "Not using dummy node",
      "symptom": "Complex edge case handling, may return wrong head",
      "fix": "Use dummy node as anchor, return dummy.next as result head",
      "example": "Without dummy, need special handling when first node is chosen"
    },
    {
      "mistake": "Not handling remaining nodes after main loop",
      "symptom": "Missing nodes when one list is longer",
      "fix": "After loop, attach remaining nodes: current.next = list1 or list2",
      "example": "If list1 has remaining nodes, attach them all at once"
    },
    {
      "mistake": "Creating new nodes instead of reusing existing",
      "symptom": "Uses extra space unnecessarily",
      "fix": "Attach existing nodes: current.next = list1 (not new Node(list1.val))",
      "example": "Reuse nodes from input lists, don't create copies"
    },
    {
      "mistake": "Not advancing pointer after attaching node",
      "symptom": "Infinite loop or wrong result",
      "fix": "After current.next = list1, do list1 = list1.next and current = current.next",
      "example": "Must advance both current and the list pointer"
    },
    {
      "mistake": "Comparing wrong values or not handling null",
      "symptom": "Null pointer exception or wrong comparison",
      "fix": "Check list1 != null and list2 != null in loop condition, compare list1.val and list2.val",
      "example": "Accessing .val on null causes error"
    }
  ],
  "interviewTalkTrack": {
    "script": [
      "This is a two-pointer merge problem using a dummy node.",
      "",
      "I'll merge the sorted lists:",
      "- Create dummy node, current = dummy",
      "- While list1 != null and list2 != null:",
      "  - If list1.val <= list2.val: current.next = list1, list1 = list1.next",
      "  - Else: current.next = list2, list2 = list2.next",
      "  - current = current.next",
      "- Attach remaining: current.next = list1 or list2 (whichever is not null)",
      "- Return dummy.next",
      "",
      "Time complexity: O(n+m) - process each node once",
      "Space complexity: O(1) - only using pointers, reusing existing nodes",
      "",
      "Edge cases:",
      "- One list empty: return the other list",
      "- Both empty: return null",
      "- Dummy node simplifies head management"
    ]
  },
  "variants": {
    "easier": {
      "problem": "Merge Two Sorted Arrays",
      "approachChange": "Same logic but with arrays, can use indices instead of pointers",
      "solution": "Use two indices i and j, compare nums1[i] and nums2[j], place smaller in result array"
    },
    "harder": {
      "problem": "Merge K Sorted Lists",
      "approachChange": "Need to merge k lists instead of 2. Use min heap to always pick smallest head.",
      "solution": "Use min heap storing (value, list_index). Pop smallest, add next from same list. O(nk log k) time."
    }
  },
  "pseudocode": [
    {
      "id": "ps1",
      "text": "Create dummy = new Node(0), current = dummy"
    },
    {
      "id": "ps2",
      "text": "While list1 != null and list2 != null:"
    },
    {
      "id": "ps3",
      "text": "  If list1.val <= list2.val: current.next = list1, list1 = list1.next"
    },
    {
      "id": "ps4",
      "text": "  Else: current.next = list2, list2 = list2.next"
    },
    {
      "id": "ps5",
      "text": "  current = current.next"
    },
    {
      "id": "ps6",
      "text": "Attach remaining: current.next = list1 or list2 (whichever is not null)"
    },
    {
      "id": "ps7",
      "text": "Return dummy.next"
    }
  ],
  "flow": [
    {
      "stepId": "objectives",
      "mentorSays": "Hey! Ready to tackle another essential linked list pattern? Today we're exploring the **merge pattern** - a powerful technique for combining two sorted linked lists into one beautifully organized list.\n\nHere's what you'll master:\n\nâ€¢ **Two-pointer coordination** - smoothly navigate through both lists simultaneously\nâ€¢ **Comparison logic** - decide which node comes next while maintaining sorted order  \nâ€¢ **Link reconstruction** - build your new merged list by rewiring node connections\n\nThis pattern shows up everywhere in coding interviews and real-world applications, so you're building some serious problem-solving muscle here. Let's dive in!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Before we dive into the problem, which programming language would you like to use?\n\nThis will help me make sure you have the right building blocks.",
      "choices": [
        {
          "label": "ðŸ’› JavaScript",
          "next": "prereq-check-js"
        },
        {
          "label": "ðŸ Python",
          "next": "prereq-check-python"
        },
        {
          "label": "â˜• Java",
          "next": "prereq-check-java"
        },
        {
          "label": "âš¡ C++",
          "next": "prereq-check-cpp"
        },
        {
          "label": "ðŸ’™ TypeScript",
          "next": "prereq-check-ts"
        }
      ]
    },
    {
      "stepId": "prereq-check-js",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in JavaScript, you'll need to know:\n- **Linked-list-concept** - Understanding of singly linked lists with nodes containing data and next pointers\n- **Comparison-operators** - Knowledge of comparison operators to determine ordering between elements\n- **Pointer-manipulation** - Ability to modify next pointers to restructure linked list connections\n- **Two-pointer-technique** - Using multiple pointers to traverse and compare elements from different data structures\n\nDo you feel confident with these JavaScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-js"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-js"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-js",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-js",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Objects/Maps:** `const map = {}` creates a map. `map[key] = value` stores, `map[key]` retrieves, `key in map` checks existence.\n\n**Functions:** `function name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-python",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Python, you'll need to know:\n- **Linked-list-concept** - Understanding of singly linked lists with nodes containing data and next pointers\n- **Comparison-operators** - Knowledge of comparison operators to determine ordering between elements\n- **Pointer-manipulation** - Ability to modify next pointers to restructure linked list connections\n- **Two-pointer-technique** - Using multiple pointers to traverse and compare elements from different data structures\n\nDo you feel confident with these Python concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-python"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-python"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-python",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Lists:** Use `[]` to create, `lst[i]` to access, `len(lst)` for size.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-python",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Lists:** `lst = [1, 2, 3]` creates a list. `lst[0]` accesses first element.\n\n**Loops:** `for i in range(len(lst))` iterates through list.\n\n**Dictionaries:** `dict = {}` creates a dict. `dict[key] = value` stores, `dict[key]` retrieves, `key in dict` checks existence.\n\n**Functions:** `def name(params): return value` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-java",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in Java, you'll need to know:\n- **Linked-list-concept** - Understanding of singly linked lists with nodes containing data and next pointers\n- **Comparison-operators** - Knowledge of comparison operators to determine ordering between elements\n- **Pointer-manipulation** - Ability to modify next pointers to restructure linked list connections\n- **Two-pointer-technique** - Using multiple pointers to traverse and compare elements from different data structures\n\nDo you feel confident with these Java concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-java"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-java"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-java",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `int[] arr = new int[size]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-java",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `int[] arr = {1, 2, 3}` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.length; i++)` iterates through array.\n\n**HashMaps:** `Map<K, V> map = new HashMap<>()` creates a map. `map.put(key, value)` stores, `map.get(key)` retrieves, `map.containsKey(key)` checks existence.\n\n**Functions:** `public returnType name(params) { return value; }` defines a method.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-cpp",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in C++, you'll need to know:\n- **Linked-list-concept** - Understanding of singly linked lists with nodes containing data and next pointers\n- **Comparison-operators** - Knowledge of comparison operators to determine ordering between elements\n- **Pointer-manipulation** - Ability to modify next pointers to restructure linked list connections\n- **Two-pointer-technique** - Using multiple pointers to traverse and compare elements from different data structures\n\nDo you feel confident with these C++ concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-cpp"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-cpp"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-cpp",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `vector<int> arr` to create, `arr[i]` to access, `arr.size()` for size.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through array.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-cpp",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Vectors:** `vector<int> arr = {1, 2, 3}` creates a vector. `arr[0]` accesses first element.\n\n**Loops:** `for (int i = 0; i < arr.size(); i++)` iterates through vector.\n\n**Maps:** `unordered_map<K, V> map` creates a map. `map[key] = value` stores, `map[key]` retrieves, `map.count(key)` checks existence.\n\n**Functions:** `returnType name(params) { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "prereq-check-ts",
      "mentorSays": "Great choice! Before we tackle this problem, let me make sure you have the building blocks.\n\nTo solve this in TypeScript, you'll need to know:\n- **Linked-list-concept** - Understanding of singly linked lists with nodes containing data and next pointers\n- **Comparison-operators** - Knowledge of comparison operators to determine ordering between elements\n- **Pointer-manipulation** - Ability to modify next pointers to restructure linked list connections\n- **Two-pointer-technique** - Using multiple pointers to traverse and compare elements from different data structures\n\nDo you feel confident with these TypeScript concepts?",
      "choices": [
        {
          "label": "Yes, I know all of them",
          "next": "problem-understanding"
        },
        {
          "label": "No, please explain them",
          "next": "teach-prereqs-ts"
        },
        {
          "label": "I know some, not all",
          "next": "select-prereqs-ts"
        }
      ]
    },
    {
      "stepId": "teach-prereqs-ts",
      "mentorSays": "Let me give you a quick refresher on the key concepts:\n\n**Arrays:** Use `[]` to create, `arr[i]` to access, `arr.length` for size.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue with the lesson!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "select-prereqs-ts",
      "mentorSays": "Here's a quick refresher on the key concepts you'll need:\n\n**Arrays:** `const arr: number[] = [1, 2, 3]` creates an array. `arr[0]` accesses first element.\n\n**Loops:** `for (let i = 0; i < arr.length; i++)` iterates through array.\n\n**Maps:** `const map = new Map<K, V>()` creates a map. `map.set(key, value)` stores, `map.get(key)` retrieves, `map.has(key)` checks existence.\n\n**Functions:** `function name(params): returnType { return value; }` defines a function.\n\nLet's continue!",
      "action": "continue",
      "next": "problem-understanding"
    },
    {
      "stepId": "problem-understanding",
      "mentorSays": "Perfect! Now let's understand what the Merge Two Sorted Lists problem asks for.\n\nImagine you have two stacks of graded test papers, each already sorted from highest to lowest score, and you need to merge them into one sorted stack. You compare the top paper from each stack, take the one with the higher score and place it on your new pile, then repeat this process until both original stacks are empty, creating one perfectly sorted stack from highest to lowest.\n\n# Merge Two Sorted Lists\n\n## What the problem asks\n\nYou're given two linked lists that are already sorted in ascending order. Your job is to merge them into one new sorted linked list and return it. Think of it like combining two ordered stacks of cards into one perfectly ordered stack.\n\n## Example\n\nLet's say you have:\n- **l1**: 1 â†’ 2 â†’ 4\n- **l2**: 1 â†’ 3 â†’ 4\n\nAfter merging, you should get:\n- **Result**: 1 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 4\n\n## Why this example works\n\nHere's the step-by-step thinking:\n\n1. Compare the first nodes: 1 (from l1) vs 1 (from l2) â†’ both are equal, so we can pick either. Let's take from l1 first.\n\n2. Now compare 2 (from l1) vs 1 (from l2) â†’ 1 is smaller, so take it from l2.\n\n3. Compare 2 (from l1) vs 3 (from l2) â†’ 2 is smaller, take it from l1.\n\n4. Compare 4 (from l1) vs 3 (from l2) â†’ 3 is smaller, take it from l2.\n\n5. Compare 4 (from l1) vs 4 (from l2) â†’ equal again, take from l1.\n\n6. l1 is done, so just append the remaining 4 from l2.\n\nThe key insight is that since both lists are already sorted, you only need to compare the \"front\" elements and always pick the smaller one. It's like merging two sorted arrays, but with linked list pointers instead!",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "You need to merge two sorted linked lists [1,2,4] and [1,3,4]. How would YOU approach building the result list while maintaining sorted order?",
      "choices": [
        {
          "label": "Create a new result list, then repeatedly find and remove the minimum element from either list",
          "next": "wrong-choice"
        },
        {
          "label": "Use a dummy node as anchor, then compare the current heads of both lists, attach the smaller one, and advance that list's pointer",
          "next": "core-idea"
        }
      ]
    },
    {
      "stepId": "wrong-choice",
      "mentorSays": "This approach works but is inefficient - finding and removing elements from the middle of linked lists requires O(n) traversal each time. You're not leveraging the fact that both lists are already sorted, leading to O(nÂ²) complexity instead of O(n).",
      "action": "next",
      "next": "pattern-recognition"
    },
    {
      "stepId": "pattern-recognition",
      "mentorSays": "### Pattern Recognition: Two-Pointer Merge\n\n**This problem follows the \"merge two sorted sequences\" pattern:**\n- **Two-pointer technique** - Maintain pointers in both lists, always choose the smaller element\n- **Dummy node pattern** - Use dummy node to simplify edge cases and pointer management\n- **In-place merging** - Build result by linking nodes, not creating new ones\n\n**Similar problems:**\n- Merge K Sorted Lists (extend to multiple lists)\n- Merge Sorted Array (same pattern with arrays)\n- Merge Intervals (different but uses similar merging logic)\n\n**Key insight:** Since both lists are sorted, we only need to compare the current heads and always pick the smaller one - this guarantees the result is sorted.",
      "action": "next",
      "next": "invariant"
    },
    {
      "stepId": "invariant",
      "mentorSays": "### Invariant: Result List Remains Sorted\n\n**Invariant maintained throughout:**\n- **Result list** (built from `dummy.next`) is always sorted\n- **Current pointer** points to the last node in the merged result\n- **Both input lists** remain sorted (we only read from their heads)\n\n**Why this works:**\n- At each step, we compare `list1.val` and `list2.val`\n- We attach the smaller value to `current.next`\n- Since both lists are sorted, the smaller value is guaranteed to be the next element in sorted order\n- We advance the pointer of the list we took from\n\n**Invariant guarantee:** After processing `i` nodes, the first `i` nodes of the result list are sorted and contain the `i` smallest elements from both input lists.",
      "action": "next",
      "next": "core-idea"
    },
    {
      "stepId": "core-idea",
      "mentorSays": "The key insight is to use a **dummy node** as a starting point to simplify edge case handling when merging two sorted linked lists. By comparing the heads of both lists, attaching the smaller node to your result chain, and advancing the corresponding pointer, you maintain the sorted order throughout the merge process. The **dummy node** eliminates the need for special logic to handle empty lists or determine the actual head of the merged result. This approach works because you're essentially building a new sorted chain by always choosing the next smallest available element from either input list.",
      "action": "next",
      "next": "walkthrough"
    },
    {
      "stepId": "walkthrough",
      "mentorSays": "Let's trace through `l1: 1â†’2â†’4, l2: 1â†’3â†’4`:\n\n- Step 1: Create dummy node, set pointers: dummyâ†’null, current=dummy, l1=1, l2=1\n- Step 2: Compare l1.val(1) â‰¤ l2.val(1), link currentâ†’l1(1), move current and l1\n- Step 3: Compare l1.val(2) â‰¤ l2.val(1), link currentâ†’l2(1), move current and l2\n- Step 4: Compare l1.val(2) â‰¤ l2.val(3), link currentâ†’l1(2), move current and l1\n- Step 5: Compare l1.val(4) > l2.val(3), link currentâ†’l2(3), move current and l2\n- Step 6: Compare l1.val(4) â‰¤ l2.val(4), link currentâ†’l1(4), move current and l1\n- Step 7: l1 is null, append remaining l2(4) to current\n- Final answer: **1â†’1â†’2â†’3â†’4â†’4**",
      "action": "next",
      "next": "pseudocode-step",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3"
      ]
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "Here's our plan written as pseudocode:",
      "action": "next",
      "next": "coding-intro",
      "pseudocodeLineIds": [
        "ps1",
        "ps2",
        "ps3",
        "ps4",
        "ps5",
        "ps6",
        "ps7"
      ]
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now let's translate this into JavaScript, building it step by step.\n\nRemember: we'll add just 1-3 lines at a time!",
      "action": "next",
      "next": "code-01"
    },
    {
      "stepId": "code-01",
      "mentorSays": "Initialize dummy node and current pointer to simplify edge cases\n\n```javascript\nfunction mergeTwoLists(list1, list2) {\n    let dummy = new ListNode(0);\n    let current = dummy;\n}\n```",
      "action": "next",
      "next": "code-02",
      "pseudocodeLineIds": [
        "ps1"
      ],
      "example": "let dummy = new ListNode(0);\nlet current = dummy;"
    },
    {
      "stepId": "code-02",
      "mentorSays": "Start main loop - continue while both lists have nodes\n\n```javascript\nfunction mergeTwoLists(list1, list2) {\n    let dummy = new ListNode(0);\n    let current = dummy;\n    \n    while (list1 && list2) {\n    }\n}\n```",
      "action": "next",
      "next": "code-03",
      "pseudocodeLineIds": [
        "ps2"
      ],
      "example": "while (list1 && list2) {\n}"
    },
    {
      "stepId": "code-03",
      "mentorSays": "Compare heads and attach the smaller node to result\n\n```javascript\nfunction mergeTwoLists(list1, list2) {\n    let dummy = new ListNode(0);\n    let current = dummy;\n    \n    while (list1 && list2) {\n        if (list1.val <= list2.val) {\n            current.next = list1;\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-04",
      "pseudocodeLineIds": [
        "ps3"
      ],
      "example": "if (list1.val <= list2.val) {\n    current.next = list1;\n}"
    },
    {
      "stepId": "code-04",
      "mentorSays": "Advance the pointer in the selected list\n\n```javascript\nfunction mergeTwoLists(list1, list2) {\n    let dummy = new ListNode(0);\n    let current = dummy;\n    \n    while (list1 && list2) {\n        if (list1.val <= list2.val) {\n            current.next = list1;\n            list1 = list1.next;\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-05",
      "pseudocodeLineIds": [
        "ps4"
      ],
      "example": "list1 = list1.next;"
    },
    {
      "stepId": "code-05",
      "mentorSays": "Handle the case where list2 has the smaller value\n\n```javascript\nfunction mergeTwoLists(list1, list2) {\n    let dummy = new ListNode(0);\n    let current = dummy;\n    \n    while (list1 && list2) {\n        if (list1.val <= list2.val) {\n            current.next = list1;\n            list1 = list1.next;\n        } else {\n            current.next = list2;\n            list2 = list2.next;\n        }\n    }\n}\n```",
      "action": "next",
      "next": "code-06",
      "pseudocodeLineIds": [
        "ps5"
      ],
      "example": "} else {\n    current.next = list2;\n    list2 = list2.next;\n}"
    },
    {
      "stepId": "code-06",
      "mentorSays": "Advance current pointer after attaching a node\n\n```javascript\nfunction mergeTwoLists(list1, list2) {\n    let dummy = new ListNode(0);\n    let current = dummy;\n    \n    while (list1 && list2) {\n        if (list1.val <= list2.val) {\n            current.next = list1;\n            list1 = list1.next;\n        } else {\n            current.next = list2;\n            list2 = list2.next;\n        }\n        current = current.next;\n    }\n}\n```",
      "action": "next",
      "next": "code-07",
      "pseudocodeLineIds": [
        "ps6"
      ],
      "example": "current = current.next;"
    },
    {
      "stepId": "code-07",
      "mentorSays": "Attach any remaining nodes from either list\n\n```javascript\nfunction mergeTwoLists(list1, list2) {\n    let dummy = new ListNode(0);\n    let current = dummy;\n    \n    while (list1 && list2) {\n        if (list1.val <= list2.val) {\n            current.next = list1;\n            list1 = list1.next;\n        } else {\n            current.next = list2;\n            list2 = list2.next;\n        }\n        current = current.next;\n    }\n    \n    current.next = list1 || list2;\n}\n```",
      "action": "next",
      "next": "code-08",
      "pseudocodeLineIds": [
        "ps7"
      ],
      "example": "current.next = list1 || list2;"
    },
    {
      "stepId": "code-08",
      "mentorSays": "Return merged list, skipping dummy node\n\n```javascript\nfunction mergeTwoLists(list1, list2) {\n    let dummy = new ListNode(0);\n    let current = dummy;\n    \n    while (list1 && list2) {\n        if (list1.val <= list2.val) {\n            current.next = list1;\n            list1 = list1.next;\n        } else {\n            current.next = list2;\n            list2 = list2.next;\n        }\n        current = current.next;\n    }\n    \n    current.next = list1 || list2;\n    return dummy.next;\n}\n```",
      "action": "next",
      "next": "common-mistakes",
      "pseudocodeLineIds": [
        "ps8"
      ],
      "example": "return dummy.next;"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Off-by-one errors** - Check array bounds and loop conditions carefully\n2. **Edge cases** - Handle empty inputs, single elements, and boundary conditions\n3. **Wrong data structure** - Choose the right structure (array, map, set, etc.) for the problem\n4. **Incorrect loop conditions** - Ensure loops terminate correctly\n5. **Type errors** - Make sure variable types match expected operations",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I'll use the optimal approach for this problem\"**\n2. **\"The key insight is [problem-specific insight]\"**\n3. **\"I'll implement this by [main steps]\"**\n4. **\"This gives us [time complexity] time complexity with [space complexity] space\"**\n5. **\"The tradeoff is [any tradeoffs mentioned]\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "Great work mastering the merge pattern! You've learned how to elegantly combine two sorted data structures while maintaining their order - a fundamental skill that appears everywhere from merge sort to database operations. Next, we'll tackle palindrome-linked-list, where you'll explore techniques for analyzing linked list symmetry and structure.\n\n**Follow-up variant:**\n\nHow would you modify this solution if [problem constraint changed]? What would be the new time/space complexity?",
      "action": "complete"
    }
  ]
}