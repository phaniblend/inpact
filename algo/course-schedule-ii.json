{
  "id": "course-schedule-ii",
  "title": "Course Schedule II",
  "pattern": "graph",
  "difficulty": "medium",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what Course Schedule II asks for\n2. Use Kahn's algorithm for topological sort\n3. Build adjacency list and in-degree array\n4. Process courses with no prerequisites first\n5. Return course order or empty array if cycle exists\n6. Implement the solution step by step in your chosen language",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Perfect! Now let's understand what Course Schedule II is asking.\n\n**Problem Definition:**\nThere are a total of `numCourses` courses you have to take, labeled from 0 to numCourses - 1. You are given an array `prerequisites` where prerequisites[i] = [ai, bi] indicates that you must take course bi before course ai.\n\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\n\n**Key Observations:**\n- This is a topological sort problem\n- If there's a cycle, return empty array\n- Use Kahn's algorithm (BFS-based)\n- Process courses with in-degree 0 first\n\n**Example 1:** numCourses = 2, prerequisites = [[1,0]]\n\nGraph: 0 → 1\n\nOrder: [0, 1]\n(Take course 0 first, then course 1)\n\nAnswer: [0, 1]\n\n**Example 2:** numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n\nGraph:\n    0\n   / \\\n  1   2\n   \\ /\n    3\n\nOrder: [0, 1, 2, 3] or [0, 2, 1, 3]\n\nAnswer: [0, 1, 2, 3] (one valid answer)\n\n**Example 3:** numCourses = 2, prerequisites = [[1,0],[0,1]]\n\nGraph: 0 ↔ 1 (cycle!)\n\nCannot complete all courses.\nAnswer: []\n\n**Step-by-step trace (Kahn's algorithm):**\n\nnumCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n\n1. **Build graph and in-degree**:\n   - graph[0] = [1, 2]\n   - graph[1] = [3]\n   - graph[2] = [3]\n   - inDegree = [0, 1, 1, 2]\n\n2. **Initialize queue with in-degree 0**:\n   - queue = [0] (inDegree[0] = 0)\n   - result = []\n\n3. **Process queue**:\n   - Process 0: result = [0]\n     - Reduce in-degree of neighbors: inDegree[1] = 0, inDegree[2] = 0\n     - Add to queue: queue = [1, 2]\n   - Process 1: result = [0, 1]\n     - Reduce in-degree: inDegree[3] = 1\n   - Process 2: result = [0, 1, 2]\n     - Reduce in-degree: inDegree[3] = 0\n     - Add to queue: queue = [3]\n   - Process 3: result = [0, 1, 2, 3]\n\n4. **Check**: result.length == numCourses? Yes! Return [0, 1, 2, 3]\n\n**Key Insight:**\n- Kahn's algorithm uses BFS to process nodes with no incoming edges first\n- Track in-degree for each node\n- If result.length != numCourses, there's a cycle\n- O(V + E) time, O(V + E) space\n\n**What makes this tricky:**\n1. Understanding topological sort\n2. Building graph and in-degree array correctly\n3. Processing nodes with in-degree 0 first\n4. Detecting cycles (result.length != numCourses)\n\n**Common pitfalls:**\n- Not building graph correctly\n- Incorrect in-degree calculation\n- Not detecting cycles\n- Forgetting to reduce in-degree of neighbors",
      "example": "Example 1:\nnumCourses=2, prerequisites=[[1,0]] → [0,1]\n\nExample 2:\nnumCourses=4, prerequisites=[[1,0],[2,0],[3,1],[3,2]] → [0,1,2,3]\n\nExample 3:\nnumCourses=2, prerequisites=[[1,0],[0,1]] → [] (cycle)",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "How would you find the course order?",
      "choices": [
        {
          "label": "Use Kahn's algorithm (BFS)",
          "next": "explore-kahn"
        },
        {
          "label": "Use DFS topological sort",
          "next": "explore-dfs"
        },
        {
          "label": "Try all permutations",
          "next": "explore-brute"
        }
      ]
    },
    {
      "stepId": "explore-dfs",
      "mentorSays": "DFS works but Kahn's algorithm is more intuitive for this problem!",
      "action": "continue",
      "next": "explore-kahn"
    },
    {
      "stepId": "explore-brute",
      "mentorSays": "Trying all permutations is exponential time. Kahn's algorithm is O(V+E)!",
      "action": "continue",
      "next": "explore-kahn"
    },
    {
      "stepId": "explore-kahn",
      "mentorSays": "Excellent! Kahn's algorithm is optimal. Algorithm:\n1. Build graph and in-degree array\n2. Add all nodes with in-degree 0 to queue\n3. Process queue: remove node, reduce in-degree of neighbors\n4. If neighbor's in-degree becomes 0, add to queue\n5. If result.length == numCourses, return result; else return []",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Which language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "variable-check-js"
        },
        {
          "label": "Python",
          "next": "variable-check-python"
        },
        {
          "label": "Java",
          "next": "variable-check-java"
        },
        {
          "label": "C++",
          "next": "variable-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "variable-check-ts"
        }
      ]
    },
    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-js"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-js"
        }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "let graph = [];\nlet inDegree = [];\nlet queue = [];\nlet result = [];",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Do you know what a function is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-js"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-js"
        }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code.",
      "example": "function findOrder(numCourses, prerequisites) {}",
      "action": "continue",
      "next": "parameter-check-js"
    },
    {
      "stepId": "parameter-check-js",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "graph-check-js"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-js"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-js",
      "mentorSays": "Parameters are inputs to a function.",
      "example": "",
      "action": "continue",
      "next": "graph-check-js"
    },
    {
      "stepId": "graph-check-js",
      "mentorSays": "Do you know how to work with graph?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "queue-check-js"
        },
        {
          "label": "No, explain",
          "next": "graph-explanation-js"
        }
      ]
    },
    {
      "stepId": "graph-explanation-js",
      "mentorSays": "A graph has nodes (courses) and edges (prerequisites). We use an adjacency list to represent the graph.",
      "example": "let graph = Array(numCourses).fill(null).map(() => []);\ngraph[0].push(1);  // Course 0 has prerequisite 1",
      "action": "continue",
      "next": "queue-check-js"
    },
    {
      "stepId": "queue-check-js",
      "mentorSays": "Do you know what queue is?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "coding-start-js"
        },
        {
          "label": "No, explain",
          "next": "queue-explanation-js"
        }
      ]
    },
    {
      "stepId": "queue-explanation-js",
      "mentorSays": "A queue is FIFO. We use it to process courses with no prerequisites first.",
      "example": "let queue = [];\nqueue.push(0);  // Add course 0\nlet course = queue.shift();  // Remove first",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Implement findOrder in JS.",
      "example": "function findOrder(numCourses, prerequisites) {}",
      "action": "continue",
      "next": "coding-build-graph-js"
    },
    {
      "stepId": "coding-build-graph-js",
      "mentorSays": "Build adjacency list and in-degree array from prerequisites.",
      "example": "function findOrder(numCourses, prerequisites) {\n  let graph = Array(numCourses).fill(null).map(() => []);\n  let inDegree = Array(numCourses).fill(0);\n  \n  for (let [course, prereq] of prerequisites) {\n    graph[prereq].push(course);\n    inDegree[course]++;\n  }",
      "action": "continue",
      "next": "coding-init-queue-js"
    },
    {
      "stepId": "coding-init-queue-js",
      "mentorSays": "Add all courses with in-degree 0 to the queue.",
      "example": "function findOrder(numCourses, prerequisites) {\n  let graph = Array(numCourses).fill(null).map(() => []);\n  let inDegree = Array(numCourses).fill(0);\n  \n  for (let [course, prereq] of prerequisites) {\n    graph[prereq].push(course);\n    inDegree[course]++;\n  }\n  \n  let queue = [];\n  for (let i = 0; i < numCourses; i++) {\n    if (inDegree[i] === 0) queue.push(i);\n  }",
      "action": "continue",
      "next": "coding-bfs-loop-js"
    },
    {
      "stepId": "coding-bfs-loop-js",
      "mentorSays": "Process queue: remove course, add to result, reduce in-degree of neighbors.",
      "example": "function findOrder(numCourses, prerequisites) {\n  let graph = Array(numCourses).fill(null).map(() => []);\n  let inDegree = Array(numCourses).fill(0);\n  \n  for (let [course, prereq] of prerequisites) {\n    graph[prereq].push(course);\n    inDegree[course]++;\n  }\n  \n  let queue = [];\n  for (let i = 0; i < numCourses; i++) {\n    if (inDegree[i] === 0) queue.push(i);\n  }\n  \n  let result = [];\n  while (queue.length > 0) {\n    let course = queue.shift();\n    result.push(course);\n    \n    for (let neighbor of graph[course]) {\n      inDegree[neighbor]--;\n      if (inDegree[neighbor] === 0) queue.push(neighbor);\n    }\n  }",
      "action": "continue",
      "next": "coding-check-cycle-js"
    },
    {
      "stepId": "coding-check-cycle-js",
      "mentorSays": "Check if all courses were processed. If not, there's a cycle - return empty array.",
      "example": "function findOrder(numCourses, prerequisites) {\n  let graph = Array(numCourses).fill(null).map(() => []);\n  let inDegree = Array(numCourses).fill(0);\n  \n  for (let [course, prereq] of prerequisites) {\n    graph[prereq].push(course);\n    inDegree[course]++;\n  }\n  \n  let queue = [];\n  for (let i = 0; i < numCourses; i++) {\n    if (inDegree[i] === 0) queue.push(i);\n  }\n  \n  let result = [];\n  while (queue.length > 0) {\n    let course = queue.shift();\n    result.push(course);\n    \n    for (let neighbor of graph[course]) {\n      inDegree[neighbor]--;\n      if (inDegree[neighbor] === 0) queue.push(neighbor);\n    }\n  }\n  \n  return result.length === numCourses ? result : [];",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Test cases:\n1. numCourses=2, prerequisites=[[1,0]] → [0,1]\n2. numCourses=4, prerequisites=[[1,0],[2,0],[3,1],[3,2]] → [0,1,2,3] or [0,2,1,3]\n3. numCourses=3, prerequisites=[] → [0,1,2]\n4. numCourses=2, prerequisites=[[1,0],[0,1]] → []\n5. numCourses=1, prerequisites=[] → [0]\n6. Complex graph with multiple valid orders",
      "example": "",
      "action": "continue",
      "next": "variable-check-python"
    },
    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Python?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-python"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-python"
        }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "graph = []\nin_degree = []\nqueue = []\nresult = []",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Do you know what a function is in Python?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-python"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-python"
        }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function is a reusable block of code.",
      "example": "def findOrder(numCourses, prerequisites):",
      "action": "continue",
      "next": "parameter-check-python"
    },
    {
      "stepId": "parameter-check-python",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "graph-check-python"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-python"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-python",
      "mentorSays": "Parameters are inputs to a function.",
      "example": "",
      "action": "continue",
      "next": "graph-check-python"
    },
    {
      "stepId": "graph-check-python",
      "mentorSays": "Do you know how to work with graph?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "queue-check-python"
        },
        {
          "label": "No, explain",
          "next": "graph-explanation-python"
        }
      ]
    },
    {
      "stepId": "graph-explanation-python",
      "mentorSays": "A graph has nodes (courses) and edges (prerequisites). We use an adjacency list to represent the graph.",
      "example": "graph = [[] for _ in range(numCourses)]\ngraph[0].append(1)  # Course 0 has prerequisite 1",
      "action": "continue",
      "next": "queue-check-python"
    },
    {
      "stepId": "queue-check-python",
      "mentorSays": "Do you know what queue is?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "coding-start-python"
        },
        {
          "label": "No, explain",
          "next": "queue-explanation-python"
        }
      ]
    },
    {
      "stepId": "queue-explanation-python",
      "mentorSays": "A queue is FIFO. We use it to process courses with no prerequisites first.",
      "example": "from collections import deque\nqueue = deque()\nqueue.append(0)  # Add course 0\ncourse = queue.popleft()  # Remove first",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Implement findOrder in PYTHON.",
      "example": "def findOrder(numCourses, prerequisites):",
      "action": "continue",
      "next": "coding-build-graph-python"
    },
    {
      "stepId": "coding-build-graph-python",
      "mentorSays": "Build adjacency list and in-degree array from prerequisites.",
      "example": "def findOrder(numCourses, prerequisites):\n    graph = [[] for _ in range(numCourses)]\n    in_degree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        in_degree[course] += 1",
      "action": "continue",
      "next": "coding-init-queue-python"
    },
    {
      "stepId": "coding-init-queue-python",
      "mentorSays": "Add all courses with in-degree 0 to the queue.",
      "example": "def findOrder(numCourses, prerequisites):\n    graph = [[] for _ in range(numCourses)]\n    in_degree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        in_degree[course] += 1\n    \n    queue = []\n    for i in range(numCourses):\n        if in_degree[i] == 0:\n            queue.append(i)",
      "action": "continue",
      "next": "coding-bfs-loop-python"
    },
    {
      "stepId": "coding-bfs-loop-python",
      "mentorSays": "Process queue: remove course, add to result, reduce in-degree of neighbors.",
      "example": "def findOrder(numCourses, prerequisites):\n    graph = [[] for _ in range(numCourses)]\n    in_degree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        in_degree[course] += 1\n    \n    queue = []\n    for i in range(numCourses):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    result = []\n    while queue:\n        course = queue.pop(0)\n        result.append(course)\n        \n        for neighbor in graph[course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)",
      "action": "continue",
      "next": "coding-check-cycle-python"
    },
    {
      "stepId": "coding-check-cycle-python",
      "mentorSays": "Check if all courses were processed. If not, there's a cycle - return empty array.",
      "example": "def findOrder(numCourses, prerequisites):\n    graph = [[] for _ in range(numCourses)]\n    in_degree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        in_degree[course] += 1\n    \n    queue = []\n    for i in range(numCourses):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    result = []\n    while queue:\n        course = queue.pop(0)\n        result.append(course)\n        \n        for neighbor in graph[course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result if len(result) == numCourses else []",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Test cases:\n1. numCourses=2, prerequisites=[[1,0]] → [0,1]\n2. numCourses=4, prerequisites=[[1,0],[2,0],[3,1],[3,2]] → [0,1,2,3] or [0,2,1,3]\n3. numCourses=3, prerequisites=[] → [0,1,2]\n4. numCourses=2, prerequisites=[[1,0],[0,1]] → []\n5. numCourses=1, prerequisites=[] → [0]\n6. Complex graph with multiple valid orders",
      "example": "",
      "action": "continue",
      "next": "variable-check-java"
    },
    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Java?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-java"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-java"
        }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "List<List<Integer>> graph = new ArrayList<>();\nint[] inDegree = new int[numCourses];\nQueue<Integer> queue = new LinkedList<>();\nList<Integer> result = new ArrayList<>();",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Do you know what a function is in Java?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-java"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-java"
        }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A function is a reusable block of code.",
      "example": "public int[] findOrder(int numCourses, int[][] prerequisites) {}",
      "action": "continue",
      "next": "parameter-check-java"
    },
    {
      "stepId": "parameter-check-java",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "graph-check-java"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-java"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-java",
      "mentorSays": "Parameters are inputs to a function.",
      "example": "",
      "action": "continue",
      "next": "graph-check-java"
    },
    {
      "stepId": "graph-check-java",
      "mentorSays": "Do you know how to work with graph?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "queue-check-java"
        },
        {
          "label": "No, explain",
          "next": "graph-explanation-java"
        }
      ]
    },
    {
      "stepId": "graph-explanation-java",
      "mentorSays": "A graph has nodes (courses) and edges (prerequisites). We use an adjacency list to represent the graph.",
      "example": "List<List<Integer>> graph = new ArrayList<>();\nfor (int i = 0; i < numCourses; i++) graph.add(new ArrayList<>());\ngraph.get(0).add(1);  // Course 0 has prerequisite 1",
      "action": "continue",
      "next": "queue-check-java"
    },
    {
      "stepId": "queue-check-java",
      "mentorSays": "Do you know what queue is?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "coding-start-java"
        },
        {
          "label": "No, explain",
          "next": "queue-explanation-java"
        }
      ]
    },
    {
      "stepId": "queue-explanation-java",
      "mentorSays": "A queue is FIFO. We use it to process courses with no prerequisites first.",
      "example": "Queue<Integer> queue = new LinkedList<>();\nqueue.offer(0);  // Add course 0\nint course = queue.poll();  // Remove first",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Implement findOrder in JAVA.",
      "example": "public int[] findOrder(int numCourses, int[][] prerequisites) {}",
      "action": "continue",
      "next": "coding-build-graph-java"
    },
    {
      "stepId": "coding-build-graph-java",
      "mentorSays": "Build adjacency list and in-degree array from prerequisites.",
      "example": "public int[] findOrder(int numCourses, int[][] prerequisites) {\n    List<List<Integer>> graph = new ArrayList<>();\n    int[] inDegree = new int[numCourses];\n    \n    for (int i = 0; i < numCourses; i++) graph.add(new ArrayList<>());\n    \n    for (int[] pre : prerequisites) {\n        int course = pre[0], prereq = pre[1];\n        graph.get(prereq).add(course);\n        inDegree[course]++;\n    }",
      "action": "continue",
      "next": "coding-init-queue-java"
    },
    {
      "stepId": "coding-init-queue-java",
      "mentorSays": "Add all courses with in-degree 0 to the queue.",
      "example": "public int[] findOrder(int numCourses, int[][] prerequisites) {\n    List<List<Integer>> graph = new ArrayList<>();\n    int[] inDegree = new int[numCourses];\n    \n    for (int i = 0; i < numCourses; i++) graph.add(new ArrayList<>());\n    \n    for (int[] pre : prerequisites) {\n        int course = pre[0], prereq = pre[1];\n        graph.get(prereq).add(course);\n        inDegree[course]++;\n    }\n    \n    Queue<Integer> queue = new LinkedList<>();\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) queue.offer(i);\n    }",
      "action": "continue",
      "next": "coding-bfs-loop-java"
    },
    {
      "stepId": "coding-bfs-loop-java",
      "mentorSays": "Process queue: remove course, add to result, reduce in-degree of neighbors.",
      "example": "public int[] findOrder(int numCourses, int[][] prerequisites) {\n    List<List<Integer>> graph = new ArrayList<>();\n    int[] inDegree = new int[numCourses];\n    \n    for (int i = 0; i < numCourses; i++) graph.add(new ArrayList<>());\n    \n    for (int[] pre : prerequisites) {\n        int course = pre[0], prereq = pre[1];\n        graph.get(prereq).add(course);\n        inDegree[course]++;\n    }\n    \n    Queue<Integer> queue = new LinkedList<>();\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) queue.offer(i);\n    }\n    \n    List<Integer> result = new ArrayList<>();\n    while (!queue.isEmpty()) {\n        int course = queue.poll();\n        result.add(course);\n        \n        for (int neighbor : graph.get(course)) {\n            inDegree[neighbor]--;\n            if (inDegree[neighbor] == 0) queue.offer(neighbor);\n        }\n    }",
      "action": "continue",
      "next": "coding-check-cycle-java"
    },
    {
      "stepId": "coding-check-cycle-java",
      "mentorSays": "Check if all courses were processed. If not, there's a cycle - return empty array.",
      "example": "public int[] findOrder(int numCourses, int[][] prerequisites) {\n    List<List<Integer>> graph = new ArrayList<>();\n    int[] inDegree = new int[numCourses];\n    \n    for (int i = 0; i < numCourses; i++) graph.add(new ArrayList<>());\n    \n    for (int[] pre : prerequisites) {\n        int course = pre[0], prereq = pre[1];\n        graph.get(prereq).add(course);\n        inDegree[course]++;\n    }\n    \n    Queue<Integer> queue = new LinkedList<>();\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) queue.offer(i);\n    }\n    \n    List<Integer> result = new ArrayList<>();\n    while (!queue.isEmpty()) {\n        int course = queue.poll();\n        result.add(course);\n        \n        for (int neighbor : graph.get(course)) {\n            inDegree[neighbor]--;\n            if (inDegree[neighbor] == 0) queue.offer(neighbor);\n        }\n    }\n    \n    if (result.size() == numCourses) {\n        int[] arr = new int[numCourses];\n        for (int i = 0; i < numCourses; i++) arr[i] = result.get(i);\n        return arr;\n    }\n    return new int[0];",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Test cases:\n1. numCourses=2, prerequisites=[[1,0]] → [0,1]\n2. numCourses=4, prerequisites=[[1,0],[2,0],[3,1],[3,2]] → [0,1,2,3] or [0,2,1,3]\n3. numCourses=3, prerequisites=[] → [0,1,2]\n4. numCourses=2, prerequisites=[[1,0],[0,1]] → []\n5. numCourses=1, prerequisites=[] → [0]\n6. Complex graph with multiple valid orders",
      "example": "",
      "action": "continue",
      "next": "variable-check-cpp"
    },
    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in C++?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-cpp"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "vector<vector<int>> graph;\nvector<int> inDegree;\nqueue<int> q;\nvector<int> result;",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Do you know what a function is in C++?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-cpp"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function is a reusable block of code.",
      "example": "vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {}",
      "action": "continue",
      "next": "parameter-check-cpp"
    },
    {
      "stepId": "parameter-check-cpp",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "graph-check-cpp"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-cpp",
      "mentorSays": "Parameters are inputs to a function.",
      "example": "",
      "action": "continue",
      "next": "graph-check-cpp"
    },
    {
      "stepId": "graph-check-cpp",
      "mentorSays": "Do you know how to work with graph?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "queue-check-cpp"
        },
        {
          "label": "No, explain",
          "next": "graph-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "graph-explanation-cpp",
      "mentorSays": "A graph has nodes (courses) and edges (prerequisites). We use an adjacency list to represent the graph.",
      "example": "vector<vector<int>> graph(numCourses);\ngraph[0].push_back(1);  // Course 0 has prerequisite 1",
      "action": "continue",
      "next": "queue-check-cpp"
    },
    {
      "stepId": "queue-check-cpp",
      "mentorSays": "Do you know what queue is?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "coding-start-cpp"
        },
        {
          "label": "No, explain",
          "next": "queue-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "queue-explanation-cpp",
      "mentorSays": "A queue is FIFO. We use it to process courses with no prerequisites first.",
      "example": "queue<int> q;\nq.push(0);  // Add course 0\nint course = q.front(); q.pop();  // Remove first",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Implement findOrder in CPP.",
      "example": "vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {}",
      "action": "continue",
      "next": "coding-build-graph-cpp"
    },
    {
      "stepId": "coding-build-graph-cpp",
      "mentorSays": "Build adjacency list and in-degree array from prerequisites.",
      "example": "vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n    vector<vector<int>> graph(numCourses);\n    vector<int> inDegree(numCourses, 0);\n    \n    for (auto& pre : prerequisites) {\n        int course = pre[0], prereq = pre[1];\n        graph[prereq].push_back(course);\n        inDegree[course]++;\n    }",
      "action": "continue",
      "next": "coding-init-queue-cpp"
    },
    {
      "stepId": "coding-init-queue-cpp",
      "mentorSays": "Add all courses with in-degree 0 to the queue.",
      "example": "vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n    vector<vector<int>> graph(numCourses);\n    vector<int> inDegree(numCourses, 0);\n    \n    for (auto& pre : prerequisites) {\n        int course = pre[0], prereq = pre[1];\n        graph[prereq].push_back(course);\n        inDegree[course]++;\n    }\n    \n    queue<int> q;\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) q.push(i);\n    }",
      "action": "continue",
      "next": "coding-bfs-loop-cpp"
    },
    {
      "stepId": "coding-bfs-loop-cpp",
      "mentorSays": "Process queue: remove course, add to result, reduce in-degree of neighbors.",
      "example": "vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n    vector<vector<int>> graph(numCourses);\n    vector<int> inDegree(numCourses, 0);\n    \n    for (auto& pre : prerequisites) {\n        int course = pre[0], prereq = pre[1];\n        graph[prereq].push_back(course);\n        inDegree[course]++;\n    }\n    \n    queue<int> q;\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) q.push(i);\n    }\n    \n    vector<int> result;\n    while (!q.empty()) {\n        int course = q.front();\n        q.pop();\n        result.push_back(course);\n        \n        for (int neighbor : graph[course]) {\n            inDegree[neighbor]--;\n            if (inDegree[neighbor] == 0) q.push(neighbor);\n        }\n    }",
      "action": "continue",
      "next": "coding-check-cycle-cpp"
    },
    {
      "stepId": "coding-check-cycle-cpp",
      "mentorSays": "Check if all courses were processed. If not, there's a cycle - return empty array.",
      "example": "vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n    vector<vector<int>> graph(numCourses);\n    vector<int> inDegree(numCourses, 0);\n    \n    for (auto& pre : prerequisites) {\n        int course = pre[0], prereq = pre[1];\n        graph[prereq].push_back(course);\n        inDegree[course]++;\n    }\n    \n    queue<int> q;\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) q.push(i);\n    }\n    \n    vector<int> result;\n    while (!q.empty()) {\n        int course = q.front();\n        q.pop();\n        result.push_back(course);\n        \n        for (int neighbor : graph[course]) {\n            inDegree[neighbor]--;\n            if (inDegree[neighbor] == 0) q.push(neighbor);\n        }\n    }\n    \n    return result.size() == numCourses ? result : vector<int>();",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Test cases:\n1. numCourses=2, prerequisites=[[1,0]] → [0,1]\n2. numCourses=4, prerequisites=[[1,0],[2,0],[3,1],[3,2]] → [0,1,2,3] or [0,2,1,3]\n3. numCourses=3, prerequisites=[] → [0,1,2]\n4. numCourses=2, prerequisites=[[1,0],[0,1]] → []\n5. numCourses=1, prerequisites=[] → [0]\n6. Complex graph with multiple valid orders",
      "example": "",
      "action": "continue",
      "next": "variable-check-ts"
    },
    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-ts"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-ts"
        }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "let graph: number[][] = [];\nlet inDegree: number[] = [];\nlet queue: number[] = [];\nlet result: number[] = [];",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Do you know what a function is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-ts"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-ts"
        }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function is a reusable block of code.",
      "example": "function findOrder(numCourses: number, prerequisites: number[][]): number[] {}",
      "action": "continue",
      "next": "parameter-check-ts"
    },
    {
      "stepId": "parameter-check-ts",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "graph-check-ts"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-ts"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-ts",
      "mentorSays": "Parameters are inputs to a function.",
      "example": "",
      "action": "continue",
      "next": "graph-check-ts"
    },
    {
      "stepId": "graph-check-ts",
      "mentorSays": "Do you know how to work with graph?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "queue-check-ts"
        },
        {
          "label": "No, explain",
          "next": "graph-explanation-ts"
        }
      ]
    },
    {
      "stepId": "graph-explanation-ts",
      "mentorSays": "A graph has nodes (courses) and edges (prerequisites). We use an adjacency list to represent the graph.",
      "example": "let graph: number[][] = Array(numCourses).fill(null).map(() => []);\ngraph[0].push(1);  // Course 0 has prerequisite 1",
      "action": "continue",
      "next": "queue-check-ts"
    },
    {
      "stepId": "queue-check-ts",
      "mentorSays": "Do you know what queue is?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "coding-start-ts"
        },
        {
          "label": "No, explain",
          "next": "queue-explanation-ts"
        }
      ]
    },
    {
      "stepId": "queue-explanation-ts",
      "mentorSays": "A queue is FIFO. We use it to process courses with no prerequisites first.",
      "example": "let queue: number[] = [];\nqueue.push(0);  // Add course 0\nlet course = queue.shift();  // Remove first",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Implement findOrder in TS.",
      "example": "function findOrder(numCourses: number, prerequisites: number[][]): number[] {}",
      "action": "continue",
      "next": "coding-build-graph-ts"
    },
    {
      "stepId": "coding-build-graph-ts",
      "mentorSays": "Build adjacency list and in-degree array from prerequisites.",
      "example": "function findOrder(numCourses: number, prerequisites: number[][]): number[] {\n    let graph: number[][] = Array(numCourses).fill(null).map(() => []);\n    let inDegree: number[] = Array(numCourses).fill(0);\n    \n    for (let [course, prereq] of prerequisites) {\n        graph[prereq].push(course);\n        inDegree[course]++;\n    }",
      "action": "continue",
      "next": "coding-init-queue-ts"
    },
    {
      "stepId": "coding-init-queue-ts",
      "mentorSays": "Add all courses with in-degree 0 to the queue.",
      "example": "function findOrder(numCourses: number, prerequisites: number[][]): number[] {\n    let graph: number[][] = Array(numCourses).fill(null).map(() => []);\n    let inDegree: number[] = Array(numCourses).fill(0);\n    \n    for (let [course, prereq] of prerequisites) {\n        graph[prereq].push(course);\n        inDegree[course]++;\n    }\n    \n    let queue: number[] = [];\n    for (let i = 0; i < numCourses; i++) {\n        if (inDegree[i] === 0) queue.push(i);\n    }",
      "action": "continue",
      "next": "coding-bfs-loop-ts"
    },
    {
      "stepId": "coding-bfs-loop-ts",
      "mentorSays": "Process queue: remove course, add to result, reduce in-degree of neighbors.",
      "example": "function findOrder(numCourses: number, prerequisites: number[][]): number[] {\n    let graph: number[][] = Array(numCourses).fill(null).map(() => []);\n    let inDegree: number[] = Array(numCourses).fill(0);\n    \n    for (let [course, prereq] of prerequisites) {\n        graph[prereq].push(course);\n        inDegree[course]++;\n    }\n    \n    let queue: number[] = [];\n    for (let i = 0; i < numCourses; i++) {\n        if (inDegree[i] === 0) queue.push(i);\n    }\n    \n    let result: number[] = [];\n    while (queue.length > 0) {\n        let course = queue.shift()!;\n        result.push(course);\n        \n        for (let neighbor of graph[course]) {\n            inDegree[neighbor]--;\n            if (inDegree[neighbor] === 0) queue.push(neighbor);\n        }\n    }",
      "action": "continue",
      "next": "coding-check-cycle-ts"
    },
    {
      "stepId": "coding-check-cycle-ts",
      "mentorSays": "Check if all courses were processed. If not, there's a cycle - return empty array.",
      "example": "function findOrder(numCourses: number, prerequisites: number[][]): number[] {\n    let graph: number[][] = Array(numCourses).fill(null).map(() => []);\n    let inDegree: number[] = Array(numCourses).fill(0);\n    \n    for (let [course, prereq] of prerequisites) {\n        graph[prereq].push(course);\n        inDegree[course]++;\n    }\n    \n    let queue: number[] = [];\n    for (let i = 0; i < numCourses; i++) {\n        if (inDegree[i] === 0) queue.push(i);\n    }\n    \n    let result: number[] = [];\n    while (queue.length > 0) {\n        let course = queue.shift()!;\n        result.push(course);\n        \n        for (let neighbor of graph[course]) {\n            inDegree[neighbor]--;\n            if (inDegree[neighbor] === 0) queue.push(neighbor);\n        }\n    }\n    \n    return result.length === numCourses ? result : [];",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Test cases:\n1. numCourses=2, prerequisites=[[1,0]] → [0,1]\n2. numCourses=4, prerequisites=[[1,0],[2,0],[3,1],[3,2]] → [0,1,2,3] or [0,2,1,3]\n3. numCourses=3, prerequisites=[] → [0,1,2]\n4. numCourses=2, prerequisites=[[1,0],[0,1]] → []\n5. numCourses=1, prerequisites=[] → [0]\n6. Complex graph with multiple valid orders",
      "example": "",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "final",
      "mentorSays": "Time: O(V + E), Space: O(V + E). Kahn's algorithm efficiently finds topological order.\n\nRelated Problems:\n- Course Schedule\n- Alien Dictionary\n- Sequence Reconstruction",
      "action": "continue"
    }
  ]
}