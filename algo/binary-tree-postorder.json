{
  "id": "binary-tree-postorder",
  "title": "Binary Tree Postorder Traversal",
  "pattern": "tree",
  "difficulty": "easy",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what Binary Tree Postorder Traversal traversal means\n2. Use recursion to traverse a binary tree in Postorder order\n3. Understand the left subtree, then right subtree, then root pattern\n4. Handle base cases (null nodes)\n5. Implement the solution step by step in your chosen language",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Perfect! Now let's understand what Binary Tree Postorder Traversal traversal means.\n\n**Problem Definition:**\nGiven the root of a binary tree, return the Postorder traversal of its nodes' values.\n\n**Key Observations:**\n- Tree traversal visits each node exactly once\n- Postorder order means: left subtree, then right subtree, then root\n- We can use recursion or iteration (stack)\n- The order matters for different use cases\n\n**Example 1:**\nTree:\n    1\n     \\\n      2\n     /\n    3\n\nPostorder traversal: [1, 2, 3]\n\n**Example 2:**\nTree:\n    1\n   / \\\n  2   3\n / \\\n4   5\n\nPostorder traversal: [4,5,2,3,1]\n\n**Step-by-step trace for Example 2 (Recursive approach):**\n\nTree:\n    1\n   / \\\n  2   3\n / \\\n4   5\n\nWe'll use recursion:\n- Visit left subtree (2,4,5)\n- Visit right subtree (3)\n- Visit root (1)\n- Result: [4,5,2,3,1]\n\n**Key Insight:**\nPostorder traversal follows a specific order: left subtree, then right subtree, then root. We recursively visit left subtree, current node, and right subtree in the correct sequence.\n\n**What makes this tricky:**\n1. Understanding the traversal order\n2. Recursive thinking: visit subtrees before/after current node\n3. Handling base cases (null nodes)\n4. Building the result list correctly\n\n**Common pitfalls:**\n- Visiting nodes in wrong order\n- Not handling null nodes\n- Forgetting to return the result\n- Not initializing the result list",
      "example": "Example 1:\n    1\n     \\\n      2\n     /\n    3\n\nPostorder: [1, 2, 3]\n\nExample 2:\n    1\n   / \\\n  2   3\n\nPostorder: [1, 2, 3]",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Now that you understand what Postorder traversal means, here's the real question:\n\nHow would YOU traverse a binary tree in Postorder order?\n\nThink about it for a moment. What approach feels natural to you?",
      "choices": [
        {
          "label": "Use recursion - follow Postorder order pattern",
          "next": "explore-recursive"
        },
        {
          "label": "Use iteration with a stack",
          "next": "explore-iterative"
        },
        {
          "label": "Use BFS/level-order traversal",
          "next": "explore-bfs"
        }
      ]
    },
    {
      "stepId": "explore-iterative",
      "mentorSays": "That's a good approach! You're thinking: \"I'll use a stack to simulate recursion iteratively.\"\n\nThis works! However, it's more complex than recursion for tree traversal.\n\nThere's a simpler recursive approach that's very elegant. Would you like to learn that?",
      "action": "continue",
      "next": "explore-recursive"
    },
    {
      "stepId": "explore-bfs",
      "mentorSays": "That's a different traversal! BFS (level-order) visits nodes level by level, which is different from {order_name} order.\n\n{order_name} order is a depth-first traversal. Would you like to learn the recursive approach?",
      "action": "continue",
      "next": "explore-recursive"
    },
    {
      "stepId": "explore-recursive",
      "mentorSays": "Excellent choice! Recursion is perfect for tree traversal. Here's the core idea:\n\n**The Algorithm:**\n1. **Base case**: If root is null, return (or return empty list)\n2. **Recursive case**: \n   - Recursively visit left subtree\n- Recursively visit right subtree\n- Visit current node (add to result)\n3. **Return result**: Combine results from subtrees and current node\n\n**Why it works**:\n- We recursively visit left and right subtrees\n- We visit the current node at the right time (Postorder order)\n- The base case handles null nodes\n\n**Key insight**: Tree traversal is naturally recursive! Each subtree is also a tree, so we can solve it recursively.\n\nLet's trace with tree:\n    1\n   / \\\n  2   3\n\n- **traverse(1)**:\n  - Left: traverse(2) = [2]\n- Right: traverse(3) = [3]\n- Visit root: 1\n- Result: [2, 3, 1]\n\nThis is O(n) time (visit each node once) and O(h) space (recursion stack)! Now let's code it step by step.",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Great! Now let's code this solution. Which programming language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "variable-check-js"
        },
        {
          "label": "Python",
          "next": "variable-check-python"
        },
        {
          "label": "Java",
          "next": "variable-check-java"
        },
        {
          "label": "C++",
          "next": "variable-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "variable-check-ts"
        }
      ]
    },
    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-js"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-js"
        }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'result') and put data inside it.",
      "example": "let result = [];  // Store traversal result",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-js"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-js"
        }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function binarytreepostorder(root) {\n  // Returns Postorder traversal\n  return [];\n}",
      "action": "continue",
      "next": "parameter-check-js"
    },
    {
      "stepId": "parameter-check-js",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-js"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-js"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-js",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function binarytreepostorder(root)', the 'root' is a parameter.",
      "example": "function binarytreepostorder(root) {\n  // Parameter receives root node\n}\n\n// Call: binarytreepostorder(rootNode)",
      "action": "continue",
      "next": "tree-check-js"
    },
    {
      "stepId": "tree-check-js",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-js"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-js"
        }
      ]
    },
    {
      "stepId": "tree-explanation-js",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-js"
    },
    {
      "stepId": "recursion-check-js",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-js"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-js"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-js",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we use recursion because a tree is naturally recursive - each subtree is also a tree.",
      "example": "function traverse(root) {\n  if (root === null) return [];\n  \n  // Recursive calls\n  let left = traverse(root.left);   // Recursive!\n  let right = traverse(root.right); // Recursive!\n  \n  // Combine results\n  return [...left, root.val, ...right];\n}",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Perfect! Let's implement Postorder traversal in JavaScript.",
      "example": "function binarytreepostorder(root) {\n  \n}",
      "action": "continue",
      "next": "coding-init-js"
    },
    {
      "stepId": "coding-init-js",
      "mentorSays": "Initialize a result array.",
      "example": "function binarytreepostorder(root) {\n  const result = [];\n  \n}",
      "action": "continue",
      "next": "coding-helper-js"
    },
    {
      "stepId": "coding-helper-js",
      "mentorSays": "Create a helper function.",
      "example": "function binarytreepostorder(root) {\n  const result = [];\n  \n  function traverse(node) {\n    // Traversal logic\n  }\n  \n}",
      "action": "continue",
      "next": "coding-base-case-js"
    },
    {
      "stepId": "coding-base-case-js",
      "mentorSays": "Handle base case (null node).",
      "example": "function binarytreepostorder(root) {\n  const result = [];\n  \n  function traverse(node) {\n    if (node === null) return;\n    \n  }\n  \n}",
      "action": "continue",
      "next": "coding-visit-left-js"
    },
    {
      "stepId": "coding-visit-left-js",
      "mentorSays": "Recursively visit left subtree first.",
      "example": "function binarytreepostorder(root) {\n  const result = [];\n  \n  function traverse(node) {\n    if (node === null) return;\n    \n    traverse(node.left);  // Visit left first\n    \n  }\n  \n}",
      "action": "continue",
      "next": "coding-visit-right-js"
    },
    {
      "stepId": "coding-visit-right-js",
      "mentorSays": "Recursively visit right subtree.",
      "example": "function binarytreepostorder(root) {\n  const result = [];\n  \n  function traverse(node) {\n    if (node === null) return;\n    \n    traverse(node.left);\n    traverse(node.right);  // Visit right\n    \n  }\n  \n}",
      "action": "continue",
      "next": "coding-visit-root-js"
    },
    {
      "stepId": "coding-visit-root-js",
      "mentorSays": "Visit current node last (postorder: root after children), then call helper and return.",
      "example": "function binarytreepostorder(root) {\n  const result = [];\n  \n  function traverse(node) {\n    if (node === null) return;\n    \n    traverse(node.left);\n    traverse(node.right);\n    result.push(node.val);  // Visit root last\n  }\n  \n  traverse(root);\n  return result;\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [1,null,2,3]\nExpected: [1, 2, 3]\n\n**Test 2:** root = [1,2,3,4,5]\nExpected: [4,5,2,3,1]\n\n**Test 3:** root = []\nExpected: []\n\n**Test 4:** root = [1]\nExpected: [1]\n\n**Test 5:** root = [1,2]\nExpected: [1, 2]\n\n**Test 6:** root = [1,null,2]\nExpected: [1, 2]\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,null,2,3] â†’ [1, 2, 3]\nTest 2: [1,2,3,4,5] â†’ [4,5,2,3,1]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Python?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-python"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-python"
        }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'result') and put data inside it.",
      "example": " result = [];  // Store traversal result",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Python?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-python"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-python"
        }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "def binarytreepostorder(root) {\n  // Returns Postorder traversal\n  return [];\n}",
      "action": "continue",
      "next": "parameter-check-python"
    },
    {
      "stepId": "parameter-check-python",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-python"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-python"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-python",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'def binarytreepostorder(root)', the 'root' is a parameter.",
      "example": "def binarytreepostorder(root) {\n  // Parameter receives root node\n}\n\n// Call: binarytreepostorder(rootNode)",
      "action": "continue",
      "next": "tree-check-python"
    },
    {
      "stepId": "tree-check-python",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-python"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-python"
        }
      ]
    },
    {
      "stepId": "tree-explanation-python",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-python"
    },
    {
      "stepId": "recursion-check-python",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in Python?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-python"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-python"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-python",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we use recursion because a tree is naturally recursive - each subtree is also a tree.",
      "example": "function traverse(root) {\n  if (root === null) return [];\n  \n  // Recursive calls\n  let left = traverse(root.left);   // Recursive!\n  let right = traverse(root.right); // Recursive!\n  \n  // Combine results\n  return [...left, root.val, ...right];\n}",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Perfect! Let's implement the solution in Python.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-init-python"
    },
    {
      "stepId": "coding-init-python",
      "mentorSays": "Initialize result array.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-helper-python"
    },
    {
      "stepId": "coding-helper-python",
      "mentorSays": "Create helper function.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-base-case-python"
    },
    {
      "stepId": "coding-base-case-python",
      "mentorSays": "Handle base case (null node).",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-visit-python"
    },
    {
      "stepId": "coding-visit-python",
      "mentorSays": "Visit nodes in Postorder order.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-return-python"
    },
    {
      "stepId": "coding-return-python",
      "mentorSays": "Return result.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [1,null,2,3]\nExpected: [1, 2, 3]\n\n**Test 2:** root = [1,2,3,4,5]\nExpected: [4,5,2,3,1]\n\n**Test 3:** root = []\nExpected: []\n\n**Test 4:** root = [1]\nExpected: [1]\n\n**Test 5:** root = [1,2]\nExpected: [1, 2]\n\n**Test 6:** root = [1,null,2]\nExpected: [1, 2]\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,null,2,3] â†’ [1, 2, 3]\nTest 2: [1,2,3,4,5] â†’ [4,5,2,3,1]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Java?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-java"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-java"
        }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'result') and put data inside it.",
      "example": "List<Integer> result = [];  // Store traversal result",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Java?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-java"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-java"
        }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "public List<Integer> binarytreepostorder(root) {\n  // Returns Postorder traversal\n  return [];\n}",
      "action": "continue",
      "next": "parameter-check-java"
    },
    {
      "stepId": "parameter-check-java",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-java"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-java"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-java",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'public List<Integer> binarytreepostorder(root)', the 'root' is a parameter.",
      "example": "public List<Integer> binarytreepostorder(root) {\n  // Parameter receives root node\n}\n\n// Call: binarytreepostorder(rootNode)",
      "action": "continue",
      "next": "tree-check-java"
    },
    {
      "stepId": "tree-check-java",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-java"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-java"
        }
      ]
    },
    {
      "stepId": "tree-explanation-java",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-java"
    },
    {
      "stepId": "recursion-check-java",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in Java?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-java"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-java"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-java",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we use recursion because a tree is naturally recursive - each subtree is also a tree.",
      "example": "function traverse(root) {\n  if (root === null) return [];\n  \n  // Recursive calls\n  let left = traverse(root.left);   // Recursive!\n  let right = traverse(root.right); // Recursive!\n  \n  // Combine results\n  return [...left, root.val, ...right];\n}",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Perfect! Let's implement the solution in Java.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-init-java"
    },
    {
      "stepId": "coding-init-java",
      "mentorSays": "Initialize result array.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-helper-java"
    },
    {
      "stepId": "coding-helper-java",
      "mentorSays": "Create helper function.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-base-case-java"
    },
    {
      "stepId": "coding-base-case-java",
      "mentorSays": "Handle base case (null node).",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-visit-java"
    },
    {
      "stepId": "coding-visit-java",
      "mentorSays": "Visit nodes in Postorder order.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-return-java"
    },
    {
      "stepId": "coding-return-java",
      "mentorSays": "Return result.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [1,null,2,3]\nExpected: [1, 2, 3]\n\n**Test 2:** root = [1,2,3,4,5]\nExpected: [4,5,2,3,1]\n\n**Test 3:** root = []\nExpected: []\n\n**Test 4:** root = [1]\nExpected: [1]\n\n**Test 5:** root = [1,2]\nExpected: [1, 2]\n\n**Test 6:** root = [1,null,2]\nExpected: [1, 2]\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,null,2,3] â†’ [1, 2, 3]\nTest 2: [1,2,3,4,5] â†’ [4,5,2,3,1]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in C++?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-cpp"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'result') and put data inside it.",
      "example": "vector<int> result = [];  // Store traversal result",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in C++?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-cpp"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "vector<int> binarytreepostorder(root) {\n  // Returns Postorder traversal\n  return [];\n}",
      "action": "continue",
      "next": "parameter-check-cpp"
    },
    {
      "stepId": "parameter-check-cpp",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-cpp"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-cpp",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'vector<int> binarytreepostorder(root)', the 'root' is a parameter.",
      "example": "vector<int> binarytreepostorder(root) {\n  // Parameter receives root node\n}\n\n// Call: binarytreepostorder(rootNode)",
      "action": "continue",
      "next": "tree-check-cpp"
    },
    {
      "stepId": "tree-check-cpp",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-cpp"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "tree-explanation-cpp",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-cpp"
    },
    {
      "stepId": "recursion-check-cpp",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in C++?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-cpp"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-cpp",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we use recursion because a tree is naturally recursive - each subtree is also a tree.",
      "example": "function traverse(root) {\n  if (root === null) return [];\n  \n  // Recursive calls\n  let left = traverse(root.left);   // Recursive!\n  let right = traverse(root.right); // Recursive!\n  \n  // Combine results\n  return [...left, root.val, ...right];\n}",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Perfect! Let's implement the solution in C++.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-init-cpp"
    },
    {
      "stepId": "coding-init-cpp",
      "mentorSays": "Initialize result array.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-helper-cpp"
    },
    {
      "stepId": "coding-helper-cpp",
      "mentorSays": "Create helper function.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-base-case-cpp"
    },
    {
      "stepId": "coding-base-case-cpp",
      "mentorSays": "Handle base case (null node).",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-visit-cpp"
    },
    {
      "stepId": "coding-visit-cpp",
      "mentorSays": "Visit nodes in Postorder order.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-return-cpp"
    },
    {
      "stepId": "coding-return-cpp",
      "mentorSays": "Return result.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [1,null,2,3]\nExpected: [1, 2, 3]\n\n**Test 2:** root = [1,2,3,4,5]\nExpected: [4,5,2,3,1]\n\n**Test 3:** root = []\nExpected: []\n\n**Test 4:** root = [1]\nExpected: [1]\n\n**Test 5:** root = [1,2]\nExpected: [1, 2]\n\n**Test 6:** root = [1,null,2]\nExpected: [1, 2]\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,null,2,3] â†’ [1, 2, 3]\nTest 2: [1,2,3,4,5] â†’ [4,5,2,3,1]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-ts"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-ts"
        }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'result') and put data inside it.",
      "example": "let result = [];  // Store traversal result",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-ts"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-ts"
        }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function binarytreepostorder(root) {\n  // Returns Postorder traversal\n  return [];\n}",
      "action": "continue",
      "next": "parameter-check-ts"
    },
    {
      "stepId": "parameter-check-ts",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-ts"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-ts"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-ts",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function binarytreepostorder(root)', the 'root' is a parameter.",
      "example": "function binarytreepostorder(root) {\n  // Parameter receives root node\n}\n\n// Call: binarytreepostorder(rootNode)",
      "action": "continue",
      "next": "tree-check-ts"
    },
    {
      "stepId": "tree-check-ts",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-ts"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-ts"
        }
      ]
    },
    {
      "stepId": "tree-explanation-ts",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-ts"
    },
    {
      "stepId": "recursion-check-ts",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-ts"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-ts"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-ts",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we use recursion because a tree is naturally recursive - each subtree is also a tree.",
      "example": "function traverse(root) {\n  if (root === null) return [];\n  \n  // Recursive calls\n  let left = traverse(root.left);   // Recursive!\n  let right = traverse(root.right); // Recursive!\n  \n  // Combine results\n  return [...left, root.val, ...right];\n}",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Perfect! Let's implement the solution in TypeScript.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-init-ts"
    },
    {
      "stepId": "coding-init-ts",
      "mentorSays": "Initialize result array.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-helper-ts"
    },
    {
      "stepId": "coding-helper-ts",
      "mentorSays": "Create helper function.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-base-case-ts"
    },
    {
      "stepId": "coding-base-case-ts",
      "mentorSays": "Handle base case (null node).",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-visit-ts"
    },
    {
      "stepId": "coding-visit-ts",
      "mentorSays": "Visit nodes in Postorder order.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-return-ts"
    },
    {
      "stepId": "coding-return-ts",
      "mentorSays": "Return result.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [1,null,2,3]\nExpected: [1, 2, 3]\n\n**Test 2:** root = [1,2,3,4,5]\nExpected: [4,5,2,3,1]\n\n**Test 3:** root = []\nExpected: []\n\n**Test 4:** root = [1]\nExpected: [1]\n\n**Test 5:** root = [1,2]\nExpected: [1, 2]\n\n**Test 6:** root = [1,null,2]\nExpected: [1, 2]\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,null,2,3] â†’ [1, 2, 3]\nTest 2: [1,2,3,4,5] â†’ [4,5,2,3,1]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "final",
      "mentorSays": "ðŸŽ‰ Well done! You've successfully implemented Binary Tree Postorder Traversal traversal!\n\n**Time Complexity:** O(n)\n- We visit each node exactly once\n- Each node does constant work\n\n**Space Complexity:** O(h)\n- The recursion stack uses O(h) space where h is the height\n- For balanced tree: O(log n)\n- For skewed tree: O(n)\n- Result array uses O(n) space\n\n**Key Takeaways:**\n1. **Postorder order**: left subtree, then right subtree, then root\n2. **Recursion**: Natural fit for tree traversal\n3. **Base case**: Handle null nodes\n4. **Order matters**: Different orders for different use cases\n5. **Efficiency**: O(n) time is optimal (must visit all nodes)\n\n**Related Practice Problems:**\n- Binary Tree Preorder Traversal (LeetCode #144) - different order\n- Binary Tree Postorder Traversal (LeetCode #145) - different order\n- Binary Tree Level Order Traversal (LeetCode #102) - BFS traversal\n\nKeep practicing tree traversals - they're fundamental!",
      "action": "continue"
    }
  ]
}