{
  "id": "climbing-stairs-dp",
  "title": "Climbing stairs (DP)",
  "pattern": "dynamic-programming",
  "difficulty": "easy",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what the Climbing Stairs problem asks for\n2. Use dynamic programming to count ways to climb stairs\n3. Build the solution by storing previously computed values\n4. Implement the solution step by step in your chosen language",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Let's understand the climbing stairs problem deeply.\n\nTHE PROBLEM:\nYou have a staircase with n steps.\nEach time you can climb either 1 step or 2 steps.\nHow many distinct ways can you reach the top?\n\nEXAMPLE: n = 5 (Detailed Walkthrough)\n\nLet's list all possible ways:\n1. 1+1+1+1+1 (five single steps)\n2. 1+1+1+2 (three singles, one double)\n3. 1+1+2+1\n4. 1+2+1+1\n5. 2+1+1+1\n6. 1+2+2\n7. 2+1+2\n8. 2+2+1\n\nTotal: 8 ways\n\nRECURSIVE THINKING:\nTo reach step 5, I could:\n- Be at step 4, then take 1 step â†’ ways(4)\n- Be at step 3, then take 2 steps â†’ ways(3)\n\nSo: ways(5) = ways(4) + ways(3)\n\nBUILDING THE SOLUTION:\nways(0) = 1  (base case: 0 steps = do nothing)\nways(1) = 1  (base case: only one way)\nways(2) = ways(1) + ways(0) = 1 + 1 = 2\nways(3) = ways(2) + ways(1) = 2 + 1 = 3\nways(4) = ways(3) + ways(2) = 3 + 2 = 5\nways(5) = ways(4) + ways(3) = 5 + 3 = 8 âœ“\n\nRECURSION TREE (shows overlapping subproblems):\n                ways(5)\n               /       \\\n          ways(4)     ways(3)\n          /    \\       /    \\\n    ways(3) ways(2) ways(2) ways(1)\n     /  \\     /  \\    /  \\\n   w(2) w(1) w(1) w(0) w(1) w(0)\n\nNotice: ways(2) appears 3 times, ways(3) appears 2 times!\n\nThis is why we need dynamic programming - to avoid recalculating!\n\nDP TABLE CONSTRUCTION:\ni:     0  1  2  3  4  5\ndp[i]: 1  1  2  3  5  8\n\nPattern: This is the Fibonacci sequence!\n\nTIME COMPLEXITY: O(n) - single pass\nSPACE COMPLEXITY: O(n) or O(1) with optimization\n\nWHY DP IS BETTER:\n- Naive recursion: O(2^n) - exponential!\n- DP: O(n) - linear!\n- For n=30: Recursion makes millions of calls, DP makes 30 calculations!",
      "example": "n = 5\n\nFind number of ways to climb:\nF(5) = 8 ways âœ“\n\nAnother example:\nn = 3\n\nAnswer: 3 ways\n(1+1+1, 1+2, 2+1)\n\nAnother example:\nn = 2\n\nAnswer: 2 ways\n(1+1, 2)",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Now that you understand what the problem wants, here's the real question:\n\nHow would YOU count the number of ways?\n\nThink about it for a moment. What approach feels natural to you?",
      "choices": [
        {
          "label": "Use dynamic programming to store and reuse computed values",
          "next": "explore-dp"
        },
        {
          "label": "Use recursion to compute ways(n) = ways(n-1) + ways(n-2)",
          "next": "explore-recursion"
        },
        {
          "label": "Try all possible combinations of 1 and 2 steps",
          "next": "explore-brute-force"
        }
      ]
    },
    {
      "stepId": "explore-recursion",
      "mentorSays": "That's a straightforward approach! You're thinking: \"I'll use recursion: ways(n) = ways(n-1) + ways(n-2) with base cases ways(0) = 1 and ways(1) = 1.\"\n\nThis works! However, it's exponential time complexity because we recalculate the same values many times.\n\nFor example, to compute ways(5):\n- ways(5) calls ways(4) and ways(3)\n- ways(4) calls ways(3) and ways(2)\n- ways(3) calls ways(2) and ways(1)\n- ways(2) is computed multiple times!\n\nWould you like to learn the dynamic programming approach which is O(n) time?",
      "action": "continue",
      "next": "explore-dp"
    },
    {
      "stepId": "explore-brute-force",
      "mentorSays": "That's a straightforward approach! You're thinking: \"I'll try all possible combinations of 1-step and 2-step moves.\"\n\nThis works! However, it's exponential time complexity.\n\nWould you like to learn the dynamic programming approach which is O(n) time?",
      "action": "continue",
      "next": "explore-dp"
    },
    {
      "stepId": "explore-dp",
      "mentorSays": "Excellent choice! Dynamic programming is efficient and intuitive. Here's the core idea:\n\n1. **DP Array**: dp[i] = number of ways to reach step i\n2. **Base Cases**:\n   - dp[0] = 1 (one way to be at start)\n   - dp[1] = 1 (one way to reach step 1: climb 1 step)\n3. **Recurrence**: For i >= 2:\n   - dp[i] = dp[i-1] + dp[i-2]\n   - (ways from step i-1 by climbing 1 step + ways from step i-2 by climbing 2 steps)\n4. **Result**: dp[n]\n\nLet's trace with n = 5:\n\n- **dp[0] = 1** (base case)\n- **dp[1] = 1** (base case)\n- **dp[2] = 1 + 1 = 2**\n- **dp[3] = 2 + 1 = 3**\n- **dp[4] = 3 + 2 = 5**\n- **dp[5] = 5 + 3 = 8** âœ“\n\nAnswer: 8\n\nThis is O(n) time and O(n) space! We can optimize to O(1) space by only keeping the last two values. Now let's code it step by step.",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Great! Now let's code this solution. Which programming language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "variable-check-js"
        },
        {
          "label": "Python",
          "next": "variable-check-python"
        },
        {
          "label": "Java",
          "next": "variable-check-java"
        },
        {
          "label": "C++",
          "next": "variable-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "variable-check-ts"
        }
      ]
    },
    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-js"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-js"
        }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'dp' or 'ways') and put data inside it.\n\nFor example, 'let dp = [];' creates a variable that stores an empty array.",
      "example": "let dp = [];\n\nNow the variable refers to an empty array",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "array-check-js"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-js"
        }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function add(a, b) {\n  return a + b;\n}\n\nadd(3, 5) returns 8",
      "action": "continue",
      "next": "array-check-js"
    },
    {
      "stepId": "array-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what an array is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know arrays",
          "next": "base-cases-check-js"
        },
        {
          "label": "No, explain arrays",
          "next": "array-explanation-js"
        }
      ]
    },
    {
      "stepId": "base-cases-check-js",
      "mentorSays": "Do you understand what base cases are in dynamic programming?",
      "choices": [
        {
          "label": "Yes, I know base-cases",
          "next": "overlapping-subproblems-check-js"
        },
        {
          "label": "No, explain base-cases",
          "next": "base-cases-explanation-js"
        }
      ]
    },
    {
      "stepId": "overlapping-subproblems-check-js",
      "mentorSays": "Do you understand why we need dynamic programming for this problem?",
      "choices": [
        {
          "label": "Yes, I know overlapping-subproblems",
          "next": "coding-start-js"
        },
        {
          "label": "No, explain overlapping-subproblems",
          "next": "overlapping-subproblems-explanation-js"
        }
      ]
    },
    {
      "stepId": "overlapping-subproblems-explanation-js",
      "mentorSays": "Without DP, we recalculate the same subproblems many times. Example: ways(5) = ways(4) + ways(3) = [ways(3) + ways(2)] + [ways(2) + ways(1)]. Notice ways(2) is calculated 3 times! ways(3) is calculated 2 times! DP solves each subproblem once and reuses the result.\n\n// Without DP, we recalculate:\n// ways(5) = ways(4) + ways(3)\n//         = [ways(3) + ways(2)] + [ways(2) + ways(1)]\n// Notice: ways(2) calculated 3 times!\n//         ways(3) calculated 2 times!\n\n// With DP, we solve once and reuse:\nlet dp = [1, 1, 2, 3, 5, 8];\n// Each value calculated only once!\n\nGot it?",
      "example": "// Without DP, we recalculate:\n// ways(5) = ways(4) + ways(3)\n//         = [ways(3) + ways(2)] + [ways(2) + ways(1)]\n// Notice: ways(2) calculated 3 times!\n//         ways(3) calculated 2 times!\n\n// With DP, we solve once and reuse:\nlet dp = [1, 1, 2, 3, 5, 8];\n// Each value calculated only once!",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "base-cases-explanation-js",
      "mentorSays": "Base cases are the simplest inputs where the answer is obvious. For climbing stairs: 0 steps = 1 way (do nothing), 1 step = 1 way (one single step), 2 steps = 2 ways (two singles OR one double). These form the foundation for solving larger problems!\n\n// Base cases for climbing stairs:\n// dp[0] = 1  (one way to be at start)\n// dp[1] = 1  (one way: climb 1 step)\n\nlet dp = [1, 1];\n// These are the simplest cases where answer is obvious!\n\nGot it?",
      "example": "// Base cases for climbing stairs:\n// dp[0] = 1  (one way to be at start)\n// dp[1] = 1  (one way: climb 1 step)\n\nlet dp = [1, 1];\n// These are the simplest cases where answer is obvious!",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "array-explanation-js",
      "mentorSays": "An array is like a list of items that keeps them in order. Each item has a position number called an 'index'. Array indices start counting from 0.",
      "example": "arr = [1, 2, 3]\n\narr[0] = 1\narr[1] = 2\narr[2] = 3",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Perfect! Let's implement climbing stairs using dynamic programming in JavaScript.",
      "example": "function climbStairs(n) {\n  // Your code here\n}",
      "action": "continue",
      "next": "coding-base-js"
    },
    {
      "stepId": "coding-base-js",
      "mentorSays": "First, handle edge cases: if n is 0, return 1. If n is 1, return 1.",
      "example": "function climbStairs(n) {\n  if (n === 0) return 1;\n  if (n === 1) return 1;",
      "action": "continue",
      "next": "coding-init-js"
    },
    {
      "stepId": "coding-init-js",
      "mentorSays": "Now, create a DP array to store the number of ways. Initialize base cases: dp[0] = 1, dp[1] = 1.",
      "example": "function climbStairs(n) {\n  if (n === 0) return 1;\n  if (n === 1) return 1;\n  \n  const dp = new Array(n + 1);\n  dp[0] = 1;\n  dp[1] = 1;",
      "action": "continue",
      "next": "coding-fill-js"
    },
    {
      "stepId": "coding-fill-js",
      "mentorSays": "Now, fill the DP array: for each i from 2 to n, compute dp[i] = dp[i-1] + dp[i-2].",
      "example": "function climbStairs(n) {\n  if (n === 0) return 1;\n  if (n === 1) return 1;\n  \n  const dp = new Array(n + 1);\n  dp[0] = 1;\n  dp[1] = 1;\n  \n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i-1] + dp[i-2];\n  }",
      "action": "continue",
      "next": "coding-recursive-relation-js"
    },
    {
      "stepId": "coding-recursive-relation-js",
      "mentorSays": "Let's define the recursive relation.\n\nTo reach step i, you could have come from:\n- Step i-1 (then take 1 step)\n- Step i-2 (then take 2 steps)\n\nSo: ways[i] = ways[i-1] + ways[i-2]\n\nThis is the Fibonacci sequence!\n\nways[0] = 1\nways[1] = 1\nways[2] = ways[1] + ways[0] = 2\nways[3] = ways[2] + ways[1] = 3\nways[4] = ways[3] + ways[2] = 5\nways[5] = ways[4] + ways[3] = 8",
      "example": "// Recursive relation:\n// dp[i] = dp[i-1] + dp[i-2]\n\nfor (let i = 2; i <= n; i++) {\n  dp[i] = dp[i-1] + dp[i-2];\n}",
      "action": "continue",
      "next": "coding-space-optimization-js"
    },
    {
      "stepId": "coding-space-optimization-js",
      "mentorSays": "We can optimize space from O(n) to O(1).\n\nNotice: we only need the previous 2 values!\n\nInstead of:\nlet dp = [1, 1, 2, 3, 5, 8]\n\nWe can use:\nlet prev2 = 1;  // dp[i-2]\nlet prev1 = 1;  // dp[i-1]\nlet current;\n\nfor (let i = 2; i <= n; i++) {\n  current = prev1 + prev2;\n  prev2 = prev1;\n  prev1 = current;\n}\n\nSpace: O(n) â†’ O(1)\nTime: still O(n)",
      "example": "// Space optimized version:\nlet prev2 = 1, prev1 = 1;\nfor (let i = 2; i <= n; i++) {\n  let current = prev1 + prev2;\n  prev2 = prev1;\n  prev1 = current;\n}\nreturn prev1;",
      "action": "continue",
      "next": "coding-return-js"
    },
    {
      "stepId": "coding-return-js",
      "mentorSays": "Finally, return dp[n], which contains the number of ways to reach step n.",
      "example": "function climbStairs(n) {\n  if (n === 0) return 1;\n  if (n === 1) return 1;\n  \n  const dp = new Array(n + 1);\n  dp[0] = 1;\n  dp[1] = 1;\n  \n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i-1] + dp[i-2];\n  }\n  \n  return dp[n];\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nn = 5\n\nAfter calling climbStairs(5), it should return:\n8\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nn = 5\n\nAfter climbStairs(5):\n8",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Python?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-python"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-python"
        }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'dp' or 'ways') and put data inside it.\n\nFor example, 'dp = []' creates a variable that stores an empty list.",
      "example": "dp = []\n\nNow the variable refers to an empty list",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Python?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "array-check-python"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-python"
        }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "def add(a, b):\n    return a + b\n\nadd(3, 5) returns 8",
      "action": "continue",
      "next": "array-check-python"
    },
    {
      "stepId": "array-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a list is in Python?",
      "choices": [
        {
          "label": "Yes, I know lists",
          "next": "base-cases-check-python"
        },
        {
          "label": "No, explain lists",
          "next": "array-explanation-python"
        }
      ]
    },
    {
      "stepId": "base-cases-check-python",
      "mentorSays": "Do you understand what base cases are in dynamic programming?",
      "choices": [
        {
          "label": "Yes, I know base-cases",
          "next": "overlapping-subproblems-check-python"
        },
        {
          "label": "No, explain base-cases",
          "next": "base-cases-explanation-python"
        }
      ]
    },
    {
      "stepId": "overlapping-subproblems-check-python",
      "mentorSays": "Do you understand why we need dynamic programming for this problem?",
      "choices": [
        {
          "label": "Yes, I know overlapping-subproblems",
          "next": "coding-start-python"
        },
        {
          "label": "No, explain overlapping-subproblems",
          "next": "overlapping-subproblems-explanation-python"
        }
      ]
    },
    {
      "stepId": "overlapping-subproblems-explanation-python",
      "mentorSays": "Without DP, we recalculate the same subproblems many times. Example: ways(5) = ways(4) + ways(3) = [ways(3) + ways(2)] + [ways(2) + ways(1)]. Notice ways(2) is calculated 3 times! ways(3) is calculated 2 times! DP solves each subproblem once and reuses the result.\n\n# Without DP, we recalculate:\n# ways(5) = ways(4) + ways(3)\n#         = [ways(3) + ways(2)] + [ways(2) + ways(1)]\n# Notice: ways(2) calculated 3 times!\n#         ways(3) calculated 2 times!\n\n# With DP, we solve once and reuse:\ndp = [1, 1, 2, 3, 5, 8]\n# Each value calculated only once!\n\nGot it?",
      "example": "# Without DP, we recalculate:\n# ways(5) = ways(4) + ways(3)\n#         = [ways(3) + ways(2)] + [ways(2) + ways(1)]\n# Notice: ways(2) calculated 3 times!\n#         ways(3) calculated 2 times!\n\n# With DP, we solve once and reuse:\ndp = [1, 1, 2, 3, 5, 8]\n# Each value calculated only once!",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "base-cases-explanation-python",
      "mentorSays": "Base cases are the simplest inputs where the answer is obvious. For climbing stairs: 0 steps = 1 way (do nothing), 1 step = 1 way (one single step), 2 steps = 2 ways (two singles OR one double). These form the foundation for solving larger problems!\n\n# Base cases for climbing stairs:\n# dp[0] = 1  (one way to be at start)\n# dp[1] = 1  (one way: climb 1 step)\n\ndp = [1, 1]\n# These are the simplest cases where answer is obvious!\n\nGot it?",
      "example": "# Base cases for climbing stairs:\n# dp[0] = 1  (one way to be at start)\n# dp[1] = 1  (one way: climb 1 step)\n\ndp = [1, 1]\n# These are the simplest cases where answer is obvious!",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "array-explanation-python",
      "mentorSays": "A list is like an array - a collection of items that keeps them in order. Each item has a position number called an 'index'. List indices start counting from 0.",
      "example": "arr = [1, 2, 3]\n\narr[0] = 1\narr[1] = 2\narr[2] = 3",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Perfect! Let's implement climbing stairs using dynamic programming in Python.",
      "example": "def climb_stairs(n):\n    # Your code here\n    pass",
      "action": "continue",
      "next": "coding-base-python"
    },
    {
      "stepId": "coding-base-python",
      "mentorSays": "First, handle edge cases: if n is 0, return 1. If n is 1, return 1.",
      "example": "def climb_stairs(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1",
      "action": "continue",
      "next": "coding-init-python"
    },
    {
      "stepId": "coding-init-python",
      "mentorSays": "Now, create a DP list to store the number of ways. Initialize base cases: dp[0] = 1, dp[1] = 1.",
      "example": "def climb_stairs(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1",
      "action": "continue",
      "next": "coding-fill-python"
    },
    {
      "stepId": "coding-fill-python",
      "mentorSays": "Now, fill the DP list: for each i from 2 to n, compute dp[i] = dp[i-1] + dp[i-2].",
      "example": "def climb_stairs(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]",
      "action": "continue",
      "next": "coding-recursive-relation-python"
    },
    {
      "stepId": "coding-recursive-relation-python",
      "mentorSays": "Let's define the recursive relation.\n\nTo reach step i, you could have come from:\n- Step i-1 (then take 1 step)\n- Step i-2 (then take 2 steps)\n\nSo: ways[i] = ways[i-1] + ways[i-2]\n\nThis is the Fibonacci sequence!\n\nways[0] = 1\nways[1] = 1\nways[2] = ways[1] + ways[0] = 2\nways[3] = ways[2] + ways[1] = 3\nways[4] = ways[3] + ways[2] = 5\nways[5] = ways[4] + ways[3] = 8",
      "example": "// Recursive relation:\n// dp[i] = dp[i-1] + dp[i-2]\n\nfor (let i = 2; i <= n; i++) {\n  dp[i] = dp[i-1] + dp[i-2];\n}",
      "action": "continue",
      "next": "coding-space-optimization-python"
    },
    {
      "stepId": "coding-space-optimization-python",
      "mentorSays": "We can optimize space from O(n) to O(1).\n\nNotice: we only need the previous 2 values!\n\nInstead of:\nlet dp = [1, 1, 2, 3, 5, 8]\n\nWe can use:\nlet prev2 = 1;  // dp[i-2]\nlet prev1 = 1;  // dp[i-1]\nlet current;\n\nfor (let i = 2; i <= n; i++) {\n  current = prev1 + prev2;\n  prev2 = prev1;\n  prev1 = current;\n}\n\nSpace: O(n) â†’ O(1)\nTime: still O(n)",
      "example": "// Space optimized version:\nlet prev2 = 1, prev1 = 1;\nfor (let i = 2; i <= n; i++) {\n  let current = prev1 + prev2;\n  prev2 = prev1;\n  prev1 = current;\n}\nreturn prev1;",
      "action": "continue",
      "next": "coding-return-python"
    },
    {
      "stepId": "coding-return-python",
      "mentorSays": "Finally, return dp[n], which contains the number of ways to reach step n.",
      "example": "def climb_stairs(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nn = 5\n\nAfter calling climb_stairs(5), it should return:\n8\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nn = 5\n\nAfter climb_stairs(5):\n8",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Java?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-java"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-java"
        }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'dp' or 'ways') and put data inside it.\n\nFor example, 'int[] dp = new int[n + 1];' creates a variable that stores an array.",
      "example": "int[] dp = new int[n + 1];\n\nNow the variable refers to an array",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a method is in Java?",
      "choices": [
        {
          "label": "Yes, I know methods",
          "next": "array-check-java"
        },
        {
          "label": "No, explain methods",
          "next": "function-explanation-java"
        }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A method is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "public int add(int a, int b) {\n    return a + b;\n}\n\nadd(3, 5) returns 8",
      "action": "continue",
      "next": "array-check-java"
    },
    {
      "stepId": "array-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what an array is in Java?",
      "choices": [
        {
          "label": "Yes, I know arrays",
          "next": "base-cases-check-java"
        },
        {
          "label": "No, explain arrays",
          "next": "array-explanation-java"
        }
      ]
    },
    {
      "stepId": "base-cases-check-java",
      "mentorSays": "Do you understand what base cases are in dynamic programming?",
      "choices": [
        {
          "label": "Yes, I know base-cases",
          "next": "overlapping-subproblems-check-java"
        },
        {
          "label": "No, explain base-cases",
          "next": "base-cases-explanation-java"
        }
      ]
    },
    {
      "stepId": "overlapping-subproblems-check-java",
      "mentorSays": "Do you understand why we need dynamic programming for this problem?",
      "choices": [
        {
          "label": "Yes, I know overlapping-subproblems",
          "next": "coding-start-java"
        },
        {
          "label": "No, explain overlapping-subproblems",
          "next": "overlapping-subproblems-explanation-java"
        }
      ]
    },
    {
      "stepId": "overlapping-subproblems-explanation-java",
      "mentorSays": "Without DP, we recalculate the same subproblems many times. Example: ways(5) = ways(4) + ways(3) = [ways(3) + ways(2)] + [ways(2) + ways(1)]. Notice ways(2) is calculated 3 times! ways(3) is calculated 2 times! DP solves each subproblem once and reuses the result.\n\n// Without DP, we recalculate:\n// ways(5) = ways(4) + ways(3)\n//         = [ways(3) + ways(2)] + [ways(2) + ways(1)]\n// Notice: ways(2) calculated 3 times!\n//         ways(3) calculated 2 times!\n\n// With DP, we solve once and reuse:\nint[] dp = {1, 1, 2, 3, 5, 8};\n// Each value calculated only once!\n\nGot it?",
      "example": "// Without DP, we recalculate:\n// ways(5) = ways(4) + ways(3)\n//         = [ways(3) + ways(2)] + [ways(2) + ways(1)]\n// Notice: ways(2) calculated 3 times!\n//         ways(3) calculated 2 times!\n\n// With DP, we solve once and reuse:\nint[] dp = {1, 1, 2, 3, 5, 8};\n// Each value calculated only once!",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "base-cases-explanation-java",
      "mentorSays": "Base cases are the simplest inputs where the answer is obvious. For climbing stairs: 0 steps = 1 way (do nothing), 1 step = 1 way (one single step), 2 steps = 2 ways (two singles OR one double). These form the foundation for solving larger problems!\n\n// Base cases for climbing stairs:\n// dp[0] = 1  (one way to be at start)\n// dp[1] = 1  (one way: climb 1 step)\n\nint[] dp = {1, 1};\n// These are the simplest cases where answer is obvious!\n\nGot it?",
      "example": "// Base cases for climbing stairs:\n// dp[0] = 1  (one way to be at start)\n// dp[1] = 1  (one way: climb 1 step)\n\nint[] dp = {1, 1};\n// These are the simplest cases where answer is obvious!",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "array-explanation-java",
      "mentorSays": "An array is like a list of items that keeps them in order. Each item has a position number called an 'index'. Array indices start counting from 0.",
      "example": "int[] arr = {1, 2, 3};\n\narr[0] = 1\narr[1] = 2\narr[2] = 3",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Perfect! Let's implement climbing stairs using dynamic programming in Java.",
      "example": "public int climbStairs(int n) {\n    // Your code here\n}",
      "action": "continue",
      "next": "coding-base-java"
    },
    {
      "stepId": "coding-base-java",
      "mentorSays": "First, handle edge cases: if n is 0, return 1. If n is 1, return 1.",
      "example": "public int climbStairs(int n) {\n    if (n == 0) return 1;\n    if (n == 1) return 1;",
      "action": "continue",
      "next": "coding-init-java"
    },
    {
      "stepId": "coding-init-java",
      "mentorSays": "Now, create a DP array to store the number of ways. Initialize base cases: dp[0] = 1, dp[1] = 1.",
      "example": "public int climbStairs(int n) {\n    if (n == 0) return 1;\n    if (n == 1) return 1;\n    \n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;",
      "action": "continue",
      "next": "coding-fill-java"
    },
    {
      "stepId": "coding-fill-java",
      "mentorSays": "Now, fill the DP array: for each i from 2 to n, compute dp[i] = dp[i-1] + dp[i-2].",
      "example": "public int climbStairs(int n) {\n    if (n == 0) return 1;\n    if (n == 1) return 1;\n    \n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n    \n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i-1] + dp[i-2];\n    }",
      "action": "continue",
      "next": "coding-recursive-relation-java"
    },
    {
      "stepId": "coding-recursive-relation-java",
      "mentorSays": "Let's define the recursive relation.\n\nTo reach step i, you could have come from:\n- Step i-1 (then take 1 step)\n- Step i-2 (then take 2 steps)\n\nSo: ways[i] = ways[i-1] + ways[i-2]\n\nThis is the Fibonacci sequence!\n\nways[0] = 1\nways[1] = 1\nways[2] = ways[1] + ways[0] = 2\nways[3] = ways[2] + ways[1] = 3\nways[4] = ways[3] + ways[2] = 5\nways[5] = ways[4] + ways[3] = 8",
      "example": "// Recursive relation:\n// dp[i] = dp[i-1] + dp[i-2]\n\nfor (let i = 2; i <= n; i++) {\n  dp[i] = dp[i-1] + dp[i-2];\n}",
      "action": "continue",
      "next": "coding-space-optimization-java"
    },
    {
      "stepId": "coding-space-optimization-java",
      "mentorSays": "We can optimize space from O(n) to O(1).\n\nNotice: we only need the previous 2 values!\n\nInstead of:\nlet dp = [1, 1, 2, 3, 5, 8]\n\nWe can use:\nlet prev2 = 1;  // dp[i-2]\nlet prev1 = 1;  // dp[i-1]\nlet current;\n\nfor (let i = 2; i <= n; i++) {\n  current = prev1 + prev2;\n  prev2 = prev1;\n  prev1 = current;\n}\n\nSpace: O(n) â†’ O(1)\nTime: still O(n)",
      "example": "// Space optimized version:\nlet prev2 = 1, prev1 = 1;\nfor (let i = 2; i <= n; i++) {\n  let current = prev1 + prev2;\n  prev2 = prev1;\n  prev1 = current;\n}\nreturn prev1;",
      "action": "continue",
      "next": "coding-return-java"
    },
    {
      "stepId": "coding-return-java",
      "mentorSays": "Finally, return dp[n], which contains the number of ways to reach step n.",
      "example": "public int climbStairs(int n) {\n    if (n == 0) return 1;\n    if (n == 1) return 1;\n    \n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n    \n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i-1] + dp[i-2];\n    }\n    \n    return dp[n];\n}",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nn = 5\n\nAfter calling climbStairs(5), it should return:\n8\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nn = 5\n\nAfter climbStairs(5):\n8",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in C++?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-cpp"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'dp' or 'ways') and put data inside it.\n\nFor example, 'vector<int> dp(n + 1);' creates a variable that stores a vector.",
      "example": "vector<int> dp(n + 1);\n\nNow the variable refers to a vector",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in C++?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "array-check-cpp"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "int add(int a, int b) {\n    return a + b;\n}\n\nadd(3, 5) returns 8",
      "action": "continue",
      "next": "array-check-cpp"
    },
    {
      "stepId": "array-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a vector is in C++?",
      "choices": [
        {
          "label": "Yes, I know vectors",
          "next": "base-cases-check-cpp"
        },
        {
          "label": "No, explain vectors",
          "next": "array-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "base-cases-check-cpp",
      "mentorSays": "Do you understand what base cases are in dynamic programming?",
      "choices": [
        {
          "label": "Yes, I know base-cases",
          "next": "overlapping-subproblems-check-cpp"
        },
        {
          "label": "No, explain base-cases",
          "next": "base-cases-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "overlapping-subproblems-check-cpp",
      "mentorSays": "Do you understand why we need dynamic programming for this problem?",
      "choices": [
        {
          "label": "Yes, I know overlapping-subproblems",
          "next": "coding-start-cpp"
        },
        {
          "label": "No, explain overlapping-subproblems",
          "next": "overlapping-subproblems-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "overlapping-subproblems-explanation-cpp",
      "mentorSays": "Without DP, we recalculate the same subproblems many times. Example: ways(5) = ways(4) + ways(3) = [ways(3) + ways(2)] + [ways(2) + ways(1)]. Notice ways(2) is calculated 3 times! ways(3) is calculated 2 times! DP solves each subproblem once and reuses the result.\n\n// Without DP, we recalculate:\n// ways(5) = ways(4) + ways(3)\n//         = [ways(3) + ways(2)] + [ways(2) + ways(1)]\n// Notice: ways(2) calculated 3 times!\n//         ways(3) calculated 2 times!\n\n// With DP, we solve once and reuse:\nvector<int> dp = {1, 1, 2, 3, 5, 8};\n// Each value calculated only once!\n\nGot it?",
      "example": "// Without DP, we recalculate:\n// ways(5) = ways(4) + ways(3)\n//         = [ways(3) + ways(2)] + [ways(2) + ways(1)]\n// Notice: ways(2) calculated 3 times!\n//         ways(3) calculated 2 times!\n\n// With DP, we solve once and reuse:\nvector<int> dp = {1, 1, 2, 3, 5, 8};\n// Each value calculated only once!",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "base-cases-explanation-cpp",
      "mentorSays": "Base cases are the simplest inputs where the answer is obvious. For climbing stairs: 0 steps = 1 way (do nothing), 1 step = 1 way (one single step), 2 steps = 2 ways (two singles OR one double). These form the foundation for solving larger problems!\n\n// Base cases for climbing stairs:\n// dp[0] = 1  (one way to be at start)\n// dp[1] = 1  (one way: climb 1 step)\n\nvector<int> dp = {1, 1};\n// These are the simplest cases where answer is obvious!\n\nGot it?",
      "example": "// Base cases for climbing stairs:\n// dp[0] = 1  (one way to be at start)\n// dp[1] = 1  (one way: climb 1 step)\n\nvector<int> dp = {1, 1};\n// These are the simplest cases where answer is obvious!",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "array-explanation-cpp",
      "mentorSays": "A vector is like an array - a collection of items that keeps them in order. Each item has a position number called an 'index'. Vector indices start counting from 0.",
      "example": "vector<int> arr = {1, 2, 3};\n\narr[0] = 1\narr[1] = 2\narr[2] = 3",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Perfect! Let's implement climbing stairs using dynamic programming in C++.",
      "example": "int climbStairs(int n) {\n    // Your code here\n}",
      "action": "continue",
      "next": "coding-base-cpp"
    },
    {
      "stepId": "coding-base-cpp",
      "mentorSays": "First, handle edge cases: if n is 0, return 1. If n is 1, return 1.",
      "example": "int climbStairs(int n) {\n    if (n == 0) return 1;\n    if (n == 1) return 1;",
      "action": "continue",
      "next": "coding-init-cpp"
    },
    {
      "stepId": "coding-init-cpp",
      "mentorSays": "Now, create a DP vector to store the number of ways. Initialize base cases: dp[0] = 1, dp[1] = 1.",
      "example": "int climbStairs(int n) {\n    if (n == 0) return 1;\n    if (n == 1) return 1;\n    \n    vector<int> dp(n + 1);\n    dp[0] = 1;\n    dp[1] = 1;",
      "action": "continue",
      "next": "coding-fill-cpp"
    },
    {
      "stepId": "coding-fill-cpp",
      "mentorSays": "Now, fill the DP vector: for each i from 2 to n, compute dp[i] = dp[i-1] + dp[i-2].",
      "example": "int climbStairs(int n) {\n    if (n == 0) return 1;\n    if (n == 1) return 1;\n    \n    vector<int> dp(n + 1);\n    dp[0] = 1;\n    dp[1] = 1;\n    \n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i-1] + dp[i-2];\n    }",
      "action": "continue",
      "next": "coding-recursive-relation-cpp"
    },
    {
      "stepId": "coding-recursive-relation-cpp",
      "mentorSays": "Let's define the recursive relation.\n\nTo reach step i, you could have come from:\n- Step i-1 (then take 1 step)\n- Step i-2 (then take 2 steps)\n\nSo: ways[i] = ways[i-1] + ways[i-2]\n\nThis is the Fibonacci sequence!\n\nways[0] = 1\nways[1] = 1\nways[2] = ways[1] + ways[0] = 2\nways[3] = ways[2] + ways[1] = 3\nways[4] = ways[3] + ways[2] = 5\nways[5] = ways[4] + ways[3] = 8",
      "example": "// Recursive relation:\n// dp[i] = dp[i-1] + dp[i-2]\n\nfor (let i = 2; i <= n; i++) {\n  dp[i] = dp[i-1] + dp[i-2];\n}",
      "action": "continue",
      "next": "coding-space-optimization-cpp"
    },
    {
      "stepId": "coding-space-optimization-cpp",
      "mentorSays": "We can optimize space from O(n) to O(1).\n\nNotice: we only need the previous 2 values!\n\nInstead of:\nlet dp = [1, 1, 2, 3, 5, 8]\n\nWe can use:\nlet prev2 = 1;  // dp[i-2]\nlet prev1 = 1;  // dp[i-1]\nlet current;\n\nfor (let i = 2; i <= n; i++) {\n  current = prev1 + prev2;\n  prev2 = prev1;\n  prev1 = current;\n}\n\nSpace: O(n) â†’ O(1)\nTime: still O(n)",
      "example": "// Space optimized version:\nlet prev2 = 1, prev1 = 1;\nfor (let i = 2; i <= n; i++) {\n  let current = prev1 + prev2;\n  prev2 = prev1;\n  prev1 = current;\n}\nreturn prev1;",
      "action": "continue",
      "next": "coding-return-cpp"
    },
    {
      "stepId": "coding-return-cpp",
      "mentorSays": "Finally, return dp[n], which contains the number of ways to reach step n.",
      "example": "int climbStairs(int n) {\n    if (n == 0) return 1;\n    if (n == 1) return 1;\n    \n    vector<int> dp(n + 1);\n    dp[0] = 1;\n    dp[1] = 1;\n    \n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i-1] + dp[i-2];\n    }\n    \n    return dp[n];\n}",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nn = 5\n\nAfter calling climbStairs(5), it should return:\n8\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nn = 5\n\nAfter climbStairs(5):\n8",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-ts"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-ts"
        }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'dp' or 'ways') and put data inside it.\n\nFor example, 'let dp: number[] = [];' creates a variable that stores an empty array.",
      "example": "let dp: number[] = [];\n\nNow the variable refers to an empty array",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "array-check-ts"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-ts"
        }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function add(a: number, b: number): number {\n  return a + b;\n}\n\nadd(3, 5) returns 8",
      "action": "continue",
      "next": "array-check-ts"
    },
    {
      "stepId": "array-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what an array is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know arrays",
          "next": "base-cases-check-ts"
        },
        {
          "label": "No, explain arrays",
          "next": "array-explanation-ts"
        }
      ]
    },
    {
      "stepId": "base-cases-check-ts",
      "mentorSays": "Do you understand what base cases are in dynamic programming?",
      "choices": [
        {
          "label": "Yes, I know base-cases",
          "next": "overlapping-subproblems-check-ts"
        },
        {
          "label": "No, explain base-cases",
          "next": "base-cases-explanation-ts"
        }
      ]
    },
    {
      "stepId": "overlapping-subproblems-check-ts",
      "mentorSays": "Do you understand why we need dynamic programming for this problem?",
      "choices": [
        {
          "label": "Yes, I know overlapping-subproblems",
          "next": "coding-start-ts"
        },
        {
          "label": "No, explain overlapping-subproblems",
          "next": "overlapping-subproblems-explanation-ts"
        }
      ]
    },
    {
      "stepId": "overlapping-subproblems-explanation-ts",
      "mentorSays": "Without DP, we recalculate the same subproblems many times. Example: ways(5) = ways(4) + ways(3) = [ways(3) + ways(2)] + [ways(2) + ways(1)]. Notice ways(2) is calculated 3 times! ways(3) is calculated 2 times! DP solves each subproblem once and reuses the result.\n\n// Without DP, we recalculate:\n// ways(5) = ways(4) + ways(3)\n//         = [ways(3) + ways(2)] + [ways(2) + ways(1)]\n// Notice: ways(2) calculated 3 times!\n//         ways(3) calculated 2 times!\n\n// With DP, we solve once and reuse:\nlet dp: number[] = [1, 1, 2, 3, 5, 8];\n// Each value calculated only once!\n\nGot it?",
      "example": "// Without DP, we recalculate:\n// ways(5) = ways(4) + ways(3)\n//         = [ways(3) + ways(2)] + [ways(2) + ways(1)]\n// Notice: ways(2) calculated 3 times!\n//         ways(3) calculated 2 times!\n\n// With DP, we solve once and reuse:\nlet dp: number[] = [1, 1, 2, 3, 5, 8];\n// Each value calculated only once!",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "base-cases-explanation-ts",
      "mentorSays": "Base cases are the simplest inputs where the answer is obvious. For climbing stairs: 0 steps = 1 way (do nothing), 1 step = 1 way (one single step), 2 steps = 2 ways (two singles OR one double). These form the foundation for solving larger problems!\n\n// Base cases for climbing stairs:\n// dp[0] = 1  (one way to be at start)\n// dp[1] = 1  (one way: climb 1 step)\n\nlet dp: number[] = [1, 1];\n// These are the simplest cases where answer is obvious!\n\nGot it?",
      "example": "// Base cases for climbing stairs:\n// dp[0] = 1  (one way to be at start)\n// dp[1] = 1  (one way: climb 1 step)\n\nlet dp: number[] = [1, 1];\n// These are the simplest cases where answer is obvious!",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "array-explanation-ts",
      "mentorSays": "An array is like a list of items that keeps them in order. Each item has a position number called an 'index'. Array indices start counting from 0.",
      "example": "arr: number[] = [1, 2, 3]\n\narr[0] = 1\narr[1] = 2\narr[2] = 3",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Perfect! Let's implement climbing stairs using dynamic programming in TypeScript.",
      "example": "function climbStairs(n: number): number {\n  // Your code here\n}",
      "action": "continue",
      "next": "coding-base-ts"
    },
    {
      "stepId": "coding-base-ts",
      "mentorSays": "First, handle edge cases: if n is 0, return 1. If n is 1, return 1.",
      "example": "function climbStairs(n: number): number {\n  if (n === 0) return 1;\n  if (n === 1) return 1;",
      "action": "continue",
      "next": "coding-init-ts"
    },
    {
      "stepId": "coding-init-ts",
      "mentorSays": "Now, create a DP array to store the number of ways. Initialize base cases: dp[0] = 1, dp[1] = 1.",
      "example": "function climbStairs(n: number): number {\n  if (n === 0) return 1;\n  if (n === 1) return 1;\n  \n  const dp: number[] = new Array(n + 1);\n  dp[0] = 1;\n  dp[1] = 1;",
      "action": "continue",
      "next": "coding-fill-ts"
    },
    {
      "stepId": "coding-fill-ts",
      "mentorSays": "Now, fill the DP array: for each i from 2 to n, compute dp[i] = dp[i-1] + dp[i-2].",
      "example": "function climbStairs(n: number): number {\n  if (n === 0) return 1;\n  if (n === 1) return 1;\n  \n  const dp: number[] = new Array(n + 1);\n  dp[0] = 1;\n  dp[1] = 1;\n  \n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i-1] + dp[i-2];\n  }",
      "action": "continue",
      "next": "coding-recursive-relation-ts"
    },
    {
      "stepId": "coding-recursive-relation-ts",
      "mentorSays": "Let's define the recursive relation.\n\nTo reach step i, you could have come from:\n- Step i-1 (then take 1 step)\n- Step i-2 (then take 2 steps)\n\nSo: ways[i] = ways[i-1] + ways[i-2]\n\nThis is the Fibonacci sequence!\n\nways[0] = 1\nways[1] = 1\nways[2] = ways[1] + ways[0] = 2\nways[3] = ways[2] + ways[1] = 3\nways[4] = ways[3] + ways[2] = 5\nways[5] = ways[4] + ways[3] = 8",
      "example": "// Recursive relation:\n// dp[i] = dp[i-1] + dp[i-2]\n\nfor (let i = 2; i <= n; i++) {\n  dp[i] = dp[i-1] + dp[i-2];\n}",
      "action": "continue",
      "next": "coding-space-optimization-ts"
    },
    {
      "stepId": "coding-space-optimization-ts",
      "mentorSays": "We can optimize space from O(n) to O(1).\n\nNotice: we only need the previous 2 values!\n\nInstead of:\nlet dp = [1, 1, 2, 3, 5, 8]\n\nWe can use:\nlet prev2 = 1;  // dp[i-2]\nlet prev1 = 1;  // dp[i-1]\nlet current;\n\nfor (let i = 2; i <= n; i++) {\n  current = prev1 + prev2;\n  prev2 = prev1;\n  prev1 = current;\n}\n\nSpace: O(n) â†’ O(1)\nTime: still O(n)",
      "example": "// Space optimized version:\nlet prev2 = 1, prev1 = 1;\nfor (let i = 2; i <= n; i++) {\n  let current = prev1 + prev2;\n  prev2 = prev1;\n  prev1 = current;\n}\nreturn prev1;",
      "action": "continue",
      "next": "coding-return-ts"
    },
    {
      "stepId": "coding-return-ts",
      "mentorSays": "Finally, return dp[n], which contains the number of ways to reach step n.",
      "example": "function climbStairs(n: number): number {\n  if (n === 0) return 1;\n  if (n === 1) return 1;\n  \n  const dp: number[] = new Array(n + 1);\n  dp[0] = 1;\n  dp[1] = 1;\n  \n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i-1] + dp[i-2];\n  }\n  \n  return dp[n];\n}",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nn = 5\n\nAfter calling climbStairs(5), it should return:\n8\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nn = 5\n\nAfter climbStairs(5):\n8",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "final",
      "mentorSays": "ðŸŽ‰ Well done! You've learned climbing stairs using dynamic programming. You understand how this problem is essentially the Fibonacci sequence - each step depends on the previous two!\n\nThis is O(n) time and O(n) space - much better than exponential recursion! Keep practicing!",
      "action": "continue"
    }
  ]
}