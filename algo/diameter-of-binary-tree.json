{
  "id": "diameter-of-binary-tree",
  "title": "Diameter of Binary Tree",
  "pattern": "tree",
  "difficulty": "easy",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what the Diameter of Binary Tree problem asks for\n2. Use recursion to calculate the diameter\n3. Track both height and diameter in the same traversal\n4. Understand that diameter may pass through root or not\n5. Implement the solution step by step in your chosen language",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Perfect! Now let's understand what the Diameter of Binary Tree problem is asking.\n\n**Problem Definition:**\nGiven the root of a binary tree, return the length of the diameter of the tree.\n\nThe diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\n\nThe length of a path between two nodes is represented by the number of edges between them.\n\n**Key Observations:**\n- Diameter is the longest path between any two nodes\n- Path length is measured in edges (not nodes)\n- The path may or may not pass through the root\n- We need to check all possible paths\n\n**Example 1:**\nTree:\n    1\n   / \\\n  2   3\n / \\\n4   5\n\nLongest path: 4 -> 2 -> 1 -> 3 (3 edges)\nOR: 4 -> 2 -> 5 (3 edges)\n\nDiameter: 3\n\n**Example 2:**\nTree:\n    1\n   /\n  2\n\nLongest path: 1 -> 2 (1 edge)\n\nDiameter: 1\n\n**Step-by-step trace for Example 1 (Recursive approach):**\n\nTree:\n    1\n   / \\\n  2   3\n / \\\n4   5\n\nWe'll use recursion to calculate height and track diameter:\n- **diameter(1)**:\n  - Left height = diameter(2) = 2\n  - Right height = diameter(3) = 0\n  - Diameter through root = 2 + 0 = 2\n  - Max diameter = max(2, left_diameter, right_diameter)\n  - Return height = 1 + max(2, 0) = 3\n\n- **diameter(2)**:\n  - Left height = diameter(4) = 0\n  - Right height = diameter(5) = 0\n  - Diameter through root = 0 + 0 = 0\n  - Max diameter = max(0, 0, 0) = 0\n  - But actual diameter at node 2 = 1 (path 4->2->5)\n  - Return height = 1 + max(0, 0) = 1\n\n**Key Insight:**\nThe diameter at a node = left height + right height. We need to track the maximum diameter across all nodes!\n\n**What makes this tricky:**\n1. Understanding that diameter may not pass through root\n2. Calculating diameter at each node (left height + right height)\n3. Tracking the maximum diameter globally\n4. Returning height from recursion (not diameter)\n\n**Common pitfalls:**\n- Only checking diameter through root\n- Not tracking maximum diameter globally\n- Confusing height (edges) with depth (nodes)\n- Returning diameter instead of height from helper function",
      "example": "Example 1:\nTree:\n    1\n   / \\\n  2   3\n / \\\n4   5\n\nDiameter: 3 (path: 4->2->1->3 or 4->2->5)\n\nExample 2:\nTree:\n    1\n   /\n  2\n\nDiameter: 1 (path: 1->2)",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Now that you understand what the problem wants, here's the real question:\n\nHow would YOU find the diameter of a binary tree?\n\nThink about it for a moment. What approach feels natural to you?",
      "choices": [
        {
          "label": "Use recursion - calculate height and track diameter at each node",
          "next": "explore-recursive"
        },
        {
          "label": "Use BFS to find longest path between all pairs of nodes",
          "next": "explore-bfs"
        },
        {
          "label": "Find all paths and return the longest",
          "next": "explore-all-paths"
        }
      ]
    },
    {
      "stepId": "explore-bfs",
      "mentorSays": "That's a thorough approach! You're thinking: \"I'll use BFS to find the longest path between all pairs of nodes.\"\n\nThis works! However, it's O(nÂ²) time and more complex than needed.\n\nThere's a more efficient O(n) recursive approach. Would you like to learn that?",
      "action": "continue",
      "next": "explore-recursive"
    },
    {
      "stepId": "explore-all-paths",
      "mentorSays": "That's a comprehensive approach! You're thinking: \"I'll find all paths and return the longest.\"\n\nThis works! However, it's inefficient and complex.\n\nThere's a simpler recursive approach that's O(n) time. Would you like to learn that?",
      "action": "continue",
      "next": "explore-recursive"
    },
    {
      "stepId": "explore-recursive",
      "mentorSays": "Excellent choice! Recursion is the most elegant solution for this problem. Here's the core idea:\n\n**The Algorithm:**\n1. **Helper function**: Calculate height and track diameter\n2. **At each node**:\n   - Calculate left height: height(node.left)\n   - Calculate right height: height(node.right)\n   - Diameter through this node = left height + right height\n   - Update global maximum diameter\n   - Return height = 1 + max(left height, right height)\n3. **Base case**: Null node returns height 0\n4. **Return maximum diameter**\n\n**Why it works**:\n- The diameter at a node = left height + right height (longest path through that node)\n- We check all nodes and track the maximum\n- The helper returns height (needed for parent's calculation)\n- We use a global variable or return both height and diameter\n\n**Key insight**: The diameter may pass through any node, not just the root! We need to check all nodes.\n\nLet's trace with tree:\n    1\n   / \\\n  2   3\n / \\\n4   5\n\n- **diameter(1)**:\n  - Left height = diameter(2) = 1\n  - Right height = diameter(3) = 0\n  - Diameter through 1 = 1 + 0 = 1\n  - Max diameter = max(1, ...) = 1\n  - Return height = 1 + max(1, 0) = 2\n\n- **diameter(2)**:\n  - Left height = diameter(4) = 0\n  - Right height = diameter(5) = 0\n  - Diameter through 2 = 0 + 0 = 0\n  - But wait, path 4->2->5 has 2 edges!\n  - Actually: left height = 1 (from 4), right height = 1 (from 5)\n  - Diameter through 2 = 1 + 1 = 2\n  - Max diameter = max(2, ...) = 2\n  - Return height = 1 + max(1, 1) = 2\n\nThis is O(n) time and O(h) space! Now let's code it step by step.",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Great! Now let's code this solution. Which programming language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "variable-check-js"
        },
        {
          "label": "Python",
          "next": "variable-check-python"
        },
        {
          "label": "Java",
          "next": "variable-check-java"
        },
        {
          "label": "C++",
          "next": "variable-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "variable-check-ts"
        }
      ]
    },
    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-js"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-js"
        }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'maxDiameter' or 'leftHeight') and put data inside it.",
      "example": "let maxDiameter = 0;  // Maximum diameter found\nlet leftHeight = 0;  // Height of left subtree",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-js"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-js"
        }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function diameterOfBinaryTree(root) {\n  // Returns diameter of tree\n  return 0;\n}",
      "action": "continue",
      "next": "parameter-check-js"
    },
    {
      "stepId": "parameter-check-js",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-js"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-js"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-js",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function diameterOfBinaryTree(root)', the 'root' is a parameter that receives the root node.",
      "example": "function diameterOfBinaryTree(root) {\n  // Parameter receives root node\n}\n\n// Call: diameterOfBinaryTree(rootNode)",
      "action": "continue",
      "next": "tree-check-js"
    },
    {
      "stepId": "tree-check-js",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-js"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-js"
        }
      ]
    },
    {
      "stepId": "tree-explanation-js",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-js"
    },
    {
      "stepId": "recursion-check-js",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-js"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-js"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-js",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees",
      "example": "function height(root, maxDiameter) {\n  if (root === null) return 0;\n  \n  // Recursive calls\n  let leftHeight = height(root.left, maxDiameter);\n  let rightHeight = height(root.right, maxDiameter);\n  \n  // Update diameter\n  maxDiameter[0] = Math.max(maxDiameter[0], leftHeight + rightHeight);\n  \n  return 1 + Math.max(leftHeight, rightHeight);\n}",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Perfect! Let's implement the diameter of binary tree solution in JavaScript. We'll create a function that takes the root and returns the diameter.",
      "example": "function diameterOfBinaryTree(root) {\n  \n}",
      "action": "continue",
      "next": "coding-init-max-js"
    },
    {
      "stepId": "coding-init-max-js",
      "mentorSays": "Initialize a variable to track the maximum diameter. We'll use an array to pass by reference.",
      "example": "function diameterOfBinaryTree(root) {\n  // Track maximum diameter\n  let maxDiameter = [0];\n  \n}",
      "action": "continue",
      "next": "coding-helper-start-js"
    },
    {
      "stepId": "coding-helper-start-js",
      "mentorSays": "Create a helper function that calculates height and updates the maximum diameter.",
      "example": "function diameterOfBinaryTree(root) {\n  let maxDiameter = [0];\n  \n  // Helper function to calculate height and track diameter\n  function height(node) {\n    // Height calculation here\n  }\n  \n}",
      "action": "continue",
      "next": "coding-helper-base-js"
    },
    {
      "stepId": "coding-helper-base-js",
      "mentorSays": "In the helper function, handle the base case: if node is null, return 0.",
      "example": "function diameterOfBinaryTree(root) {\n  let maxDiameter = [0];\n  \n  function height(node) {\n    // Base case: empty tree has height 0\n    if (node === null) {\n      return 0;\n    }\n    \n  }\n  \n}",
      "action": "continue",
      "next": "coding-helper-recursive-js"
    },
    {
      "stepId": "coding-helper-recursive-js",
      "mentorSays": "Recursively calculate left and right heights.",
      "example": "function diameterOfBinaryTree(root) {\n  let maxDiameter = [0];\n  \n  function height(node) {\n    if (node === null) {\n      return 0;\n    }\n    \n    // Recursively calculate heights\n    let leftHeight = height(node.left);\n    let rightHeight = height(node.right);\n    \n  }\n  \n}",
      "action": "continue",
      "next": "coding-update-diameter-js"
    },
    {
      "stepId": "coding-update-diameter-js",
      "mentorSays": "Update the maximum diameter: diameter through this node = leftHeight + rightHeight.",
      "example": "function diameterOfBinaryTree(root) {\n  let maxDiameter = [0];\n  \n  function height(node) {\n    if (node === null) {\n      return 0;\n    }\n    \n    let leftHeight = height(node.left);\n    let rightHeight = height(node.right);\n    \n    // Update maximum diameter\n    maxDiameter[0] = Math.max(maxDiameter[0], leftHeight + rightHeight);\n    \n  }\n  \n}",
      "action": "continue",
      "next": "coding-return-height-js"
    },
    {
      "stepId": "coding-return-height-js",
      "mentorSays": "Return the height of the current node: 1 + max(leftHeight, rightHeight).",
      "example": "function diameterOfBinaryTree(root) {\n  let maxDiameter = [0];\n  \n  function height(node) {\n    if (node === null) {\n      return 0;\n    }\n    \n    let leftHeight = height(node.left);\n    let rightHeight = height(node.right);\n    \n    maxDiameter[0] = Math.max(maxDiameter[0], leftHeight + rightHeight);\n    \n    // Return height of current node\n    return 1 + Math.max(leftHeight, rightHeight);\n  }\n  \n}",
      "action": "continue",
      "next": "coding-call-return-js"
    },
    {
      "stepId": "coding-call-return-js",
      "mentorSays": "Call the helper function and return the maximum diameter.",
      "example": "function diameterOfBinaryTree(root) {\n  let maxDiameter = [0];\n  \n  function height(node) {\n    if (node === null) {\n      return 0;\n    }\n    \n    let leftHeight = height(node.left);\n    let rightHeight = height(node.right);\n    \n    maxDiameter[0] = Math.max(maxDiameter[0], leftHeight + rightHeight);\n    \n    return 1 + Math.max(leftHeight, rightHeight);\n  }\n  \n  // Call helper to calculate and update diameter\n  height(root);\n  \n  return maxDiameter[0];\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [1, 2, 3, 4, 5]\nExpected: 3 (path: 4->2->1->3 or 4->2->5)\n\n**Test 2:** root = [1, 2]\nExpected: 1 (path: 1->2)\n\n**Test 3:** root = [1]\nExpected: 0 (single node, no edges)\n\n**Test 4:** root = [1, 2, null, 4, 5, null, null, 6, 7]\nExpected: 4 (long path through node 2)\n\n**Test 5:** root = null\nExpected: 0 (empty tree)\n\n**Test 6:** root = [1, 2, 3, null, null, 4, 5]\nExpected: 3 (path through root)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,2,3,4,5] â†’ 3\nTest 2: [1,2] â†’ 1\nTest 3: [1] â†’ 0\nTest 4: [1,2,null,4,5,null,null,6,7] â†’ 4\nTest 5: null â†’ 0\nTest 6: [1,2,3,null,null,4,5] â†’ 3",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Python?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-python"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-python"
        }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'maxDiameter' or 'leftHeight') and put data inside it.",
      "example": " maxDiameter = 0;  // Maximum diameter found\n leftHeight = 0;  // Height of left subtree",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Python?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-python"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-python"
        }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "def diameterOfBinaryTree(root) {\n  // Returns diameter of tree\n  return 0;\n}",
      "action": "continue",
      "next": "parameter-check-python"
    },
    {
      "stepId": "parameter-check-python",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-python"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-python"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-python",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'def diameterOfBinaryTree(root)', the 'root' is a parameter that receives the root node.",
      "example": "def diameterOfBinaryTree(root) {\n  // Parameter receives root node\n}\n\n// Call: diameterOfBinaryTree(rootNode)",
      "action": "continue",
      "next": "tree-check-python"
    },
    {
      "stepId": "tree-check-python",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-python"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-python"
        }
      ]
    },
    {
      "stepId": "tree-explanation-python",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-python"
    },
    {
      "stepId": "recursion-check-python",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in Python?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-python"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-python"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-python",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees",
      "example": "function height(root, maxDiameter) {\n  if (root === null) return 0;\n  \n  // Recursive calls\n  let leftHeight = height(root.left, maxDiameter);\n  let rightHeight = height(root.right, maxDiameter);\n  \n  // Update diameter\n  maxDiameter[0] = Math.max(maxDiameter[0], leftHeight + rightHeight);\n  \n  return 1 + Math.max(leftHeight, rightHeight);\n}",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Perfect! Let's implement the solution in Python.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-init-max-python"
    },
    {
      "stepId": "coding-init-max-python",
      "mentorSays": "Initialize max diameter tracker.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-helper-start-python"
    },
    {
      "stepId": "coding-helper-start-python",
      "mentorSays": "Create helper function.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-helper-base-python"
    },
    {
      "stepId": "coding-helper-base-python",
      "mentorSays": "Handle base case in helper.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-helper-recursive-python"
    },
    {
      "stepId": "coding-helper-recursive-python",
      "mentorSays": "Recursively calculate heights.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-update-diameter-python"
    },
    {
      "stepId": "coding-update-diameter-python",
      "mentorSays": "Update maximum diameter.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-return-height-python"
    },
    {
      "stepId": "coding-return-height-python",
      "mentorSays": "Return height.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-call-return-python"
    },
    {
      "stepId": "coding-call-return-python",
      "mentorSays": "Call helper and return diameter.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [1, 2, 3, 4, 5]\nExpected: 3 (path: 4->2->1->3 or 4->2->5)\n\n**Test 2:** root = [1, 2]\nExpected: 1 (path: 1->2)\n\n**Test 3:** root = [1]\nExpected: 0 (single node, no edges)\n\n**Test 4:** root = [1, 2, null, 4, 5, null, null, 6, 7]\nExpected: 4 (long path through node 2)\n\n**Test 5:** root = null\nExpected: 0 (empty tree)\n\n**Test 6:** root = [1, 2, 3, null, null, 4, 5]\nExpected: 3 (path through root)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,2,3,4,5] â†’ 3\nTest 2: [1,2] â†’ 1\nTest 3: [1] â†’ 0\nTest 4: [1,2,null,4,5,null,null,6,7] â†’ 4\nTest 5: null â†’ 0\nTest 6: [1,2,3,null,null,4,5] â†’ 3",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Java?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-java"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-java"
        }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'maxDiameter' or 'leftHeight') and put data inside it.",
      "example": "int maxDiameter = 0;  // Maximum diameter found\nint leftHeight = 0;  // Height of left subtree",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Java?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-java"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-java"
        }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "public int diameterOfBinaryTree(root) {\n  // Returns diameter of tree\n  return 0;\n}",
      "action": "continue",
      "next": "parameter-check-java"
    },
    {
      "stepId": "parameter-check-java",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-java"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-java"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-java",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'public int diameterOfBinaryTree(root)', the 'root' is a parameter that receives the root node.",
      "example": "public int diameterOfBinaryTree(root) {\n  // Parameter receives root node\n}\n\n// Call: diameterOfBinaryTree(rootNode)",
      "action": "continue",
      "next": "tree-check-java"
    },
    {
      "stepId": "tree-check-java",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-java"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-java"
        }
      ]
    },
    {
      "stepId": "tree-explanation-java",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-java"
    },
    {
      "stepId": "recursion-check-java",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in Java?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-java"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-java"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-java",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees",
      "example": "function height(root, maxDiameter) {\n  if (root === null) return 0;\n  \n  // Recursive calls\n  let leftHeight = height(root.left, maxDiameter);\n  let rightHeight = height(root.right, maxDiameter);\n  \n  // Update diameter\n  maxDiameter[0] = Math.max(maxDiameter[0], leftHeight + rightHeight);\n  \n  return 1 + Math.max(leftHeight, rightHeight);\n}",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Perfect! Let's implement the solution in Java.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-init-max-java"
    },
    {
      "stepId": "coding-init-max-java",
      "mentorSays": "Initialize max diameter tracker.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-helper-start-java"
    },
    {
      "stepId": "coding-helper-start-java",
      "mentorSays": "Create helper function.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-helper-base-java"
    },
    {
      "stepId": "coding-helper-base-java",
      "mentorSays": "Handle base case in helper.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-helper-recursive-java"
    },
    {
      "stepId": "coding-helper-recursive-java",
      "mentorSays": "Recursively calculate heights.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-update-diameter-java"
    },
    {
      "stepId": "coding-update-diameter-java",
      "mentorSays": "Update maximum diameter.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-return-height-java"
    },
    {
      "stepId": "coding-return-height-java",
      "mentorSays": "Return height.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-call-return-java"
    },
    {
      "stepId": "coding-call-return-java",
      "mentorSays": "Call helper and return diameter.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [1, 2, 3, 4, 5]\nExpected: 3 (path: 4->2->1->3 or 4->2->5)\n\n**Test 2:** root = [1, 2]\nExpected: 1 (path: 1->2)\n\n**Test 3:** root = [1]\nExpected: 0 (single node, no edges)\n\n**Test 4:** root = [1, 2, null, 4, 5, null, null, 6, 7]\nExpected: 4 (long path through node 2)\n\n**Test 5:** root = null\nExpected: 0 (empty tree)\n\n**Test 6:** root = [1, 2, 3, null, null, 4, 5]\nExpected: 3 (path through root)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,2,3,4,5] â†’ 3\nTest 2: [1,2] â†’ 1\nTest 3: [1] â†’ 0\nTest 4: [1,2,null,4,5,null,null,6,7] â†’ 4\nTest 5: null â†’ 0\nTest 6: [1,2,3,null,null,4,5] â†’ 3",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in C++?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-cpp"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'maxDiameter' or 'leftHeight') and put data inside it.",
      "example": "int maxDiameter = 0;  // Maximum diameter found\nint leftHeight = 0;  // Height of left subtree",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in C++?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-cpp"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "int diameterOfBinaryTree(root) {\n  // Returns diameter of tree\n  return 0;\n}",
      "action": "continue",
      "next": "parameter-check-cpp"
    },
    {
      "stepId": "parameter-check-cpp",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-cpp"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-cpp",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'int diameterOfBinaryTree(root)', the 'root' is a parameter that receives the root node.",
      "example": "int diameterOfBinaryTree(root) {\n  // Parameter receives root node\n}\n\n// Call: diameterOfBinaryTree(rootNode)",
      "action": "continue",
      "next": "tree-check-cpp"
    },
    {
      "stepId": "tree-check-cpp",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-cpp"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "tree-explanation-cpp",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-cpp"
    },
    {
      "stepId": "recursion-check-cpp",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in C++?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-cpp"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-cpp",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees",
      "example": "function height(root, maxDiameter) {\n  if (root === null) return 0;\n  \n  // Recursive calls\n  let leftHeight = height(root.left, maxDiameter);\n  let rightHeight = height(root.right, maxDiameter);\n  \n  // Update diameter\n  maxDiameter[0] = Math.max(maxDiameter[0], leftHeight + rightHeight);\n  \n  return 1 + Math.max(leftHeight, rightHeight);\n}",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Perfect! Let's implement the solution in C++.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-init-max-cpp"
    },
    {
      "stepId": "coding-init-max-cpp",
      "mentorSays": "Initialize max diameter tracker.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-helper-start-cpp"
    },
    {
      "stepId": "coding-helper-start-cpp",
      "mentorSays": "Create helper function.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-helper-base-cpp"
    },
    {
      "stepId": "coding-helper-base-cpp",
      "mentorSays": "Handle base case in helper.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-helper-recursive-cpp"
    },
    {
      "stepId": "coding-helper-recursive-cpp",
      "mentorSays": "Recursively calculate heights.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-update-diameter-cpp"
    },
    {
      "stepId": "coding-update-diameter-cpp",
      "mentorSays": "Update maximum diameter.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-return-height-cpp"
    },
    {
      "stepId": "coding-return-height-cpp",
      "mentorSays": "Return height.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-call-return-cpp"
    },
    {
      "stepId": "coding-call-return-cpp",
      "mentorSays": "Call helper and return diameter.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [1, 2, 3, 4, 5]\nExpected: 3 (path: 4->2->1->3 or 4->2->5)\n\n**Test 2:** root = [1, 2]\nExpected: 1 (path: 1->2)\n\n**Test 3:** root = [1]\nExpected: 0 (single node, no edges)\n\n**Test 4:** root = [1, 2, null, 4, 5, null, null, 6, 7]\nExpected: 4 (long path through node 2)\n\n**Test 5:** root = null\nExpected: 0 (empty tree)\n\n**Test 6:** root = [1, 2, 3, null, null, 4, 5]\nExpected: 3 (path through root)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,2,3,4,5] â†’ 3\nTest 2: [1,2] â†’ 1\nTest 3: [1] â†’ 0\nTest 4: [1,2,null,4,5,null,null,6,7] â†’ 4\nTest 5: null â†’ 0\nTest 6: [1,2,3,null,null,4,5] â†’ 3",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-ts"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-ts"
        }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'maxDiameter' or 'leftHeight') and put data inside it.",
      "example": "let maxDiameter = 0;  // Maximum diameter found\nlet leftHeight = 0;  // Height of left subtree",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-ts"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-ts"
        }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function diameterOfBinaryTree(root) {\n  // Returns diameter of tree\n  return 0;\n}",
      "action": "continue",
      "next": "parameter-check-ts"
    },
    {
      "stepId": "parameter-check-ts",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-ts"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-ts"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-ts",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function diameterOfBinaryTree(root)', the 'root' is a parameter that receives the root node.",
      "example": "function diameterOfBinaryTree(root) {\n  // Parameter receives root node\n}\n\n// Call: diameterOfBinaryTree(rootNode)",
      "action": "continue",
      "next": "tree-check-ts"
    },
    {
      "stepId": "tree-check-ts",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-ts"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-ts"
        }
      ]
    },
    {
      "stepId": "tree-explanation-ts",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-ts"
    },
    {
      "stepId": "recursion-check-ts",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-ts"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-ts"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-ts",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees",
      "example": "function height(root, maxDiameter) {\n  if (root === null) return 0;\n  \n  // Recursive calls\n  let leftHeight = height(root.left, maxDiameter);\n  let rightHeight = height(root.right, maxDiameter);\n  \n  // Update diameter\n  maxDiameter[0] = Math.max(maxDiameter[0], leftHeight + rightHeight);\n  \n  return 1 + Math.max(leftHeight, rightHeight);\n}",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Perfect! Let's implement the solution in TypeScript.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-init-max-ts"
    },
    {
      "stepId": "coding-init-max-ts",
      "mentorSays": "Initialize max diameter tracker.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-helper-start-ts"
    },
    {
      "stepId": "coding-helper-start-ts",
      "mentorSays": "Create helper function.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-helper-base-ts"
    },
    {
      "stepId": "coding-helper-base-ts",
      "mentorSays": "Handle base case in helper.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-helper-recursive-ts"
    },
    {
      "stepId": "coding-helper-recursive-ts",
      "mentorSays": "Recursively calculate heights.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-update-diameter-ts"
    },
    {
      "stepId": "coding-update-diameter-ts",
      "mentorSays": "Update maximum diameter.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-return-height-ts"
    },
    {
      "stepId": "coding-return-height-ts",
      "mentorSays": "Return height.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-call-return-ts"
    },
    {
      "stepId": "coding-call-return-ts",
      "mentorSays": "Call helper and return diameter.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [1, 2, 3, 4, 5]\nExpected: 3 (path: 4->2->1->3 or 4->2->5)\n\n**Test 2:** root = [1, 2]\nExpected: 1 (path: 1->2)\n\n**Test 3:** root = [1]\nExpected: 0 (single node, no edges)\n\n**Test 4:** root = [1, 2, null, 4, 5, null, null, 6, 7]\nExpected: 4 (long path through node 2)\n\n**Test 5:** root = null\nExpected: 0 (empty tree)\n\n**Test 6:** root = [1, 2, 3, null, null, 4, 5]\nExpected: 3 (path through root)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,2,3,4,5] â†’ 3\nTest 2: [1,2] â†’ 1\nTest 3: [1] â†’ 0\nTest 4: [1,2,null,4,5,null,null,6,7] â†’ 4\nTest 5: null â†’ 0\nTest 6: [1,2,3,null,null,4,5] â†’ 3",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "final",
      "mentorSays": "ðŸŽ‰ Well done! You've successfully implemented the Diameter of Binary Tree solution!\n\n**Time Complexity:** O(n)\n- We visit each node exactly once\n- n is the number of nodes in the tree\n\n**Space Complexity:** O(h)\n- The recursion stack uses space proportional to the height of the tree\n- In the worst case (skewed tree), h = n, so O(n)\n- In the best case (balanced tree), h = log n, so O(log n)\n\n**Key Takeaways:**\n1. **Recursive approach**: Calculate height and track diameter at each node\n2. **Diameter at node**: left height + right height (longest path through that node)\n3. **Global tracking**: Use a variable to track maximum diameter across all nodes\n4. **Height calculation**: Return height from helper (needed for parent's calculation)\n5. **May not pass through root**: Check all nodes, not just root\n\n**Related Practice Problems:**\n- Maximum Depth of Binary Tree (LeetCode #104) - find height\n- Binary Tree Maximum Path Sum (LeetCode #124) - similar pattern\n- Longest Univalue Path (LeetCode #687) - similar diameter concept\n\nKeep practicing tree problems - they're fundamental for interviews!",
      "action": "continue"
    }
  ]
}