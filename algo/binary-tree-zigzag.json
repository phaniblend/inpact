{
  "id": "binary-tree-zigzag",
  "title": "Binary Tree Zigzag Level Order Traversal",
  "pattern": "tree",
  "difficulty": "medium",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what Zigzag Level Order Traversal asks for\n2. Use BFS with direction toggle\n3. Reverse alternate levels\n4. Track level direction (left-to-right vs right-to-left)\n5. Implement the solution step by step in your chosen language",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Perfect! Now let's understand what Binary Tree Zigzag Level Order Traversal is asking.\n\n**Problem Definition:**\nGiven the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).\n\n**Key Observations:**\n- Level 0: left to right\n- Level 1: right to left\n- Level 2: left to right\n- And so on...\n- Use BFS (level-order traversal)\n- Reverse alternate levels\n\n**Example 1:** root = [3,9,20,null,null,15,7]\n\nTree:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\nZigzag traversal:\n- Level 0: [3] (left to right)\n- Level 1: [20, 9] (right to left - reversed!)\n- Level 2: [15, 7] (left to right)\n\nAnswer: [[3], [20, 9], [15, 7]]\n\n**Example 2:** root = [1]\n\nAnswer: [[1]]\n\n**Step-by-step trace (BFS with direction toggle):**\n\nTree: [3,9,20,null,null,15,7]\n\n- **Level 0**: queue=[3], leftToRight=true\n  - Process 3 → level=[3]\n  - Add children: queue=[9,20]\n  - leftToRight=true, don't reverse → result=[[3]]\n  - Toggle: leftToRight=false\n\n- **Level 1**: queue=[9,20], leftToRight=false\n  - Process 9 → level=[9]\n  - Process 20 → level=[9,20]\n  - Add children: queue=[15,7]\n  - leftToRight=false, reverse → level=[20,9]\n  - result=[[3], [20,9]]\n  - Toggle: leftToRight=true\n\n- **Level 2**: queue=[15,7], leftToRight=true\n  - Process 15 → level=[15]\n  - Process 7 → level=[15,7]\n  - No children\n  - leftToRight=true, don't reverse → result=[[3], [20,9], [15,7]]\n\n**Key Insight:**\n- Use BFS to process level by level\n- Track direction with a boolean flag\n- Reverse level array when direction is right-to-left\n- Toggle direction after each level\n- O(n) time, O(n) space\n\n**What makes this tricky:**\n1. Understanding zigzag pattern (alternate directions)\n2. Knowing when to reverse the level array\n3. Toggling direction after each level\n4. Handling edge cases (empty tree, single node)\n\n**Common pitfalls:**\n- Forgetting to reverse alternate levels\n- Not toggling direction correctly\n- Reversing in wrong direction\n- Not handling empty tree",
      "example": "Example 1:\nTree: [3,9,20,null,null,15,7]\nResult: [[3], [20,9], [15,7]]\n\nExample 2:\nTree: [1]\nResult: [[1]]\n\nExample 3:\nTree: [1,2,3]\nResult: [[1], [3,2]]",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "How would you traverse the tree in zigzag order?",
      "choices": [
        {
          "label": "Use BFS with direction toggle",
          "next": "explore-bfs"
        },
        {
          "label": "Use two stacks",
          "next": "explore-stacks"
        },
        {
          "label": "Use DFS with level tracking",
          "next": "explore-dfs"
        }
      ]
    },
    {
      "stepId": "explore-stacks",
      "mentorSays": "Two stacks work but BFS with direction toggle is simpler and more intuitive!",
      "action": "continue",
      "next": "explore-bfs"
    },
    {
      "stepId": "explore-dfs",
      "mentorSays": "DFS works but BFS is more natural for level-order traversal!",
      "action": "continue",
      "next": "explore-bfs"
    },
    {
      "stepId": "explore-bfs",
      "mentorSays": "Excellent! BFS with direction toggle is optimal. Algorithm:\n1. Use queue for BFS\n2. Track direction with boolean (leftToRight)\n3. Process each level\n4. Reverse level array if right-to-left\n5. Toggle direction after each level",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Which language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "variable-check-js"
        },
        {
          "label": "Python",
          "next": "variable-check-python"
        },
        {
          "label": "Java",
          "next": "variable-check-java"
        },
        {
          "label": "C++",
          "next": "variable-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "variable-check-ts"
        }
      ]
    },
    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-js"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-js"
        }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "let result = [];\nlet queue = [];\nlet leftToRight = true;",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Do you know what a function is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-js"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-js"
        }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code.",
      "example": "function zigzagLevelOrder(root) {}",
      "action": "continue",
      "next": "parameter-check-js"
    },
    {
      "stepId": "parameter-check-js",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-js"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-js"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-js",
      "mentorSays": "Parameters are inputs to a function.",
      "example": "",
      "action": "continue",
      "next": "tree-check-js"
    },
    {
      "stepId": "tree-check-js",
      "mentorSays": "Do you know how to work with tree?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "queue-check-js"
        },
        {
          "label": "No, explain",
          "next": "tree-explanation-js"
        }
      ]
    },
    {
      "stepId": "tree-explanation-js",
      "mentorSays": "A binary tree has nodes with left and right children. We traverse level by level using a queue.",
      "example": "root.left  // Left child\nroot.right  // Right child\nroot.val    // Node value",
      "action": "continue",
      "next": "queue-check-js"
    },
    {
      "stepId": "queue-check-js",
      "mentorSays": "Do you know what queue is?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "coding-start-js"
        },
        {
          "label": "No, explain",
          "next": "queue-explanation-js"
        }
      ]
    },
    {
      "stepId": "queue-explanation-js",
      "mentorSays": "A queue is FIFO (First In First Out). We use it for BFS to process nodes level by level.",
      "example": "let queue = [];\nqueue.push(node);  // Add to end\nlet current = queue.shift();  // Remove from front",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Implement zigzag traversal in JS.",
      "example": "function zigzagLevelOrder(root) {}",
      "action": "continue",
      "next": "coding-edge-case-js"
    },
    {
      "stepId": "coding-edge-case-js",
      "mentorSays": "Handle edge case: if root is null, return empty array.",
      "example": "function zigzagLevelOrder(root) {\n  if (!root) return [];",
      "action": "continue",
      "next": "coding-init-js"
    },
    {
      "stepId": "coding-init-js",
      "mentorSays": "Initialize result array, queue, and direction flag.",
      "example": "function zigzagLevelOrder(root) {\n  if (!root) return [];\n  let result = [];\n  let queue = [root];\n  let leftToRight = true;",
      "action": "continue",
      "next": "coding-bfs-loop-js"
    },
    {
      "stepId": "coding-bfs-loop-js",
      "mentorSays": "Start BFS loop: while queue is not empty.",
      "example": "function zigzagLevelOrder(root) {\n  if (!root) return [];\n  let result = [];\n  let queue = [root];\n  let leftToRight = true;\n  \n  while (queue.length > 0) {",
      "action": "continue",
      "next": "coding-process-level-js"
    },
    {
      "stepId": "coding-process-level-js",
      "mentorSays": "Process current level: get level size, create level array, process all nodes at this level.",
      "example": "function zigzagLevelOrder(root) {\n  if (!root) return [];\n  let result = [];\n  let queue = [root];\n  let leftToRight = true;\n  \n  while (queue.length > 0) {\n    let levelSize = queue.length;\n    let level = [];\n    \n    for (let i = 0; i < levelSize; i++) {\n      let node = queue.shift();\n      level.push(node.val);\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }",
      "action": "continue",
      "next": "coding-reverse-js"
    },
    {
      "stepId": "coding-reverse-js",
      "mentorSays": "If direction is right-to-left, reverse the level array.",
      "example": "function zigzagLevelOrder(root) {\n  if (!root) return [];\n  let result = [];\n  let queue = [root];\n  let leftToRight = true;\n  \n  while (queue.length > 0) {\n    let levelSize = queue.length;\n    let level = [];\n    \n    for (let i = 0; i < levelSize; i++) {\n      let node = queue.shift();\n      level.push(node.val);\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    \n    if (!leftToRight) level.reverse();",
      "action": "continue",
      "next": "coding-return-js"
    },
    {
      "stepId": "coding-return-js",
      "mentorSays": "Add level to result, toggle direction, and return result.",
      "example": "function zigzagLevelOrder(root) {\n  if (!root) return [];\n  let result = [];\n  let queue = [root];\n  let leftToRight = true;\n  \n  while (queue.length > 0) {\n    let levelSize = queue.length;\n    let level = [];\n    \n    for (let i = 0; i < levelSize; i++) {\n      let node = queue.shift();\n      level.push(node.val);\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    \n    if (!leftToRight) level.reverse();\n    result.push(level);\n    leftToRight = !leftToRight;\n  }\n  \n  return result;\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Test cases:\n1. root=[3,9,20,null,null,15,7] → [[3],[20,9],[15,7]]\n2. root=[1] → [[1]]\n3. root=[1,2,3] → [[1],[3,2]]\n4. root=[1,2,null,3] → [[1],[2],[3]]\n5. root=[] → []\n6. root=[1,2,3,4,5,6,7] → [[1],[3,2],[4,5,6,7]]",
      "example": "",
      "action": "continue",
      "next": "variable-check-python"
    },
    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Python?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-python"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-python"
        }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "result = []\nqueue = []\nleft_to_right = True",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Do you know what a function is in Python?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-python"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-python"
        }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function is a reusable block of code.",
      "example": "def zigzagLevelOrder(root):",
      "action": "continue",
      "next": "parameter-check-python"
    },
    {
      "stepId": "parameter-check-python",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-python"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-python"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-python",
      "mentorSays": "Parameters are inputs to a function.",
      "example": "",
      "action": "continue",
      "next": "tree-check-python"
    },
    {
      "stepId": "tree-check-python",
      "mentorSays": "Do you know how to work with tree?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "queue-check-python"
        },
        {
          "label": "No, explain",
          "next": "tree-explanation-python"
        }
      ]
    },
    {
      "stepId": "tree-explanation-python",
      "mentorSays": "A binary tree has nodes with left and right children. We traverse level by level using a queue.",
      "example": "root.left  # Left child\nroot.right  # Right child\nroot.val    # Node value",
      "action": "continue",
      "next": "queue-check-python"
    },
    {
      "stepId": "queue-check-python",
      "mentorSays": "Do you know what queue is?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "coding-start-python"
        },
        {
          "label": "No, explain",
          "next": "queue-explanation-python"
        }
      ]
    },
    {
      "stepId": "queue-explanation-python",
      "mentorSays": "A queue is FIFO (First In First Out). We use it for BFS to process nodes level by level.",
      "example": "from collections import deque\nqueue = deque()\nqueue.append(node)  # Add to end\ncurrent = queue.popleft()  # Remove from front",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Implement zigzag traversal in PYTHON.",
      "example": "def zigzagLevelOrder(root):",
      "action": "continue",
      "next": "coding-edge-case-python"
    },
    {
      "stepId": "coding-edge-case-python",
      "mentorSays": "Handle edge case: if root is null, return empty array.",
      "example": "def zigzagLevelOrder(root):\n    if not root:\n        return []",
      "action": "continue",
      "next": "coding-init-python"
    },
    {
      "stepId": "coding-init-python",
      "mentorSays": "Initialize result array, queue, and direction flag.",
      "example": "def zigzagLevelOrder(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    left_to_right = True",
      "action": "continue",
      "next": "coding-bfs-loop-python"
    },
    {
      "stepId": "coding-bfs-loop-python",
      "mentorSays": "Start BFS loop: while queue is not empty.",
      "example": "def zigzagLevelOrder(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    left_to_right = True\n    \n    while queue:",
      "action": "continue",
      "next": "coding-process-level-python"
    },
    {
      "stepId": "coding-process-level-python",
      "mentorSays": "Process current level: get level size, create level array, process all nodes at this level.",
      "example": "def zigzagLevelOrder(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    left_to_right = True\n    \n    while queue:\n        level_size = len(queue)\n        level = []\n        \n        for i in range(level_size):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)",
      "action": "continue",
      "next": "coding-reverse-python"
    },
    {
      "stepId": "coding-reverse-python",
      "mentorSays": "If direction is right-to-left, reverse the level array.",
      "example": "def zigzagLevelOrder(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    left_to_right = True\n    \n    while queue:\n        level_size = len(queue)\n        level = []\n        \n        for i in range(level_size):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        if not left_to_right:\n            level.reverse()",
      "action": "continue",
      "next": "coding-return-python"
    },
    {
      "stepId": "coding-return-python",
      "mentorSays": "Add level to result, toggle direction, and return result.",
      "example": "def zigzagLevelOrder(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    left_to_right = True\n    \n    while queue:\n        level_size = len(queue)\n        level = []\n        \n        for i in range(level_size):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        if not left_to_right:\n            level.reverse()\n        result.append(level)\n        left_to_right = not left_to_right\n    \n    return result",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Test cases:\n1. root=[3,9,20,null,null,15,7] → [[3],[20,9],[15,7]]\n2. root=[1] → [[1]]\n3. root=[1,2,3] → [[1],[3,2]]\n4. root=[1,2,null,3] → [[1],[2],[3]]\n5. root=[] → []\n6. root=[1,2,3,4,5,6,7] → [[1],[3,2],[4,5,6,7]]",
      "example": "",
      "action": "continue",
      "next": "variable-check-java"
    },
    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Java?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-java"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-java"
        }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "List<List<Integer>> result = new ArrayList<>();\nQueue<TreeNode> queue = new LinkedList<>();\nboolean leftToRight = true;",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Do you know what a function is in Java?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-java"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-java"
        }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A function is a reusable block of code.",
      "example": "public List<List<Integer>> zigzagLevelOrder(TreeNode root) {}",
      "action": "continue",
      "next": "parameter-check-java"
    },
    {
      "stepId": "parameter-check-java",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-java"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-java"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-java",
      "mentorSays": "Parameters are inputs to a function.",
      "example": "",
      "action": "continue",
      "next": "tree-check-java"
    },
    {
      "stepId": "tree-check-java",
      "mentorSays": "Do you know how to work with tree?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "queue-check-java"
        },
        {
          "label": "No, explain",
          "next": "tree-explanation-java"
        }
      ]
    },
    {
      "stepId": "tree-explanation-java",
      "mentorSays": "A binary tree has nodes with left and right children. We traverse level by level using a queue.",
      "example": "root.left  // Left child\nroot.right  // Right child\nroot.val    // Node value",
      "action": "continue",
      "next": "queue-check-java"
    },
    {
      "stepId": "queue-check-java",
      "mentorSays": "Do you know what queue is?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "coding-start-java"
        },
        {
          "label": "No, explain",
          "next": "queue-explanation-java"
        }
      ]
    },
    {
      "stepId": "queue-explanation-java",
      "mentorSays": "A queue is FIFO (First In First Out). We use it for BFS to process nodes level by level.",
      "example": "Queue<TreeNode> queue = new LinkedList<>();\nqueue.offer(node);  // Add to end\nTreeNode current = queue.poll();  // Remove from front",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Implement zigzag traversal in JAVA.",
      "example": "public List<List<Integer>> zigzagLevelOrder(TreeNode root) {}",
      "action": "continue",
      "next": "coding-edge-case-java"
    },
    {
      "stepId": "coding-edge-case-java",
      "mentorSays": "Handle edge case: if root is null, return empty array.",
      "example": "public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    if (root == null) return new ArrayList<>();",
      "action": "continue",
      "next": "coding-init-java"
    },
    {
      "stepId": "coding-init-java",
      "mentorSays": "Initialize result array, queue, and direction flag.",
      "example": "public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    if (root == null) return new ArrayList<>();\n    List<List<Integer>> result = new ArrayList<>();\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    boolean leftToRight = true;",
      "action": "continue",
      "next": "coding-bfs-loop-java"
    },
    {
      "stepId": "coding-bfs-loop-java",
      "mentorSays": "Start BFS loop: while queue is not empty.",
      "example": "public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    if (root == null) return new ArrayList<>();\n    List<List<Integer>> result = new ArrayList<>();\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    boolean leftToRight = true;\n    \n    while (!queue.isEmpty()) {",
      "action": "continue",
      "next": "coding-process-level-java"
    },
    {
      "stepId": "coding-process-level-java",
      "mentorSays": "Process current level: get level size, create level array, process all nodes at this level.",
      "example": "public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    if (root == null) return new ArrayList<>();\n    List<List<Integer>> result = new ArrayList<>();\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    boolean leftToRight = true;\n    \n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        List<Integer> level = new ArrayList<>();\n        \n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n            level.add(node.val);\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }",
      "action": "continue",
      "next": "coding-reverse-java"
    },
    {
      "stepId": "coding-reverse-java",
      "mentorSays": "If direction is right-to-left, reverse the level array.",
      "example": "public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    if (root == null) return new ArrayList<>();\n    List<List<Integer>> result = new ArrayList<>();\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    boolean leftToRight = true;\n    \n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        List<Integer> level = new ArrayList<>();\n        \n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n            level.add(node.val);\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n        \n        if (!leftToRight) Collections.reverse(level);",
      "action": "continue",
      "next": "coding-return-java"
    },
    {
      "stepId": "coding-return-java",
      "mentorSays": "Add level to result, toggle direction, and return result.",
      "example": "public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    if (root == null) return new ArrayList<>();\n    List<List<Integer>> result = new ArrayList<>();\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    boolean leftToRight = true;\n    \n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        List<Integer> level = new ArrayList<>();\n        \n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n            level.add(node.val);\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n        \n        if (!leftToRight) Collections.reverse(level);\n        result.add(level);\n        leftToRight = !leftToRight;\n    }\n    \n    return result;\n}",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Test cases:\n1. root=[3,9,20,null,null,15,7] → [[3],[20,9],[15,7]]\n2. root=[1] → [[1]]\n3. root=[1,2,3] → [[1],[3,2]]\n4. root=[1,2,null,3] → [[1],[2],[3]]\n5. root=[] → []\n6. root=[1,2,3,4,5,6,7] → [[1],[3,2],[4,5,6,7]]",
      "example": "",
      "action": "continue",
      "next": "variable-check-cpp"
    },
    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in C++?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-cpp"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "vector<vector<int>> result;\nqueue<TreeNode*> q;\nbool leftToRight = true;",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Do you know what a function is in C++?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-cpp"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function is a reusable block of code.",
      "example": "vector<vector<int>> zigzagLevelOrder(TreeNode* root) {}",
      "action": "continue",
      "next": "parameter-check-cpp"
    },
    {
      "stepId": "parameter-check-cpp",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-cpp"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-cpp",
      "mentorSays": "Parameters are inputs to a function.",
      "example": "",
      "action": "continue",
      "next": "tree-check-cpp"
    },
    {
      "stepId": "tree-check-cpp",
      "mentorSays": "Do you know how to work with tree?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "queue-check-cpp"
        },
        {
          "label": "No, explain",
          "next": "tree-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "tree-explanation-cpp",
      "mentorSays": "A binary tree has nodes with left and right children. We traverse level by level using a queue.",
      "example": "root->left  // Left child\nroot->right  // Right child\nroot->val    // Node value",
      "action": "continue",
      "next": "queue-check-cpp"
    },
    {
      "stepId": "queue-check-cpp",
      "mentorSays": "Do you know what queue is?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "coding-start-cpp"
        },
        {
          "label": "No, explain",
          "next": "queue-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "queue-explanation-cpp",
      "mentorSays": "A queue is FIFO (First In First Out). We use it for BFS to process nodes level by level.",
      "example": "queue<TreeNode*> q;\nq.push(node);  // Add to end\nTreeNode* current = q.front(); q.pop();  // Remove from front",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Implement zigzag traversal in CPP.",
      "example": "vector<vector<int>> zigzagLevelOrder(TreeNode* root) {}",
      "action": "continue",
      "next": "coding-edge-case-cpp"
    },
    {
      "stepId": "coding-edge-case-cpp",
      "mentorSays": "Handle edge case: if root is null, return empty array.",
      "example": "vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n    if (!root) return {};",
      "action": "continue",
      "next": "coding-init-cpp"
    },
    {
      "stepId": "coding-init-cpp",
      "mentorSays": "Initialize result array, queue, and direction flag.",
      "example": "vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n    if (!root) return {};\n    vector<vector<int>> result;\n    queue<TreeNode*> q;\n    q.push(root);\n    bool leftToRight = true;",
      "action": "continue",
      "next": "coding-bfs-loop-cpp"
    },
    {
      "stepId": "coding-bfs-loop-cpp",
      "mentorSays": "Start BFS loop: while queue is not empty.",
      "example": "vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n    if (!root) return {};\n    vector<vector<int>> result;\n    queue<TreeNode*> q;\n    q.push(root);\n    bool leftToRight = true;\n    \n    while (!q.empty()) {",
      "action": "continue",
      "next": "coding-process-level-cpp"
    },
    {
      "stepId": "coding-process-level-cpp",
      "mentorSays": "Process current level: get level size, create level array, process all nodes at this level.",
      "example": "vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n    if (!root) return {};\n    vector<vector<int>> result;\n    queue<TreeNode*> q;\n    q.push(root);\n    bool leftToRight = true;\n    \n    while (!q.empty()) {\n        int levelSize = q.size();\n        vector<int> level;\n        \n        for (int i = 0; i < levelSize; i++) {\n            TreeNode* node = q.front();\n            q.pop();\n            level.push_back(node->val);\n            if (node->left) q.push(node->left);\n            if (node->right) q.push(node->right);\n        }",
      "action": "continue",
      "next": "coding-reverse-cpp"
    },
    {
      "stepId": "coding-reverse-cpp",
      "mentorSays": "If direction is right-to-left, reverse the level array.",
      "example": "vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n    if (!root) return {};\n    vector<vector<int>> result;\n    queue<TreeNode*> q;\n    q.push(root);\n    bool leftToRight = true;\n    \n    while (!q.empty()) {\n        int levelSize = q.size();\n        vector<int> level;\n        \n        for (int i = 0; i < levelSize; i++) {\n            TreeNode* node = q.front();\n            q.pop();\n            level.push_back(node->val);\n            if (node->left) q.push(node->left);\n            if (node->right) q.push(node->right);\n        }\n        \n        if (!leftToRight) reverse(level.begin(), level.end());",
      "action": "continue",
      "next": "coding-return-cpp"
    },
    {
      "stepId": "coding-return-cpp",
      "mentorSays": "Add level to result, toggle direction, and return result.",
      "example": "vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n    if (!root) return {};\n    vector<vector<int>> result;\n    queue<TreeNode*> q;\n    q.push(root);\n    bool leftToRight = true;\n    \n    while (!q.empty()) {\n        int levelSize = q.size();\n        vector<int> level;\n        \n        for (int i = 0; i < levelSize; i++) {\n            TreeNode* node = q.front();\n            q.pop();\n            level.push_back(node->val);\n            if (node->left) q.push(node->left);\n            if (node->right) q.push(node->right);\n        }\n        \n        if (!leftToRight) reverse(level.begin(), level.end());\n        result.push_back(level);\n        leftToRight = !leftToRight;\n    }\n    \n    return result;\n}",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Test cases:\n1. root=[3,9,20,null,null,15,7] → [[3],[20,9],[15,7]]\n2. root=[1] → [[1]]\n3. root=[1,2,3] → [[1],[3,2]]\n4. root=[1,2,null,3] → [[1],[2],[3]]\n5. root=[] → []\n6. root=[1,2,3,4,5,6,7] → [[1],[3,2],[4,5,6,7]]",
      "example": "",
      "action": "continue",
      "next": "variable-check-ts"
    },
    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-ts"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-ts"
        }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "let result: number[][] = [];\nlet queue: (TreeNode | null)[] = [];\nlet leftToRight: boolean = true;",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Do you know what a function is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-ts"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-ts"
        }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function is a reusable block of code.",
      "example": "function zigzagLevelOrder(root: TreeNode | null): number[][] {}",
      "action": "continue",
      "next": "parameter-check-ts"
    },
    {
      "stepId": "parameter-check-ts",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-ts"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-ts"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-ts",
      "mentorSays": "Parameters are inputs to a function.",
      "example": "",
      "action": "continue",
      "next": "tree-check-ts"
    },
    {
      "stepId": "tree-check-ts",
      "mentorSays": "Do you know how to work with tree?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "queue-check-ts"
        },
        {
          "label": "No, explain",
          "next": "tree-explanation-ts"
        }
      ]
    },
    {
      "stepId": "tree-explanation-ts",
      "mentorSays": "A binary tree has nodes with left and right children. We traverse level by level using a queue.",
      "example": "root.left  // Left child\nroot.right  // Right child\nroot.val    // Node value",
      "action": "continue",
      "next": "queue-check-ts"
    },
    {
      "stepId": "queue-check-ts",
      "mentorSays": "Do you know what queue is?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "coding-start-ts"
        },
        {
          "label": "No, explain",
          "next": "queue-explanation-ts"
        }
      ]
    },
    {
      "stepId": "queue-explanation-ts",
      "mentorSays": "A queue is FIFO (First In First Out). We use it for BFS to process nodes level by level.",
      "example": "let queue: (TreeNode | null)[] = [];\nqueue.push(node);  // Add to end\nlet current = queue.shift();  // Remove from front",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Implement zigzag traversal in TS.",
      "example": "function zigzagLevelOrder(root: TreeNode | null): number[][] {}",
      "action": "continue",
      "next": "coding-edge-case-ts"
    },
    {
      "stepId": "coding-edge-case-ts",
      "mentorSays": "Handle edge case: if root is null, return empty array.",
      "example": "function zigzagLevelOrder(root: TreeNode | null): number[][] {\n    if (!root) return [];",
      "action": "continue",
      "next": "coding-init-ts"
    },
    {
      "stepId": "coding-init-ts",
      "mentorSays": "Initialize result array, queue, and direction flag.",
      "example": "function zigzagLevelOrder(root: TreeNode | null): number[][] {\n    if (!root) return [];\n    let result: number[][] = [];\n    let queue: (TreeNode | null)[] = [root];\n    let leftToRight: boolean = true;",
      "action": "continue",
      "next": "coding-bfs-loop-ts"
    },
    {
      "stepId": "coding-bfs-loop-ts",
      "mentorSays": "Start BFS loop: while queue is not empty.",
      "example": "function zigzagLevelOrder(root: TreeNode | null): number[][] {\n    if (!root) return [];\n    let result: number[][] = [];\n    let queue: (TreeNode | null)[] = [root];\n    let leftToRight: boolean = true;\n    \n    while (queue.length > 0) {",
      "action": "continue",
      "next": "coding-process-level-ts"
    },
    {
      "stepId": "coding-process-level-ts",
      "mentorSays": "Process current level: get level size, create level array, process all nodes at this level.",
      "example": "function zigzagLevelOrder(root: TreeNode | null): number[][] {\n    if (!root) return [];\n    let result: number[][] = [];\n    let queue: (TreeNode | null)[] = [root];\n    let leftToRight: boolean = true;\n    \n    while (queue.length > 0) {\n        let levelSize = queue.length;\n        let level: number[] = [];\n        \n        for (let i = 0; i < levelSize; i++) {\n            let node = queue.shift()!;\n            level.push(node.val);\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }",
      "action": "continue",
      "next": "coding-reverse-ts"
    },
    {
      "stepId": "coding-reverse-ts",
      "mentorSays": "If direction is right-to-left, reverse the level array.",
      "example": "function zigzagLevelOrder(root: TreeNode | null): number[][] {\n    if (!root) return [];\n    let result: number[][] = [];\n    let queue: (TreeNode | null)[] = [root];\n    let leftToRight: boolean = true;\n    \n    while (queue.length > 0) {\n        let levelSize = queue.length;\n        let level: number[] = [];\n        \n        for (let i = 0; i < levelSize; i++) {\n            let node = queue.shift()!;\n            level.push(node.val);\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n        \n        if (!leftToRight) level.reverse();",
      "action": "continue",
      "next": "coding-return-ts"
    },
    {
      "stepId": "coding-return-ts",
      "mentorSays": "Add level to result, toggle direction, and return result.",
      "example": "function zigzagLevelOrder(root: TreeNode | null): number[][] {\n    if (!root) return [];\n    let result: number[][] = [];\n    let queue: (TreeNode | null)[] = [root];\n    let leftToRight: boolean = true;\n    \n    while (queue.length > 0) {\n        let levelSize = queue.length;\n        let level: number[] = [];\n        \n        for (let i = 0; i < levelSize; i++) {\n            let node = queue.shift()!;\n            level.push(node.val);\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n        \n        if (!leftToRight) level.reverse();\n        result.push(level);\n        leftToRight = !leftToRight;\n    }\n    \n    return result;\n}",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Test cases:\n1. root=[3,9,20,null,null,15,7] → [[3],[20,9],[15,7]]\n2. root=[1] → [[1]]\n3. root=[1,2,3] → [[1],[3,2]]\n4. root=[1,2,null,3] → [[1],[2],[3]]\n5. root=[] → []\n6. root=[1,2,3,4,5,6,7] → [[1],[3,2],[4,5,6,7]]",
      "example": "",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "final",
      "mentorSays": "Time: O(n), Space: O(n). BFS with direction toggle efficiently creates zigzag traversal.\n\nRelated Problems:\n- Binary Tree Level Order Traversal\n- Binary Tree Level Order Traversal II\n- N-ary Tree Level Order Traversal",
      "action": "continue"
    }
  ]
}