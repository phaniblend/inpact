{
  "id": "binary-tree-level-order",
  "title": "Binary Tree Level Order Traversal",
  "pattern": "tree",
  "difficulty": "medium",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what level-order (BFS) traversal means\n2. Use a queue to traverse the tree level by level\n3. Process nodes at each level before moving to the next\n4. Handle base cases (empty tree)\n5. Implement the solution step by step in your chosen language",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Perfect! Now let's understand what Binary Tree Level Order Traversal means.\n\n**Problem Definition:**\nGiven the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\n\n**Key Observations:**\n- Level-order traversal visits nodes level by level (BFS)\n- Level 0: root\n- Level 1: root's children\n- Level 2: children's children, etc.\n- We use a queue to process nodes level by level\n- Result is a 2D array: each inner array represents one level\n\n**Example 1:**\nTree:\n    3\n   / \\\n  9   20\n     /  \\\n    15   7\n\nLevel-order traversal:\nLevel 0: [3]\nLevel 1: [9, 20]\nLevel 2: [15, 7]\n\nResult: [[3], [9, 20], [15, 7]]\n\n**Example 2:**\nTree:\n    1\n\nLevel-order traversal:\nLevel 0: [1]\n\nResult: [[1]]\n\n**Example 3:**\nTree: null (empty tree)\n\nResult: []\n\n**Step-by-step trace for Example 1 (BFS/Queue approach):**\n\nTree:\n    3\n   / \\\n  9   20\n     /  \\\n    15   7\n\nWe'll use a queue:\n- **Initial**: queue = [3], result = []\n- **Level 0**: Process queue (size = 1)\n  - Dequeue 3, add to level: [3]\n  - Enqueue children: queue = [9, 20]\n  - Add level to result: [[3]]\n- **Level 1**: Process queue (size = 2)\n  - Dequeue 9, add to level: [9]\n  - Dequeue 20, add to level: [9, 20]\n  - Enqueue children: queue = [15, 7]\n  - Add level to result: [[3], [9, 20]]\n- **Level 2**: Process queue (size = 2)\n  - Dequeue 15, add to level: [15]\n  - Dequeue 7, add to level: [15, 7]\n  - No children to enqueue\n  - Add level to result: [[3], [9, 20], [15, 7]]\n- **Queue empty**: Done! âœ“\n\n**Key Insight:**\nWe use a queue to process nodes level by level. At each level, we:\n1. Process all nodes currently in the queue (that's one level)\n2. Add their children to the queue (for the next level)\n3. Add the level's values to the result\n\n**What makes this tricky:**\n1. Understanding BFS vs DFS\n2. Using a queue correctly\n3. Processing one level at a time (not all nodes at once)\n4. Building the 2D result array correctly\n\n**Common pitfalls:**\n- Not processing one level at a time\n- Forgetting to track level boundaries\n- Not handling empty tree\n- Adding nodes incorrectly to result",
      "example": "Example 1:\n    3\n   / \\\n  9   20\n     /  \\\n    15   7\n\nResult: [[3], [9, 20], [15, 7]]\n\nExample 2:\n    1\n\nResult: [[1]]",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Now that you understand what level-order traversal means, here's the real question:\n\nHow would YOU traverse a binary tree level by level?\n\nThink about it for a moment. What approach feels natural to you?",
      "choices": [
        {
          "label": "Use BFS with a queue - process nodes level by level",
          "next": "explore-bfs"
        },
        {
          "label": "Use recursion with depth tracking",
          "next": "explore-recursive"
        },
        {
          "label": "Use DFS and group by depth",
          "next": "explore-dfs"
        }
      ]
    },
    {
      "stepId": "explore-recursive",
      "mentorSays": "That's a good approach! You're thinking: \"I'll use recursion and track the depth, then group nodes by depth.\"\n\nThis works! However, it's more complex than the BFS approach.\n\nThere's a simpler iterative BFS approach using a queue. Would you like to learn that?",
      "action": "continue",
      "next": "explore-bfs"
    },
    {
      "stepId": "explore-dfs",
      "mentorSays": "That's a creative approach! You're thinking: \"I'll use DFS and group nodes by their depth.\"\n\nThis works, but BFS is more natural for level-order traversal since it visits nodes level by level.\n\nThere's a simpler BFS approach using a queue. Would you like to learn that?",
      "action": "continue",
      "next": "explore-bfs"
    },
    {
      "stepId": "explore-bfs",
      "mentorSays": "Excellent choice! BFS with a queue is perfect for level-order traversal. Here's the core idea:\n\n**The Algorithm:**\n1. **Initialize**: queue = [root], result = []\n2. **While queue is not empty**:\n   - Get current level size (number of nodes at this level)\n   - Create a level array\n   - Process all nodes at current level:\n     - Dequeue node\n     - Add node.val to level array\n     - Enqueue node's children (if they exist)\n   - Add level array to result\n3. **Return result**\n\n**Why it works**:\n- Queue ensures we process nodes level by level (FIFO)\n- We process all nodes at current level before moving to next\n- Children are added to queue for next level\n\n**Key insight**: The queue naturally maintains level order! We just need to process one level's worth of nodes at a time.\n\nLet's trace with tree:\n    3\n   / \\\n  9   20\n\n- **Initial**: queue = [3], result = []\n- **Level 0**:\n  - Level size = 1\n  - Dequeue 3, level = [3]\n  - Enqueue 9, 20: queue = [9, 20]\n  - Result = [[3]]\n- **Level 1**:\n  - Level size = 2\n  - Dequeue 9, level = [9]\n  - Dequeue 20, level = [9, 20]\n  - No children\n  - Result = [[3], [9, 20]]\n- **Done**: queue empty âœ“\n\nThis is O(n) time and O(n) space! Now let's code it step by step.",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Great! Now let's code this solution. Which programming language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "variable-check-js"
        },
        {
          "label": "Python",
          "next": "variable-check-python"
        },
        {
          "label": "Java",
          "next": "variable-check-java"
        },
        {
          "label": "C++",
          "next": "variable-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "variable-check-ts"
        }
      ]
    },
    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-js"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-js"
        }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "let queue = [];  // Queue for BFS",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Do you know what a function is in JavaScript?",
      "choices": [
        {
          "label": "Yes",
          "next": "parameter-check-js"
        },
        {
          "label": "No",
          "next": "function-explanation-js"
        }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code.",
      "action": "continue",
      "next": "parameter-check-js"
    },
    {
      "stepId": "parameter-check-js",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes",
          "next": "queue-check-js"
        },
        {
          "label": "No",
          "next": "parameter-explanation-js"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-js",
      "mentorSays": "Parameters are inputs to a function.",
      "action": "continue",
      "next": "queue-check-js"
    },
    {
      "stepId": "queue-check-js",
      "mentorSays": "To solve this, we'll use a queue. Do you know what a queue is?",
      "choices": [
        {
          "label": "Yes",
          "next": "coding-start-js"
        },
        {
          "label": "No",
          "next": "queue-explanation-js"
        }
      ]
    },
    {
      "stepId": "queue-explanation-js",
      "mentorSays": "A queue is FIFO (First In First Out). We add to the back, remove from the front.",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Perfect! Let's implement level-order traversal in JavaScript.",
      "example": "function levelOrder(root) {\n  \n}",
      "action": "continue",
      "next": "coding-init-js"
    },
    {
      "stepId": "coding-init-js",
      "mentorSays": "Initialize queue with root and result array.",
      "example": "function levelOrder(root) {\n  if (!root) return [];\n  \n  const queue = [root];\n  const result = [];\n  \n}",
      "action": "continue",
      "next": "coding-while-loop-js"
    },
    {
      "stepId": "coding-while-loop-js",
      "mentorSays": "Create a while loop that continues while queue is not empty.",
      "example": "function levelOrder(root) {\n  if (!root) return [];\n  \n  const queue = [root];\n  const result = [];\n  \n  while (queue.length > 0) {\n    // Process one level\n  }\n  \n}",
      "action": "continue",
      "next": "coding-level-size-js"
    },
    {
      "stepId": "coding-level-size-js",
      "mentorSays": "Get the current level size (number of nodes at this level).",
      "example": "function levelOrder(root) {\n  if (!root) return [];\n  \n  const queue = [root];\n  const result = [];\n  \n  while (queue.length > 0) {\n    const levelSize = queue.length;  // Nodes at current level\n    const level = [];\n    \n  }\n  \n}",
      "action": "continue",
      "next": "coding-process-level-js"
    },
    {
      "stepId": "coding-process-level-js",
      "mentorSays": "Process all nodes at current level: dequeue, add to level, enqueue children.",
      "example": "function levelOrder(root) {\n  if (!root) return [];\n  \n  const queue = [root];\n  const result = [];\n  \n  while (queue.length > 0) {\n    const levelSize = queue.length;\n    const level = [];\n    \n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift();  // Dequeue\n      level.push(node.val);\n      \n      if (node.left) queue.push(node.left);   // Enqueue left child\n      if (node.right) queue.push(node.right); // Enqueue right child\n    }\n    \n  }\n  \n}",
      "action": "continue",
      "next": "coding-add-level-js"
    },
    {
      "stepId": "coding-add-level-js",
      "mentorSays": "Add the level array to result.",
      "example": "function levelOrder(root) {\n  if (!root) return [];\n  \n  const queue = [root];\n  const result = [];\n  \n  while (queue.length > 0) {\n    const levelSize = queue.length;\n    const level = [];\n    \n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift();\n      level.push(node.val);\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    \n    result.push(level);  // Add level to result\n  }\n  \n}",
      "action": "continue",
      "next": "coding-return-js"
    },
    {
      "stepId": "coding-return-js",
      "mentorSays": "Return the result array.",
      "example": "function levelOrder(root) {\n  if (!root) return [];\n  \n  const queue = [root];\n  const result = [];\n  \n  while (queue.length > 0) {\n    const levelSize = queue.length;\n    const level = [];\n    \n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift();\n      level.push(node.val);\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    \n    result.push(level);\n  }\n  \n  return result;\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [3,9,20,null,null,15,7]\nExpected: [[3], [9, 20], [15, 7]]\n\n**Test 2:** root = [1]\nExpected: [[1]]\n\n**Test 3:** root = []\nExpected: []\n\n**Test 4:** root = [1,2,3,4,5]\nExpected: [[1], [2, 3], [4, 5]]\n\n**Test 5:** root = [1,2,null,3]\nExpected: [[1], [2], [3]]\n\n**Test 6:** root = [1,null,2,null,3]\nExpected: [[1], [2], [3]]\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [3,9,20,null,null,15,7] â†’ [[3], [9, 20], [15, 7]]\nTest 2: [1] â†’ [[1]]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Python?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-python"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-python"
        }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": " queue = [];  // Queue for BFS",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Do you know what a function is in Python?",
      "choices": [
        {
          "label": "Yes",
          "next": "parameter-check-python"
        },
        {
          "label": "No",
          "next": "function-explanation-python"
        }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function is a reusable block of code.",
      "action": "continue",
      "next": "parameter-check-python"
    },
    {
      "stepId": "parameter-check-python",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes",
          "next": "queue-check-python"
        },
        {
          "label": "No",
          "next": "parameter-explanation-python"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-python",
      "mentorSays": "Parameters are inputs to a function.",
      "action": "continue",
      "next": "queue-check-python"
    },
    {
      "stepId": "queue-check-python",
      "mentorSays": "To solve this, we'll use a queue. Do you know what a queue is?",
      "choices": [
        {
          "label": "Yes",
          "next": "coding-start-python"
        },
        {
          "label": "No",
          "next": "queue-explanation-python"
        }
      ]
    },
    {
      "stepId": "queue-explanation-python",
      "mentorSays": "A queue is FIFO (First In First Out). We add to the back, remove from the front.",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Perfect! Let's implement the solution in Python.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-init-python"
    },
    {
      "stepId": "coding-init-python",
      "mentorSays": "Initialize queue and result.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-while-loop-python"
    },
    {
      "stepId": "coding-while-loop-python",
      "mentorSays": "Create while loop for BFS.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-level-size-python"
    },
    {
      "stepId": "coding-level-size-python",
      "mentorSays": "Get level size.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-process-level-python"
    },
    {
      "stepId": "coding-process-level-python",
      "mentorSays": "Process all nodes at current level.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-add-level-python"
    },
    {
      "stepId": "coding-add-level-python",
      "mentorSays": "Add level to result.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-return-python"
    },
    {
      "stepId": "coding-return-python",
      "mentorSays": "Return result.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [3,9,20,null,null,15,7]\nExpected: [[3], [9, 20], [15, 7]]\n\n**Test 2:** root = [1]\nExpected: [[1]]\n\n**Test 3:** root = []\nExpected: []\n\n**Test 4:** root = [1,2,3,4,5]\nExpected: [[1], [2, 3], [4, 5]]\n\n**Test 5:** root = [1,2,null,3]\nExpected: [[1], [2], [3]]\n\n**Test 6:** root = [1,null,2,null,3]\nExpected: [[1], [2], [3]]\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [3,9,20,null,null,15,7] â†’ [[3], [9, 20], [15, 7]]\nTest 2: [1] â†’ [[1]]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Java?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-java"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-java"
        }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "List<List<Integer>> queue = [];  // Queue for BFS",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Do you know what a function is in Java?",
      "choices": [
        {
          "label": "Yes",
          "next": "parameter-check-java"
        },
        {
          "label": "No",
          "next": "function-explanation-java"
        }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A function is a reusable block of code.",
      "action": "continue",
      "next": "parameter-check-java"
    },
    {
      "stepId": "parameter-check-java",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes",
          "next": "queue-check-java"
        },
        {
          "label": "No",
          "next": "parameter-explanation-java"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-java",
      "mentorSays": "Parameters are inputs to a function.",
      "action": "continue",
      "next": "queue-check-java"
    },
    {
      "stepId": "queue-check-java",
      "mentorSays": "To solve this, we'll use a queue. Do you know what a queue is?",
      "choices": [
        {
          "label": "Yes",
          "next": "coding-start-java"
        },
        {
          "label": "No",
          "next": "queue-explanation-java"
        }
      ]
    },
    {
      "stepId": "queue-explanation-java",
      "mentorSays": "A queue is FIFO (First In First Out). We add to the back, remove from the front.",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Perfect! Let's implement the solution in Java.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-init-java"
    },
    {
      "stepId": "coding-init-java",
      "mentorSays": "Initialize queue and result.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-while-loop-java"
    },
    {
      "stepId": "coding-while-loop-java",
      "mentorSays": "Create while loop for BFS.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-level-size-java"
    },
    {
      "stepId": "coding-level-size-java",
      "mentorSays": "Get level size.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-process-level-java"
    },
    {
      "stepId": "coding-process-level-java",
      "mentorSays": "Process all nodes at current level.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-add-level-java"
    },
    {
      "stepId": "coding-add-level-java",
      "mentorSays": "Add level to result.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-return-java"
    },
    {
      "stepId": "coding-return-java",
      "mentorSays": "Return result.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [3,9,20,null,null,15,7]\nExpected: [[3], [9, 20], [15, 7]]\n\n**Test 2:** root = [1]\nExpected: [[1]]\n\n**Test 3:** root = []\nExpected: []\n\n**Test 4:** root = [1,2,3,4,5]\nExpected: [[1], [2, 3], [4, 5]]\n\n**Test 5:** root = [1,2,null,3]\nExpected: [[1], [2], [3]]\n\n**Test 6:** root = [1,null,2,null,3]\nExpected: [[1], [2], [3]]\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [3,9,20,null,null,15,7] â†’ [[3], [9, 20], [15, 7]]\nTest 2: [1] â†’ [[1]]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in C++?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-cpp"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "vector<vector<int>> queue = [];  // Queue for BFS",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Do you know what a function is in C++?",
      "choices": [
        {
          "label": "Yes",
          "next": "parameter-check-cpp"
        },
        {
          "label": "No",
          "next": "function-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function is a reusable block of code.",
      "action": "continue",
      "next": "parameter-check-cpp"
    },
    {
      "stepId": "parameter-check-cpp",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes",
          "next": "queue-check-cpp"
        },
        {
          "label": "No",
          "next": "parameter-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-cpp",
      "mentorSays": "Parameters are inputs to a function.",
      "action": "continue",
      "next": "queue-check-cpp"
    },
    {
      "stepId": "queue-check-cpp",
      "mentorSays": "To solve this, we'll use a queue. Do you know what a queue is?",
      "choices": [
        {
          "label": "Yes",
          "next": "coding-start-cpp"
        },
        {
          "label": "No",
          "next": "queue-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "queue-explanation-cpp",
      "mentorSays": "A queue is FIFO (First In First Out). We add to the back, remove from the front.",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Perfect! Let's implement the solution in C++.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-init-cpp"
    },
    {
      "stepId": "coding-init-cpp",
      "mentorSays": "Initialize queue and result.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-while-loop-cpp"
    },
    {
      "stepId": "coding-while-loop-cpp",
      "mentorSays": "Create while loop for BFS.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-level-size-cpp"
    },
    {
      "stepId": "coding-level-size-cpp",
      "mentorSays": "Get level size.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-process-level-cpp"
    },
    {
      "stepId": "coding-process-level-cpp",
      "mentorSays": "Process all nodes at current level.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-add-level-cpp"
    },
    {
      "stepId": "coding-add-level-cpp",
      "mentorSays": "Add level to result.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-return-cpp"
    },
    {
      "stepId": "coding-return-cpp",
      "mentorSays": "Return result.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [3,9,20,null,null,15,7]\nExpected: [[3], [9, 20], [15, 7]]\n\n**Test 2:** root = [1]\nExpected: [[1]]\n\n**Test 3:** root = []\nExpected: []\n\n**Test 4:** root = [1,2,3,4,5]\nExpected: [[1], [2, 3], [4, 5]]\n\n**Test 5:** root = [1,2,null,3]\nExpected: [[1], [2], [3]]\n\n**Test 6:** root = [1,null,2,null,3]\nExpected: [[1], [2], [3]]\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [3,9,20,null,null,15,7] â†’ [[3], [9, 20], [15, 7]]\nTest 2: [1] â†’ [[1]]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-ts"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-ts"
        }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "let queue = [];  // Queue for BFS",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Do you know what a function is in TypeScript?",
      "choices": [
        {
          "label": "Yes",
          "next": "parameter-check-ts"
        },
        {
          "label": "No",
          "next": "function-explanation-ts"
        }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function is a reusable block of code.",
      "action": "continue",
      "next": "parameter-check-ts"
    },
    {
      "stepId": "parameter-check-ts",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes",
          "next": "queue-check-ts"
        },
        {
          "label": "No",
          "next": "parameter-explanation-ts"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-ts",
      "mentorSays": "Parameters are inputs to a function.",
      "action": "continue",
      "next": "queue-check-ts"
    },
    {
      "stepId": "queue-check-ts",
      "mentorSays": "To solve this, we'll use a queue. Do you know what a queue is?",
      "choices": [
        {
          "label": "Yes",
          "next": "coding-start-ts"
        },
        {
          "label": "No",
          "next": "queue-explanation-ts"
        }
      ]
    },
    {
      "stepId": "queue-explanation-ts",
      "mentorSays": "A queue is FIFO (First In First Out). We add to the back, remove from the front.",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Perfect! Let's implement the solution in TypeScript.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-init-ts"
    },
    {
      "stepId": "coding-init-ts",
      "mentorSays": "Initialize queue and result.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-while-loop-ts"
    },
    {
      "stepId": "coding-while-loop-ts",
      "mentorSays": "Create while loop for BFS.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-level-size-ts"
    },
    {
      "stepId": "coding-level-size-ts",
      "mentorSays": "Get level size.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-process-level-ts"
    },
    {
      "stepId": "coding-process-level-ts",
      "mentorSays": "Process all nodes at current level.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-add-level-ts"
    },
    {
      "stepId": "coding-add-level-ts",
      "mentorSays": "Add level to result.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-return-ts"
    },
    {
      "stepId": "coding-return-ts",
      "mentorSays": "Return result.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [3,9,20,null,null,15,7]\nExpected: [[3], [9, 20], [15, 7]]\n\n**Test 2:** root = [1]\nExpected: [[1]]\n\n**Test 3:** root = []\nExpected: []\n\n**Test 4:** root = [1,2,3,4,5]\nExpected: [[1], [2, 3], [4, 5]]\n\n**Test 5:** root = [1,2,null,3]\nExpected: [[1], [2], [3]]\n\n**Test 6:** root = [1,null,2,null,3]\nExpected: [[1], [2], [3]]\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [3,9,20,null,null,15,7] â†’ [[3], [9, 20], [15, 7]]\nTest 2: [1] â†’ [[1]]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "final",
      "mentorSays": "ðŸŽ‰ Well done! You've successfully implemented Binary Tree Level Order Traversal!\n\n**Time Complexity:** O(n)\n- We visit each node exactly once\n- Each node is enqueued and dequeued once\n\n**Space Complexity:** O(n)\n- The queue can hold at most O(n) nodes (last level)\n- Result array uses O(n) space\n\n**Key Takeaways:**\n1. **BFS**: Use queue for level-order traversal\n2. **Level by level**: Process one level's nodes before moving to next\n3. **Queue size**: Track level size to process one level at a time\n4. **2D result**: Each inner array represents one level\n5. **Efficiency**: O(n) time is optimal\n\n**Related Practice Problems:**\n- Binary Tree Zigzag Level Order (LeetCode #103) - same but reverse every other level\n- Binary Tree Right Side View (LeetCode #199) - last node of each level\n- Average of Levels in Binary Tree (LeetCode #637) - average of each level\n\nKeep practicing BFS problems - they're common in interviews!",
      "action": "continue"
    }
  ]
}