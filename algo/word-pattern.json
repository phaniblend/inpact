{
  "id": "word-pattern",
  "title": "Word pattern",
  "pattern": "hash-map",
  "difficulty": "easy",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what the Word Pattern problem asks for\n2. Use hash maps to track pattern-to-word mappings\n3. Check bidirectional mappings to ensure pattern matches\n4. Implement the solution step by step in your chosen language",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Perfect! Now let's understand what the Word Pattern problem is asking.\n\nGiven a pattern and a string, determine if the string follows the pattern.\n\nExample 1: pattern = \"abba\", s = \"dog cat cat dog\"\n- Pattern 'a' should map to \"dog\"\n- Pattern 'b' should map to \"cat\"\n- Pattern 'b' should map to \"cat\" (consistent) ✓\n- Pattern 'a' should map to \"dog\" (consistent) ✓\n- They match! Answer: true\n\nExample 2: pattern = \"abba\", s = \"dog cat cat fish\"\n- Pattern 'a' → \"dog\"\n- Pattern 'b' → \"cat\"\n- Pattern 'b' → \"cat\" (consistent) ✓\n- Pattern 'a' → \"fish\" (inconsistent! 'a' already mapped to \"dog\") ✗\n- They don't match! Answer: false\n\nExample 3: pattern = \"aaaa\", s = \"dog cat cat dog\"\n- Pattern 'a' → \"dog\"\n- Pattern 'a' → \"cat\" (inconsistent! 'a' already mapped to \"dog\") ✗\n- They don't match! Answer: false\n\nThat's what the problem wants: return true if s follows the pattern, false otherwise.",
      "example": "pattern = \"abba\", s = \"dog cat cat dog\"\n\nMapping:\na → \"dog\"\nb → \"cat\"\nb → \"cat\" (consistent)\na → \"dog\" (consistent)\n\nResult: true (matches pattern)\n\nAnother example:\npattern = \"abba\", s = \"dog cat cat fish\"\n\nMapping:\na → \"dog\"\nb → \"cat\"\nb → \"cat\" (consistent)\na → \"fish\" (inconsistent! a already mapped to \"dog\")\n\nResult: false (doesn't match pattern)",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Now that you understand what the problem wants, here's the real question:\n\nHow would YOU check if a string follows a pattern?\n\nThink about it for a moment. What approach feels natural to you?",
      "choices": [
        {
          "label": "Use two hash maps to track mappings in both directions",
          "next": "explore-hashmap"
        },
        {
          "label": "Use one hash map and check for conflicts",
          "next": "explore-single-map"
        },
        {
          "label": "Compare character patterns",
          "next": "explore-pattern"
        }
      ]
    },
    {
      "stepId": "explore-single-map",
      "mentorSays": "That's a good approach! However, we need to check mappings in both directions to ensure consistency. For example, pattern \"ab\" and s \"dog dog\" - if we only check pattern→word, we might miss that \"dog\" maps to both 'a' and 'b'.\n\nWould you like to learn the two hash maps approach which ensures bidirectional consistency?",
      "action": "continue",
      "next": "explore-hashmap"
    },
    {
      "stepId": "explore-pattern",
      "mentorSays": "Interesting idea! However, the hash map approach is clearer and more efficient. Would you like to learn it?",
      "action": "continue",
      "next": "explore-hashmap"
    },
    {
      "stepId": "explore-hashmap",
      "mentorSays": "Excellent choice! The two hash maps approach ensures bidirectional consistency. Here's the core idea:\n\n1. **Split the string**: Convert s into an array of words\n2. **Check lengths**: If pattern length ≠ number of words, return false\n3. **Create two hash maps**: One for pattern→word mapping, one for word→pattern mapping\n4. **Iterate through pattern and words**: For each position i:\n   - Check if pattern[i] is already mapped to something different than words[i] → return false\n   - Check if words[i] is already mapped to something different than pattern[i] → return false\n   - Otherwise, create the mappings\n5. **All mappings consistent**: If we finish the loop, return true\n\nLet's trace with pattern = \"abba\", s = \"dog cat cat dog\":\n\n- **Split**: words = [\"dog\", \"cat\", \"cat\", \"dog\"]\n- **Check length**: pattern.length = 4, words.length = 4 ✓\n- **i=0**: pattern[0]='a', words[0]=\"dog\"\n  - patternMap doesn't have 'a' → create mapping a→\"dog\"\n  - wordMap doesn't have \"dog\" → create mapping \"dog\"→a\n- **i=1**: pattern[1]='b', words[1]=\"cat\"\n  - patternMap doesn't have 'b' → create mapping b→\"cat\"\n  - wordMap doesn't have \"cat\" → create mapping \"cat\"→b\n- **i=2**: pattern[2]='b', words[2]=\"cat\"\n  - patternMap['b'] = \"cat\" (matches words[2]) ✓\n  - wordMap[\"cat\"] = 'b' (matches pattern[2]) ✓\n- **i=3**: pattern[3]='a', words[3]=\"dog\"\n  - patternMap['a'] = \"dog\" (matches words[3]) ✓\n  - wordMap[\"dog\"] = 'a' (matches pattern[3]) ✓\n- **Result**: All mappings consistent → true\n\nThis is O(n) time! Now let's code it step by step.",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Great! Now let's code this solution. Which programming language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "variable-check-js"
        },
        {
          "label": "Python",
          "next": "variable-check-python"
        },
        {
          "label": "Java",
          "next": "variable-check-java"
        },
        {
          "label": "C++",
          "next": "variable-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "variable-check-ts"
        }
      ]
    },
    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-js"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-js"
        }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'patternMap' or 'wordMap') and put data inside it.\n\nFor example, 'let patternMap = {};' creates a variable that stores an object (hash map). Later, you can use that variable name to refer to it.",
      "example": "let patternMap = {};\n\nNow the variable refers to an empty object\nWe can use the variable name to access this object",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-js"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-js"
        }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the function does the work, and gives you a result (return value).",
      "example": "function add(a, b) {\n  return a + b;\n}\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-js"
    },
    {
      "stepId": "parameter-check-js",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "loop-check-js"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-js"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-js",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function wordPattern(pattern, s)', the 'pattern' and 's' are parameters - they're placeholders that will receive actual values when you call the function.\n\nWhen you call 'wordPattern(\"abba\", \"dog cat cat dog\")', the string \"abba\" goes into 'pattern' and \"dog cat cat dog\" goes into 's'.",
      "example": "function wordPattern(pattern, s) {\n  // 'pattern' and 's' are parameters\n}\n\n// When we call it:\nwordPattern(\"abba\", \"dog cat cat dog\");\n// \"abba\" goes into 'pattern', \"dog cat cat dog\" goes into 's'",
      "action": "continue",
      "next": "loop-check-js"
    },
    {
      "stepId": "loop-check-js",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "coding-start-js"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-js"
        }
      ]
    },
    {
      "stepId": "loop-explanation-js",
      "mentorSays": "A loop lets you repeat code multiple times. A 'for' loop runs code for each index in a sequence.\n\nFor example, 'for (let i = 0; i < pattern.length; i++)' means: run the code for each index from 0 to pattern.length-1.",
      "example": "for (let i = 0; i < 3; i++) {\n  console.log(i);\n}\n\nThis prints: 0, 1, 2",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Perfect! Let's implement the word pattern solution in JavaScript. We'll create a function that takes a pattern and a string, and returns true if the string follows the pattern, false otherwise.",
      "example": "function wordPattern(pattern, s) {\n  \n}",
      "action": "continue",
      "next": "coding-split-js"
    },
    {
      "stepId": "coding-split-js",
      "mentorSays": "First, let's split the string into an array of words.",
      "example": "function wordPattern(pattern, s) {\n  // Split string into words\n  const words = s.split(' ');\n  // For \"dog cat cat dog\": words = [\"dog\", \"cat\", \"cat\", \"dog\"]\n}",
      "action": "continue",
      "next": "coding-check-length-js"
    },
    {
      "stepId": "coding-check-length-js",
      "mentorSays": "Check if the pattern length matches the number of words. If they don't match, return false.",
      "example": "function wordPattern(pattern, s) {\n  const words = s.split(' ');\n  \n  // If lengths don't match, pattern can't match\n  if (pattern.length !== words.length) {\n    return false;\n  }\n}",
      "action": "continue",
      "next": "coding-init-maps-js"
    },
    {
      "stepId": "coding-init-maps-js",
      "mentorSays": "Now, let's create two hash maps: one for pattern→word mapping and one for word→pattern mapping.",
      "example": "function wordPattern(pattern, s) {\n  const words = s.split(' ');\n  \n  if (pattern.length !== words.length) {\n    return false;\n  }\n  \n  // Create two hash maps for bidirectional mapping\n  let patternMap = {};  // Maps pattern characters to words\n  let wordMap = {};     // Maps words to pattern characters\n}",
      "action": "continue",
      "next": "coding-loop-js"
    },
    {
      "stepId": "coding-loop-js",
      "mentorSays": "Now, let's iterate through both the pattern and words simultaneously.",
      "example": "function wordPattern(pattern, s) {\n  const words = s.split(' ');\n  \n  if (pattern.length !== words.length) {\n    return false;\n  }\n  \n  let patternMap = {};\n  let wordMap = {};\n  \n  // Iterate through pattern and words\n  for (let i = 0; i < pattern.length; i++) {\n    \n  }\n}",
      "action": "continue",
      "next": "coding-check-pattern-mapping-js"
    },
    {
      "stepId": "coding-check-pattern-mapping-js",
      "mentorSays": "For each position, check if pattern[i] is already mapped to something different than words[i]. If so, return false.",
      "example": "function wordPattern(pattern, s) {\n  const words = s.split(' ');\n  \n  if (pattern.length !== words.length) {\n    return false;\n  }\n  \n  let patternMap = {};\n  let wordMap = {};\n  \n  for (let i = 0; i < pattern.length; i++) {\n    // Check if pattern[i] is already mapped to something different\n    if (patternMap[pattern[i]] && patternMap[pattern[i]] !== words[i]) {\n      return false;\n    }\n  }\n}",
      "action": "continue",
      "next": "coding-check-word-mapping-js"
    },
    {
      "stepId": "coding-check-word-mapping-js",
      "mentorSays": "Also check if words[i] is already mapped to something different than pattern[i]. If so, return false.",
      "example": "function wordPattern(pattern, s) {\n  const words = s.split(' ');\n  \n  if (pattern.length !== words.length) {\n    return false;\n  }\n  \n  let patternMap = {};\n  let wordMap = {};\n  \n  for (let i = 0; i < pattern.length; i++) {\n    if (patternMap[pattern[i]] && patternMap[pattern[i]] !== words[i]) {\n      return false;\n    }\n    // Check if words[i] is already mapped to something different\n    if (wordMap[words[i]] && wordMap[words[i]] !== pattern[i]) {\n      return false;\n    }\n  }\n}",
      "action": "continue",
      "next": "coding-create-mappings-js"
    },
    {
      "stepId": "coding-create-mappings-js",
      "mentorSays": "If both checks pass, create the mappings: pattern[i] → words[i] and words[i] → pattern[i].",
      "example": "function wordPattern(pattern, s) {\n  const words = s.split(' ');\n  \n  if (pattern.length !== words.length) {\n    return false;\n  }\n  \n  let patternMap = {};\n  let wordMap = {};\n  \n  for (let i = 0; i < pattern.length; i++) {\n    if (patternMap[pattern[i]] && patternMap[pattern[i]] !== words[i]) {\n      return false;\n    }\n    if (wordMap[words[i]] && wordMap[words[i]] !== pattern[i]) {\n      return false;\n    }\n    // Create mappings\n    patternMap[pattern[i]] = words[i];\n    wordMap[words[i]] = pattern[i];\n  }\n}",
      "action": "continue",
      "next": "coding-return-true-js"
    },
    {
      "stepId": "coding-return-true-js",
      "mentorSays": "If we finish the loop without finding any conflicts, return true - the string follows the pattern!",
      "example": "function wordPattern(pattern, s) {\n  const words = s.split(' ');\n  \n  if (pattern.length !== words.length) {\n    return false;\n  }\n  \n  let patternMap = {};\n  let wordMap = {};\n  \n  for (let i = 0; i < pattern.length; i++) {\n    if (patternMap[pattern[i]] && patternMap[pattern[i]] !== words[i]) {\n      return false;\n    }\n    if (wordMap[words[i]] && wordMap[words[i]] !== pattern[i]) {\n      return false;\n    }\n    patternMap[pattern[i]] = words[i];\n    wordMap[words[i]] = pattern[i];\n  }\n  \n  // All mappings are consistent\n  return true;\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\npattern = \"abba\", s = \"dog cat cat dog\"\n\nExpected output: true\n\nTry it in your IDE or code editor!",
      "example": "Test input:\npattern = \"abba\"\ns = \"dog cat cat dog\"\n\nExpected output: true\n\nBecause all mappings are consistent.",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Python?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-python"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-python"
        }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'patternMap' or 'wordMap') and put data inside it.\n\nFor example, 'patternMap = {}' creates a variable that stores a dictionary (hash map). Later, you can use that variable name to refer to it.",
      "example": "patternMap = {}\n\nNow the variable refers to an empty dictionary\nWe can use the variable name to access this dictionary",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Python?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-python"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-python"
        }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the function does the work, and gives you a result (return value).",
      "example": "def add(a, b):\n    return a + b\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-python"
    },
    {
      "stepId": "parameter-check-python",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "loop-check-python"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-python"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-python",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'def word_pattern(pattern, s):', the 'pattern' and 's' are parameters - they're placeholders that will receive actual values when you call the function.\n\nWhen you call 'word_pattern(\"abba\", \"dog cat cat dog\")', the string \"abba\" goes into 'pattern' and \"dog cat cat dog\" goes into 's'.",
      "example": "def word_pattern(pattern, s):\n  # 'pattern' and 's' are parameters\n\n# When we call it:\nword_pattern(\"abba\", \"dog cat cat dog\")\n# \"abba\" goes into 'pattern', \"dog cat cat dog\" goes into 's'",
      "action": "continue",
      "next": "loop-check-python"
    },
    {
      "stepId": "loop-check-python",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in Python?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "coding-start-python"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-python"
        }
      ]
    },
    {
      "stepId": "loop-explanation-python",
      "mentorSays": "A loop lets you repeat code multiple times. A 'for' loop in Python runs code for each index in a sequence.\n\nFor example, 'for i in range(len(pattern)):' means: run the code for each index from 0 to len(pattern)-1.",
      "example": "for i in range(3):\n    print(i)\n\nThis prints: 0, 1, 2",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Perfect! Let's implement the word pattern solution in Python. We'll create a function that takes a pattern and a string, and returns True if the string follows the pattern, False otherwise.",
      "example": "def word_pattern(pattern, s):\n    \n    pass",
      "action": "continue",
      "next": "coding-split-python"
    },
    {
      "stepId": "coding-split-python",
      "mentorSays": "First, let's split the string into a list of words.",
      "example": "def word_pattern(pattern, s):\n    # Split string into words\n    words = s.split()\n    # For \"dog cat cat dog\": words = [\"dog\", \"cat\", \"cat\", \"dog\"]\n    \n    pass",
      "action": "continue",
      "next": "coding-check-length-python"
    },
    {
      "stepId": "coding-check-length-python",
      "mentorSays": "Check if the pattern length matches the number of words. If they don't match, return False.",
      "example": "def word_pattern(pattern, s):\n    words = s.split()\n    \n    # If lengths don't match, pattern can't match\n    if len(pattern) != len(words):\n        return False\n    \n    pass",
      "action": "continue",
      "next": "coding-init-maps-python"
    },
    {
      "stepId": "coding-init-maps-python",
      "mentorSays": "Now, let's create two dictionaries: one for pattern→word mapping and one for word→pattern mapping.",
      "example": "def word_pattern(pattern, s):\n    words = s.split()\n    \n    if len(pattern) != len(words):\n        return False\n    \n    # Create two dictionaries for bidirectional mapping\n    patternMap = {}  # Maps pattern characters to words\n    wordMap = {}     # Maps words to pattern characters\n    \n    pass",
      "action": "continue",
      "next": "coding-loop-python"
    },
    {
      "stepId": "coding-loop-python",
      "mentorSays": "Now, let's iterate through both the pattern and words simultaneously.",
      "example": "def word_pattern(pattern, s):\n    words = s.split()\n    \n    if len(pattern) != len(words):\n        return False\n    \n    patternMap = {}\n    wordMap = {}\n    \n    # Iterate through pattern and words\n    for i in range(len(pattern)):\n        \n    pass",
      "action": "continue",
      "next": "coding-check-pattern-mapping-python"
    },
    {
      "stepId": "coding-check-pattern-mapping-python",
      "mentorSays": "For each position, check if pattern[i] is already mapped to something different than words[i]. If so, return False.",
      "example": "def word_pattern(pattern, s):\n    words = s.split()\n    \n    if len(pattern) != len(words):\n        return False\n    \n    patternMap = {}\n    wordMap = {}\n    \n    for i in range(len(pattern)):\n        # Check if pattern[i] is already mapped to something different\n        if pattern[i] in patternMap and patternMap[pattern[i]] != words[i]:\n            return False\n    \n    pass",
      "action": "continue",
      "next": "coding-check-word-mapping-python"
    },
    {
      "stepId": "coding-check-word-mapping-python",
      "mentorSays": "Also check if words[i] is already mapped to something different than pattern[i]. If so, return False.",
      "example": "def word_pattern(pattern, s):\n    words = s.split()\n    \n    if len(pattern) != len(words):\n        return False\n    \n    patternMap = {}\n    wordMap = {}\n    \n    for i in range(len(pattern)):\n        if pattern[i] in patternMap and patternMap[pattern[i]] != words[i]:\n            return False\n        # Check if words[i] is already mapped to something different\n        if words[i] in wordMap and wordMap[words[i]] != pattern[i]:\n            return False\n    \n    pass",
      "action": "continue",
      "next": "coding-create-mappings-python"
    },
    {
      "stepId": "coding-create-mappings-python",
      "mentorSays": "If both checks pass, create the mappings: pattern[i] → words[i] and words[i] → pattern[i].",
      "example": "def word_pattern(pattern, s):\n    words = s.split()\n    \n    if len(pattern) != len(words):\n        return False\n    \n    patternMap = {}\n    wordMap = {}\n    \n    for i in range(len(pattern)):\n        if pattern[i] in patternMap and patternMap[pattern[i]] != words[i]:\n            return False\n        if words[i] in wordMap and wordMap[words[i]] != pattern[i]:\n            return False\n        # Create mappings\n        patternMap[pattern[i]] = words[i]\n        wordMap[words[i]] = pattern[i]\n    \n    pass",
      "action": "continue",
      "next": "coding-return-true-python"
    },
    {
      "stepId": "coding-return-true-python",
      "mentorSays": "If we finish the loop without finding any conflicts, return True - the string follows the pattern!",
      "example": "def word_pattern(pattern, s):\n    words = s.split()\n    \n    if len(pattern) != len(words):\n        return False\n    \n    patternMap = {}\n    wordMap = {}\n    \n    for i in range(len(pattern)):\n        if pattern[i] in patternMap and patternMap[pattern[i]] != words[i]:\n            return False\n        if words[i] in wordMap and wordMap[words[i]] != pattern[i]:\n            return False\n        patternMap[pattern[i]] = words[i]\n        wordMap[words[i]] = pattern[i]\n    \n    # All mappings are consistent\n    return True",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\npattern = \"abba\", s = \"dog cat cat dog\"\n\nExpected output: True\n\nTry it in your IDE or code editor!",
      "example": "Test input:\npattern = \"abba\"\ns = \"dog cat cat dog\"\n\nExpected output: True\n\nBecause all mappings are consistent.",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Java?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-java"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-java"
        }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'patternMap' or 'wordMap') and put data inside it.\n\nFor example, 'Map<Character, String> patternMap = new HashMap<>();' creates a variable that stores a HashMap. Later, you can use that variable name to refer to it.",
      "example": "Map<Character, String> patternMap = new HashMap<>();\n\nNow the variable refers to an empty hash map\nWe can use the variable name to access this hash map",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a method is in Java?",
      "choices": [
        {
          "label": "Yes, I know methods",
          "next": "parameter-check-java"
        },
        {
          "label": "No, explain methods",
          "next": "function-explanation-java"
        }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A method (Java's version of a function) is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the method does the work, and gives you a result (return value).",
      "example": "public int add(int a, int b) {\n    return a + b;\n}\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-java"
    },
    {
      "stepId": "parameter-check-java",
      "mentorSays": "When we write a method, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "loop-check-java"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-java"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-java",
      "mentorSays": "Parameters are like variables that receive values when you call the method. When you write 'public boolean wordPattern(String pattern, String s)', the 'pattern' and 's' are parameters - they're placeholders that will receive actual strings when you call the method.\n\nWhen you call 'wordPattern(\"abba\", \"dog cat cat dog\")', the string \"abba\" goes into 'pattern' and \"dog cat cat dog\" goes into 's'.",
      "example": "public boolean wordPattern(String pattern, String s) {\n  // 'pattern' and 's' are parameters\n}\n\n// When we call it:\nwordPattern(\"abba\", \"dog cat cat dog\");\n// \"abba\" goes into 'pattern', \"dog cat cat dog\" goes into 's'",
      "action": "continue",
      "next": "loop-check-java"
    },
    {
      "stepId": "loop-check-java",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in Java?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "coding-start-java"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-java"
        }
      ]
    },
    {
      "stepId": "loop-explanation-java",
      "mentorSays": "A loop lets you repeat code multiple times. A 'for' loop runs code for each index in a sequence.\n\nFor example, 'for (int i = 0; i < pattern.length(); i++)' means: run the code for each index from 0 to pattern.length()-1.",
      "example": "for (int i = 0; i < 3; i++) {\n    System.out.println(i);\n}\n\nThis prints: 0, 1, 2",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Perfect! Let's implement the word pattern solution in Java. We'll create a method that takes a pattern and a string, and returns true if the string follows the pattern, false otherwise.",
      "example": "public boolean wordPattern(String pattern, String s) {\n    \n}",
      "action": "continue",
      "next": "coding-split-java"
    },
    {
      "stepId": "coding-split-java",
      "mentorSays": "First, let's split the string into an array of words.",
      "example": "public boolean wordPattern(String pattern, String s) {\n    // Split string into words\n    String[] words = s.split(\" \");\n    // For \"dog cat cat dog\": words = [\"dog\", \"cat\", \"cat\", \"dog\"]\n}",
      "action": "continue",
      "next": "coding-check-length-java"
    },
    {
      "stepId": "coding-check-length-java",
      "mentorSays": "Check if the pattern length matches the number of words. If they don't match, return false.",
      "example": "public boolean wordPattern(String pattern, String s) {\n    String[] words = s.split(\" \");\n    \n    // If lengths don't match, pattern can't match\n    if (pattern.length() != words.length) {\n        return false;\n    }\n}",
      "action": "continue",
      "next": "coding-init-maps-java"
    },
    {
      "stepId": "coding-init-maps-java",
      "mentorSays": "Now, let's create two HashMaps: one for pattern→word mapping and one for word→pattern mapping.",
      "example": "public boolean wordPattern(String pattern, String s) {\n    String[] words = s.split(\" \");\n    \n    if (pattern.length() != words.length) {\n        return false;\n    }\n    \n    // Create two HashMaps for bidirectional mapping\n    Map<Character, String> patternMap = new HashMap<>();  // Maps pattern characters to words\n    Map<String, Character> wordMap = new HashMap<>();     // Maps words to pattern characters\n}",
      "action": "continue",
      "next": "coding-loop-java"
    },
    {
      "stepId": "coding-loop-java",
      "mentorSays": "Now, let's iterate through both the pattern and words simultaneously.",
      "example": "public boolean wordPattern(String pattern, String s) {\n    String[] words = s.split(\" \");\n    \n    if (pattern.length() != words.length) {\n        return false;\n    }\n    \n    Map<Character, String> patternMap = new HashMap<>();\n    Map<String, Character> wordMap = new HashMap<>();\n    \n    // Iterate through pattern and words\n    for (int i = 0; i < pattern.length(); i++) {\n        \n    }\n}",
      "action": "continue",
      "next": "coding-check-pattern-mapping-java"
    },
    {
      "stepId": "coding-check-pattern-mapping-java",
      "mentorSays": "For each position, check if pattern[i] is already mapped to something different than words[i]. If so, return false.",
      "example": "public boolean wordPattern(String pattern, String s) {\n    String[] words = s.split(\" \");\n    \n    if (pattern.length() != words.length) {\n        return false;\n    }\n    \n    Map<Character, String> patternMap = new HashMap<>();\n    Map<String, Character> wordMap = new HashMap<>();\n    \n    for (int i = 0; i < pattern.length(); i++) {\n        // Check if pattern[i] is already mapped to something different\n        if (patternMap.containsKey(pattern.charAt(i)) && !patternMap.get(pattern.charAt(i)).equals(words[i])) {\n            return false;\n        }\n    }\n}",
      "action": "continue",
      "next": "coding-check-word-mapping-java"
    },
    {
      "stepId": "coding-check-word-mapping-java",
      "mentorSays": "Also check if words[i] is already mapped to something different than pattern[i]. If so, return false.",
      "example": "public boolean wordPattern(String pattern, String s) {\n    String[] words = s.split(\" \");\n    \n    if (pattern.length() != words.length) {\n        return false;\n    }\n    \n    Map<Character, String> patternMap = new HashMap<>();\n    Map<String, Character> wordMap = new HashMap<>();\n    \n    for (int i = 0; i < pattern.length(); i++) {\n        if (patternMap.containsKey(pattern.charAt(i)) && !patternMap.get(pattern.charAt(i)).equals(words[i])) {\n            return false;\n        }\n        // Check if words[i] is already mapped to something different\n        if (wordMap.containsKey(words[i]) && wordMap.get(words[i]) != pattern.charAt(i)) {\n            return false;\n        }\n    }\n}",
      "action": "continue",
      "next": "coding-create-mappings-java"
    },
    {
      "stepId": "coding-create-mappings-java",
      "mentorSays": "If both checks pass, create the mappings: pattern[i] → words[i] and words[i] → pattern[i].",
      "example": "public boolean wordPattern(String pattern, String s) {\n    String[] words = s.split(\" \");\n    \n    if (pattern.length() != words.length) {\n        return false;\n    }\n    \n    Map<Character, String> patternMap = new HashMap<>();\n    Map<String, Character> wordMap = new HashMap<>();\n    \n    for (int i = 0; i < pattern.length(); i++) {\n        if (patternMap.containsKey(pattern.charAt(i)) && !patternMap.get(pattern.charAt(i)).equals(words[i])) {\n            return false;\n        }\n        if (wordMap.containsKey(words[i]) && wordMap.get(words[i]) != pattern.charAt(i)) {\n            return false;\n        }\n        // Create mappings\n        patternMap.put(pattern.charAt(i), words[i]);\n        wordMap.put(words[i], pattern.charAt(i));\n    }\n}",
      "action": "continue",
      "next": "coding-return-true-java"
    },
    {
      "stepId": "coding-return-true-java",
      "mentorSays": "If we finish the loop without finding any conflicts, return true - the string follows the pattern!",
      "example": "public boolean wordPattern(String pattern, String s) {\n    String[] words = s.split(\" \");\n    \n    if (pattern.length() != words.length) {\n        return false;\n    }\n    \n    Map<Character, String> patternMap = new HashMap<>();\n    Map<String, Character> wordMap = new HashMap<>();\n    \n    for (int i = 0; i < pattern.length(); i++) {\n        if (patternMap.containsKey(pattern.charAt(i)) && !patternMap.get(pattern.charAt(i)).equals(words[i])) {\n            return false;\n        }\n        if (wordMap.containsKey(words[i]) && wordMap.get(words[i]) != pattern.charAt(i)) {\n            return false;\n        }\n        patternMap.put(pattern.charAt(i), words[i]);\n        wordMap.put(words[i], pattern.charAt(i));\n    }\n    \n    // All mappings are consistent\n    return true;\n}",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\npattern = \"abba\", s = \"dog cat cat dog\"\n\nExpected output: true\n\nTry it in your IDE or code editor!",
      "example": "Test input:\npattern = \"abba\"\ns = \"dog cat cat dog\"\n\nExpected output: true\n\nBecause all mappings are consistent.",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in C++?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-cpp"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'patternMap' or 'wordMap') and put data inside it.\n\nFor example, 'unordered_map<char, string> patternMap;' creates a variable that stores an unordered_map. Later, you can use that variable name to refer to it.",
      "example": "unordered_map<char, string> patternMap;\n\nNow the variable refers to an empty hash map\nWe can use the variable name to access this hash map",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in C++?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-cpp"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the function does the work, and gives you a result (return value).",
      "example": "int add(int a, int b) {\n    return a + b;\n}\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-cpp"
    },
    {
      "stepId": "parameter-check-cpp",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "loop-check-cpp"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-cpp",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'bool wordPattern(string pattern, string s)', the 'pattern' and 's' are parameters - they're placeholders that will receive actual strings when you call the function.\n\nWhen you call 'wordPattern(\"abba\", \"dog cat cat dog\")', the string \"abba\" goes into 'pattern' and \"dog cat cat dog\" goes into 's'.",
      "example": "bool wordPattern(string pattern, string s) {\n  // 'pattern' and 's' are parameters\n}\n\n// When we call it:\nwordPattern(\"abba\", \"dog cat cat dog\");\n// \"abba\" goes into 'pattern', \"dog cat cat dog\" goes into 's'",
      "action": "continue",
      "next": "loop-check-cpp"
    },
    {
      "stepId": "loop-check-cpp",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in C++?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "coding-start-cpp"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "loop-explanation-cpp",
      "mentorSays": "A loop lets you repeat code multiple times. A 'for' loop runs code for each index in a sequence.\n\nFor example, 'for (int i = 0; i < pattern.length(); i++)' means: run the code for each index from 0 to pattern.length()-1.",
      "example": "for (int i = 0; i < 3; i++) {\n    cout << i << endl;\n}\n\nThis prints: 0, 1, 2",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Perfect! Let's implement the word pattern solution in C++. We'll create a function that takes a pattern and a string, and returns true if the string follows the pattern, false otherwise.",
      "example": "bool wordPattern(string pattern, string s) {\n    \n}",
      "action": "continue",
      "next": "coding-split-cpp"
    },
    {
      "stepId": "coding-split-cpp",
      "mentorSays": "First, let's split the string into a vector of words. We'll use a stringstream to split by spaces.",
      "example": "bool wordPattern(string pattern, string s) {\n    // Split string into words\n    stringstream ss(s);\n    string word;\n    vector<string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    // For \"dog cat cat dog\": words = [\"dog\", \"cat\", \"cat\", \"dog\"]\n}",
      "action": "continue",
      "next": "coding-check-length-cpp"
    },
    {
      "stepId": "coding-check-length-cpp",
      "mentorSays": "Check if the pattern length matches the number of words. If they don't match, return false.",
      "example": "bool wordPattern(string pattern, string s) {\n    stringstream ss(s);\n    string word;\n    vector<string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    // If lengths don't match, pattern can't match\n    if (pattern.length() != words.size()) {\n        return false;\n    }\n}",
      "action": "continue",
      "next": "coding-init-maps-cpp"
    },
    {
      "stepId": "coding-init-maps-cpp",
      "mentorSays": "Now, let's create two unordered_maps: one for pattern→word mapping and one for word→pattern mapping.",
      "example": "bool wordPattern(string pattern, string s) {\n    stringstream ss(s);\n    string word;\n    vector<string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    if (pattern.length() != words.size()) {\n        return false;\n    }\n    \n    // Create two unordered_maps for bidirectional mapping\n    unordered_map<char, string> patternMap;  // Maps pattern characters to words\n    unordered_map<string, char> wordMap;     // Maps words to pattern characters\n}",
      "action": "continue",
      "next": "coding-loop-cpp"
    },
    {
      "stepId": "coding-loop-cpp",
      "mentorSays": "Now, let's iterate through both the pattern and words simultaneously.",
      "example": "bool wordPattern(string pattern, string s) {\n    stringstream ss(s);\n    string word;\n    vector<string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    if (pattern.length() != words.size()) {\n        return false;\n    }\n    \n    unordered_map<char, string> patternMap;\n    unordered_map<string, char> wordMap;\n    \n    // Iterate through pattern and words\n    for (int i = 0; i < pattern.length(); i++) {\n        \n    }\n}",
      "action": "continue",
      "next": "coding-check-pattern-mapping-cpp"
    },
    {
      "stepId": "coding-check-pattern-mapping-cpp",
      "mentorSays": "For each position, check if pattern[i] is already mapped to something different than words[i]. If so, return false.",
      "example": "bool wordPattern(string pattern, string s) {\n    stringstream ss(s);\n    string word;\n    vector<string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    if (pattern.length() != words.size()) {\n        return false;\n    }\n    \n    unordered_map<char, string> patternMap;\n    unordered_map<string, char> wordMap;\n    \n    for (int i = 0; i < pattern.length(); i++) {\n        // Check if pattern[i] is already mapped to something different\n        if (patternMap.find(pattern[i]) != patternMap.end() && patternMap[pattern[i]] != words[i]) {\n            return false;\n        }\n    }\n}",
      "action": "continue",
      "next": "coding-check-word-mapping-cpp"
    },
    {
      "stepId": "coding-check-word-mapping-cpp",
      "mentorSays": "Also check if words[i] is already mapped to something different than pattern[i]. If so, return false.",
      "example": "bool wordPattern(string pattern, string s) {\n    stringstream ss(s);\n    string word;\n    vector<string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    if (pattern.length() != words.size()) {\n        return false;\n    }\n    \n    unordered_map<char, string> patternMap;\n    unordered_map<string, char> wordMap;\n    \n    for (int i = 0; i < pattern.length(); i++) {\n        if (patternMap.find(pattern[i]) != patternMap.end() && patternMap[pattern[i]] != words[i]) {\n            return false;\n        }\n        // Check if words[i] is already mapped to something different\n        if (wordMap.find(words[i]) != wordMap.end() && wordMap[words[i]] != pattern[i]) {\n            return false;\n        }\n    }\n}",
      "action": "continue",
      "next": "coding-create-mappings-cpp"
    },
    {
      "stepId": "coding-create-mappings-cpp",
      "mentorSays": "If both checks pass, create the mappings: pattern[i] → words[i] and words[i] → pattern[i].",
      "example": "bool wordPattern(string pattern, string s) {\n    stringstream ss(s);\n    string word;\n    vector<string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    if (pattern.length() != words.size()) {\n        return false;\n    }\n    \n    unordered_map<char, string> patternMap;\n    unordered_map<string, char> wordMap;\n    \n    for (int i = 0; i < pattern.length(); i++) {\n        if (patternMap.find(pattern[i]) != patternMap.end() && patternMap[pattern[i]] != words[i]) {\n            return false;\n        }\n        if (wordMap.find(words[i]) != wordMap.end() && wordMap[words[i]] != pattern[i]) {\n            return false;\n        }\n        // Create mappings\n        patternMap[pattern[i]] = words[i];\n        wordMap[words[i]] = pattern[i];\n    }\n}",
      "action": "continue",
      "next": "coding-return-true-cpp"
    },
    {
      "stepId": "coding-return-true-cpp",
      "mentorSays": "If we finish the loop without finding any conflicts, return true - the string follows the pattern!",
      "example": "bool wordPattern(string pattern, string s) {\n    stringstream ss(s);\n    string word;\n    vector<string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    if (pattern.length() != words.size()) {\n        return false;\n    }\n    \n    unordered_map<char, string> patternMap;\n    unordered_map<string, char> wordMap;\n    \n    for (int i = 0; i < pattern.length(); i++) {\n        if (patternMap.find(pattern[i]) != patternMap.end() && patternMap[pattern[i]] != words[i]) {\n            return false;\n        }\n        if (wordMap.find(words[i]) != wordMap.end() && wordMap[words[i]] != pattern[i]) {\n            return false;\n        }\n        patternMap[pattern[i]] = words[i];\n        wordMap[words[i]] = pattern[i];\n    }\n    \n    // All mappings are consistent\n    return true;\n}",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\npattern = \"abba\", s = \"dog cat cat dog\"\n\nExpected output: true\n\nTry it in your IDE or code editor!",
      "example": "Test input:\npattern = \"abba\"\ns = \"dog cat cat dog\"\n\nExpected output: true\n\nBecause all mappings are consistent.",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-ts"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-ts"
        }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'patternMap' or 'wordMap') and put data inside it.\n\nFor example, 'let patternMap: {[key: string]: string} = {};' creates a variable that stores an object (hash map). Later, you can use that variable name to refer to it.",
      "example": "let patternMap: {[key: string]: string} = {};\n\nNow the variable refers to an empty object\nWe can use the variable name to access this object",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-ts"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-ts"
        }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the function does the work, and gives you a result (return value).",
      "example": "function add(a: number, b: number): number {\n  return a + b;\n}\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-ts"
    },
    {
      "stepId": "parameter-check-ts",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "loop-check-ts"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-ts"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-ts",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function wordPattern(pattern: string, s: string): boolean', the 'pattern' and 's' are parameters - they're placeholders that will receive actual strings when you call the function.\n\nWhen you call 'wordPattern(\"abba\", \"dog cat cat dog\")', the string \"abba\" goes into 'pattern' and \"dog cat cat dog\" goes into 's'.",
      "example": "function wordPattern(pattern: string, s: string): boolean {\n  // 'pattern' and 's' are parameters\n}\n\n// When we call it:\nwordPattern(\"abba\", \"dog cat cat dog\");\n// \"abba\" goes into 'pattern', \"dog cat cat dog\" goes into 's'",
      "action": "continue",
      "next": "loop-check-ts"
    },
    {
      "stepId": "loop-check-ts",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "coding-start-ts"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-ts"
        }
      ]
    },
    {
      "stepId": "loop-explanation-ts",
      "mentorSays": "A loop lets you repeat code multiple times. A 'for' loop runs code for each index in a sequence.\n\nFor example, 'for (let i = 0; i < pattern.length; i++)' means: run the code for each index from 0 to pattern.length-1.",
      "example": "for (let i = 0; i < 3; i++) {\n  console.log(i);\n}\n\nThis prints: 0, 1, 2",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Perfect! Let's implement the word pattern solution in TypeScript. We'll create a function that takes a pattern and a string, and returns true if the string follows the pattern, false otherwise.",
      "example": "function wordPattern(pattern: string, s: string): boolean {\n  \n}",
      "action": "continue",
      "next": "coding-split-ts"
    },
    {
      "stepId": "coding-split-ts",
      "mentorSays": "First, let's split the string into an array of words.",
      "example": "function wordPattern(pattern: string, s: string): boolean {\n  // Split string into words\n  const words = s.split(' ');\n  // For \"dog cat cat dog\": words = [\"dog\", \"cat\", \"cat\", \"dog\"]\n}",
      "action": "continue",
      "next": "coding-check-length-ts"
    },
    {
      "stepId": "coding-check-length-ts",
      "mentorSays": "Check if the pattern length matches the number of words. If they don't match, return false.",
      "example": "function wordPattern(pattern: string, s: string): boolean {\n  const words = s.split(' ');\n  \n  // If lengths don't match, pattern can't match\n  if (pattern.length !== words.length) {\n    return false;\n  }\n}",
      "action": "continue",
      "next": "coding-init-maps-ts"
    },
    {
      "stepId": "coding-init-maps-ts",
      "mentorSays": "Now, let's create two objects: one for pattern→word mapping and one for word→pattern mapping.",
      "example": "function wordPattern(pattern: string, s: string): boolean {\n  const words = s.split(' ');\n  \n  if (pattern.length !== words.length) {\n    return false;\n  }\n  \n  // Create two objects for bidirectional mapping\n  let patternMap: {[key: string]: string} = {};  // Maps pattern characters to words\n  let wordMap: {[key: string]: string} = {};     // Maps words to pattern characters\n}",
      "action": "continue",
      "next": "coding-loop-ts"
    },
    {
      "stepId": "coding-loop-ts",
      "mentorSays": "Now, let's iterate through both the pattern and words simultaneously.",
      "example": "function wordPattern(pattern: string, s: string): boolean {\n  const words = s.split(' ');\n  \n  if (pattern.length !== words.length) {\n    return false;\n  }\n  \n  let patternMap: {[key: string]: string} = {};\n  let wordMap: {[key: string]: string} = {};\n  \n  // Iterate through pattern and words\n  for (let i = 0; i < pattern.length; i++) {\n    \n  }\n}",
      "action": "continue",
      "next": "coding-check-pattern-mapping-ts"
    },
    {
      "stepId": "coding-check-pattern-mapping-ts",
      "mentorSays": "For each position, check if pattern[i] is already mapped to something different than words[i]. If so, return false.",
      "example": "function wordPattern(pattern: string, s: string): boolean {\n  const words = s.split(' ');\n  \n  if (pattern.length !== words.length) {\n    return false;\n  }\n  \n  let patternMap: {[key: string]: string} = {};\n  let wordMap: {[key: string]: string} = {};\n  \n  for (let i = 0; i < pattern.length; i++) {\n    // Check if pattern[i] is already mapped to something different\n    if (patternMap[pattern[i]] && patternMap[pattern[i]] !== words[i]) {\n      return false;\n    }\n  }\n}",
      "action": "continue",
      "next": "coding-check-word-mapping-ts"
    },
    {
      "stepId": "coding-check-word-mapping-ts",
      "mentorSays": "Also check if words[i] is already mapped to something different than pattern[i]. If so, return false.",
      "example": "function wordPattern(pattern: string, s: string): boolean {\n  const words = s.split(' ');\n  \n  if (pattern.length !== words.length) {\n    return false;\n  }\n  \n  let patternMap: {[key: string]: string} = {};\n  let wordMap: {[key: string]: string} = {};\n  \n  for (let i = 0; i < pattern.length; i++) {\n    if (patternMap[pattern[i]] && patternMap[pattern[i]] !== words[i]) {\n      return false;\n    }\n    // Check if words[i] is already mapped to something different\n    if (wordMap[words[i]] && wordMap[words[i]] !== pattern[i]) {\n      return false;\n    }\n  }\n}",
      "action": "continue",
      "next": "coding-create-mappings-ts"
    },
    {
      "stepId": "coding-create-mappings-ts",
      "mentorSays": "If both checks pass, create the mappings: pattern[i] → words[i] and words[i] → pattern[i].",
      "example": "function wordPattern(pattern: string, s: string): boolean {\n  const words = s.split(' ');\n  \n  if (pattern.length !== words.length) {\n    return false;\n  }\n  \n  let patternMap: {[key: string]: string} = {};\n  let wordMap: {[key: string]: string} = {};\n  \n  for (let i = 0; i < pattern.length; i++) {\n    if (patternMap[pattern[i]] && patternMap[pattern[i]] !== words[i]) {\n      return false;\n    }\n    if (wordMap[words[i]] && wordMap[words[i]] !== pattern[i]) {\n      return false;\n    }\n    // Create mappings\n    patternMap[pattern[i]] = words[i];\n    wordMap[words[i]] = pattern[i];\n  }\n}",
      "action": "continue",
      "next": "coding-return-true-ts"
    },
    {
      "stepId": "coding-return-true-ts",
      "mentorSays": "If we finish the loop without finding any conflicts, return true - the string follows the pattern!",
      "example": "function wordPattern(pattern: string, s: string): boolean {\n  const words = s.split(' ');\n  \n  if (pattern.length !== words.length) {\n    return false;\n  }\n  \n  let patternMap: {[key: string]: string} = {};\n  let wordMap: {[key: string]: string} = {};\n  \n  for (let i = 0; i < pattern.length; i++) {\n    if (patternMap[pattern[i]] && patternMap[pattern[i]] !== words[i]) {\n      return false;\n    }\n    if (wordMap[words[i]] && wordMap[words[i]] !== pattern[i]) {\n      return false;\n    }\n    patternMap[pattern[i]] = words[i];\n    wordMap[words[i]] = pattern[i];\n  }\n  \n  // All mappings are consistent\n  return true;\n}",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\npattern = \"abba\", s = \"dog cat cat dog\"\n\nExpected output: true\n\nTry it in your IDE or code editor!",
      "example": "Test input:\npattern = \"abba\"\ns = \"dog cat cat dog\"\n\nExpected output: true\n\nBecause all mappings are consistent.",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "final",
      "mentorSays": "🎉 Well done! You've learned to think through the Word Pattern problem. You understand what the problem asks for, how to use hash maps to track pattern-to-word mappings, and how to check bidirectional consistency.\n\nThis kind of thinking—using hash maps to track mappings—is essential for solving many string problems. Keep practicing!",
      "action": "continue"
    }
  ]
}