{
  "id": "binary-search",
  "title": "Binary Search",
  "pattern": "binary-search (core)",
  "difficulty": "easy",
  "language": "javascript",
  "status": "PERFECT",
  "standardsVersion": "lessonStandards.v1",
  "curriculum": {
    "lessonOrderTag": "FOUNDATION-03",
    "introduces": ["binary-search-loop", "search-space-halving"],
    "assumesAlreadyTaught": [
      "variables",
      "arrays",
      "indexes",
      "loops",
      "functions",
      "return",
      "comparison",
      "midpoint"
    ]
  },
  "pseudocode": [
    { "id": "ps1", "text": "Set left = 0 and right = last index." },
    { "id": "ps2", "text": "While left <= right:" },
    { "id": "ps3", "text": "  Compute mid index." },
    { "id": "ps4", "text": "  If nums[mid] equals target, return mid." },
    { "id": "ps5", "text": "  If nums[mid] < target, move left to mid + 1." },
    { "id": "ps6", "text": "  Else move right to mid - 1." },
    { "id": "ps7", "text": "If loop ends, target is not present; return -1." }
  ],
  "flow": [
    {
      "stepId": "lesson-start",
      "mentorSays": "You selected **Binary Search**.\n\nThis lesson teaches the **core searching technique** used throughout many algorithms.\n\nWe assume you are comfortable with arrays, indexes, and loops.",
      "action": "next",
      "next": "problem-statement"
    },
    {
      "stepId": "problem-statement",
      "mentorSays": "### Problem\nYou are given a **sorted** array of numbers and a target value.\n\nYour task is to return the **index** of the target if it exists.\nIf it does not exist, return **-1**.",
      "example": "nums = [1,3,5,7,9], target = 5",
      "action": "next",
      "next": "tiny-examples"
    },
    {
      "stepId": "tiny-examples",
      "mentorSays": "Tiny examples:\n\n1) nums = [1,3,5,7,9], target = 5 → index 2\n2) nums = [1,3,5,7,9], target = 6 → -1",
      "action": "next",
      "next": "why-not-linear"
    },
    {
      "stepId": "why-not-linear",
      "mentorSays": "A simple loop could check every element.\n\nBut because the array is **sorted**, we can do better than checking one-by-one.",
      "action": "next",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Thinking challenge:\n\nIf the array has 1,000,000 elements, how can we reduce the number of checks quickly?",
      "choices": [
        { "label": "Ignore half the numbers each time", "next": "core-idea" },
        { "label": "Start from the beginning", "next": "core-idea" }
      ]
    },
    {
      "stepId": "core-idea",
      "mentorSays": "Correct.\n\nBinary search works by **halving the search space** on each step.\n\nWe repeatedly look at the middle element and decide which half can be ignored.",
      "action": "next",
      "next": "midpoint-recap"
    },
    {
      "stepId": "midpoint-recap",
      "mentorSays": "### Midpoint recap\n\nIf left = 0 and right = 4:\n\nmid = floor((0 + 4) / 2) = 2\n\n`nums[2]` is the middle element.",
      "action": "next",
      "next": "walkthrough-mini"
    },
    {
      "stepId": "walkthrough-mini",
      "mentorSays": "Mini walkthrough:\n\nnums = [1,3,5,7,9], target = 7\n\n- left=0, right=4\n- mid=2 → nums[2]=5 (too small)\n- move left to 3\n- mid=3 → nums[3]=7 → found",
      "action": "next",
      "next": "pseudocode-step"
    },
    {
      "stepId": "pseudocode-step",
      "mentorSays": "### Pseudocode (logic plan)\nEach coding step maps to this plan.",
      "pseudocodeLineIds": ["ps1", "ps2", "ps3", "ps4", "ps5", "ps6", "ps7"],
      "action": "next",
      "next": "coding-intro"
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now we write JavaScript.\n\nRemember: type the code yourself for learning retention.",
      "action": "next",
      "next": "code-01-function",
      "pseudocodeLineIds": ["ps1"]
    },
    {
      "stepId": "code-01-function",
      "mentorSays": "Step 1: Create the function.",
      "example": "function binarySearch(nums, target) {\n\n}",
      "action": "next",
      "next": "code-02-pointers",
      "pseudocodeLineIds": ["ps1"]
    },
    {
      "stepId": "code-02-pointers",
      "mentorSays": "Step 2: Initialize left and right pointers.",
      "example": "function binarySearch(nums, target) {\n  let left = 0;\n  let right = nums.length - 1;\n\n}",
      "action": "next",
      "next": "code-03-loop",
      "pseudocodeLineIds": ["ps2"]
    },
    {
      "stepId": "code-03-loop",
      "mentorSays": "Step 3: Loop while left <= right.",
      "example": "while (left <= right) {\n\n}",
      "action": "next",
      "next": "loop-invariant"
    },
    {
      "stepId": "loop-invariant",
      "mentorSays": "### Loop Invariant (Interview-Grade Explanation)\n\n**The invariant:** Throughout the loop, if the target exists in the array, it must be within the range `[left, right]`.\n\n**Why this matters:**\n- At start: `left = 0`, `right = length - 1` → target is in `[0, length-1]` ✓\n- Each iteration: We narrow the range, but the invariant holds\n- When `left > right`: The range is empty, target doesn't exist\n\n**This is why we use `left <= right`:**\n- When `left == right`, there's still one element to check\n- Only when `left > right` is the range truly empty\n\n**Interview tip:** Stating the invariant shows deep understanding of the algorithm!",
      "action": "next",
      "next": "code-04-mid",
      "pseudocodeLineIds": ["ps2", "ps3"]
    },
    {
      "stepId": "code-04-mid",
      "mentorSays": "Step 4: Compute the midpoint.",
      "example": "const mid = Math.floor((left + right) / 2);",
      "action": "next",
      "next": "code-05-compare",
      "pseudocodeLineIds": ["ps3"]
    },
    {
      "stepId": "code-05-compare",
      "mentorSays": "Step 5: Compare middle value with target and adjust pointers.",
      "example": "if (nums[mid] === target) return mid;\nif (nums[mid] < target) left = mid + 1;\nelse right = mid - 1;",
      "action": "next",
      "next": "code-06-not-found",
      "pseudocodeLineIds": ["ps4", "ps5", "ps6"]
    },
    {
      "stepId": "code-06-not-found",
      "mentorSays": "Step 6: If the loop ends, the target is not present.",
      "example": "return -1;",
      "action": "next",
      "next": "final-code",
      "pseudocodeLineIds": ["ps7"]
    },
    {
      "stepId": "final-code",
      "mentorSays": "### Final JavaScript code",
      "example": "function binarySearch(nums, target) {\n  let left = 0;\n  let right = nums.length - 1;\n\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n\n    if (nums[mid] === target) return mid;\n    if (nums[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n\n  return -1;\n}",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "common-mistakes",
      "mentorSays": "### Common Mistakes\n\n1. **Wrong loop condition** - Use `left <= right` not `left < right` (need to check when they're equal)\n2. **Off-by-one in pointer updates** - Use `mid + 1` and `mid - 1`, not `mid` (avoid infinite loop)\n3. **Integer overflow** - Use `Math.floor((left + right) / 2)` or `left + Math.floor((right - left) / 2)`\n4. **Forgetting array is sorted** - Binary search only works on sorted arrays!\n5. **Returning wrong value** - Return `mid` when found, `-1` when not found",
      "action": "next",
      "next": "interview-talk-track"
    },
    {
      "stepId": "interview-talk-track",
      "mentorSays": "### Interview Talk Track (30 seconds)\n\n**How to explain this solution in an interview:**\n\n1. **\"I maintain the invariant that if target exists, it's within [left, right]\"**\n2. **\"I calculate the midpoint and compare with target\"**\n3. **\"If target is smaller, I search the left half by setting right = mid - 1\"**\n4. **\"If target is larger, I search the right half by setting left = mid + 1\"**\n5. **\"This halves the search space each iteration, giving O(log n) time complexity\"**",
      "action": "next",
      "next": "wrap-up"
    },
    {
      "stepId": "wrap-up",
      "mentorSays": "Wrap-up:\n\nYou learned:\n- how binary search halves the search space\n- why sorted arrays are critical\n- the loop invariant: target is within [left, right]\n- how this pattern appears in many future problems\n\nNext lessons will reuse this exact structure.\n\n**Follow-up variant:**\n\n**Search Insert Position:** Given a sorted array and a target, return the index where target should be inserted. How would you modify the binary search?",
      "action": "complete"
    }
  ]
}
