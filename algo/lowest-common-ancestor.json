{
  "id": "lowest-common-ancestor",
  "title": "Lowest Common Ancestor of a Binary Tree",
  "pattern": "tree",
  "difficulty": "medium",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what Lowest Common Ancestor asks for\n2. Use recursion to find LCA in a binary tree\n3. Handle cases where one node is ancestor of the other\n4. Return the LCA node efficiently\n5. Implement the solution step by step in your chosen language",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Perfect! Now let's understand what Lowest Common Ancestor is asking.\n\n**Problem Definition:**\nGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\nThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\n\n**Key Observations:**\n- LCA is the deepest node that is an ancestor of both p and q\n- If one node is ancestor of the other, that node is the LCA\n- We need to search both left and right subtrees\n- Use recursion to traverse the tree\n\n**Example 1:** root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n\nTree structure:\n        3\n       / \\\n      5   1\n     / \\ / \\\n    6  2 0  8\n      / \\\n     7   4\n\nFind LCA of nodes 5 and 1:\n- Node 5 is in left subtree of 3\n- Node 1 is in right subtree of 3\n- Node 3 is the LCA (lowest node containing both)\n\nAnswer: 3\n\n**Example 2:** p = 5, q = 4\n\nFind LCA of nodes 5 and 4:\n- Node 5 is ancestor of node 4 (4 is in 5's subtree)\n- Node 5 is the LCA\n\nAnswer: 5\n\n**Step-by-step trace (Recursive approach):**\n\nFor root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1:\n\n- **lowestCommonAncestor(3, 5, 1)**:\n  - root = 3, not null, not p or q\n  - Search left: lowestCommonAncestor(5, 5, 1)\n    - root = 5, matches p! Return 5\n  - Search right: lowestCommonAncestor(1, 5, 1)\n    - root = 1, matches q! Return 1\n  - left = 5, right = 1, both non-null\n  - Return root (3) as LCA ✓\n\n**Key Insight:**\n- If we find p or q, return that node (it might be LCA or p/q is above it)\n- If both left and right return non-null, current node is LCA\n- If only one side returns non-null, LCA is in that subtree\n- O(n) time, O(h) space where h is height\n\n**What makes this tricky:**\n1. Understanding that finding p or q means we might have found LCA\n2. Handling case where one node is ancestor of the other\n3. Knowing when both subtrees return non-null = current is LCA\n4. Base cases: null node or node matches p/q\n\n**Common pitfalls:**\n- Not handling the case where p or q is the LCA\n- Confusing when to return the current node vs child\n- Not checking if both left and right are non-null\n- Forgetting base case for null node",
      "example": "Example 1:\nTree: [3,5,1,6,2,0,8,null,null,7,4]\np=5, q=1 → LCA=3\n\nExample 2:\np=5, q=4 → LCA=5 (5 is ancestor of 4)\n\nExample 3:\nTree: [1,2]\np=1, q=2 → LCA=1",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "How would you find the lowest common ancestor?",
      "choices": [
        {
          "label": "Use recursion - search both subtrees",
          "next": "explore-recursion"
        },
        {
          "label": "Find paths to both nodes, then compare",
          "next": "explore-path"
        },
        {
          "label": "Use parent pointers",
          "next": "explore-parent"
        }
      ]
    },
    {
      "stepId": "explore-path",
      "mentorSays": "That works! Find paths from root to p and q, then find the last common node. However, this requires storing paths and is more complex. Recursion is simpler!",
      "action": "continue",
      "next": "explore-recursion"
    },
    {
      "stepId": "explore-parent",
      "mentorSays": "Good idea if we had parent pointers! But in this problem, we only have child pointers. Recursion is the optimal approach.",
      "action": "continue",
      "next": "explore-recursion"
    },
    {
      "stepId": "explore-recursion",
      "mentorSays": "Excellent! Recursion is optimal. Algorithm:\n1. Base case: if root is null or matches p/q, return root\n2. Search left subtree recursively\n3. Search right subtree recursively\n4. If both return non-null, root is LCA\n5. Otherwise, return the non-null child (or null)",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Which language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "variable-check-js"
        },
        {
          "label": "Python",
          "next": "variable-check-python"
        },
        {
          "label": "Java",
          "next": "variable-check-java"
        },
        {
          "label": "C++",
          "next": "variable-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "variable-check-ts"
        }
      ]
    },
    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-js"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-js"
        }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "let left = null;",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Do you know what a function is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-js"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-js"
        }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code.",
      "example": "function lowestCommonAncestor(root, p, q) {}",
      "action": "continue",
      "next": "parameter-check-js"
    },
    {
      "stepId": "parameter-check-js",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-js"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-js"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-js",
      "mentorSays": "Parameters are inputs to a function.",
      "example": "",
      "action": "continue",
      "next": "tree-check-js"
    },
    {
      "stepId": "tree-check-js",
      "mentorSays": "Do you know how to work with tree?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "recursion-check-js"
        },
        {
          "label": "No, explain",
          "next": "tree-explanation-js"
        }
      ]
    },
    {
      "stepId": "tree-explanation-js",
      "mentorSays": "A binary tree has nodes with left and right children. We traverse using root.left and root.right.",
      "example": "root.left  // Left child\nroot.right  // Right child\nroot.val    // Node value",
      "action": "continue",
      "next": "recursion-check-js"
    },
    {
      "stepId": "recursion-check-js",
      "mentorSays": "Do you know what recursion is?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "coding-start-js"
        },
        {
          "label": "No, explain",
          "next": "recursion-explanation-js"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-js",
      "mentorSays": "Recursion is when a function calls itself. We'll search left and right subtrees recursively.",
      "example": "function search(node) {\n  if (!node) return null;\n  return search(node.left);  // Recursive call\n}",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Implement LCA in JS.",
      "example": "function lowestCommonAncestor(root, p, q) {}",
      "action": "continue",
      "next": "coding-base-case-js"
    },
    {
      "stepId": "coding-base-case-js",
      "mentorSays": "Add base case: if root is null or matches p/q, return root.",
      "example": "function lowestCommonAncestor(root, p, q) {\n  if (!root || root === p || root === q) return root;",
      "action": "continue",
      "next": "coding-search-left-js"
    },
    {
      "stepId": "coding-search-left-js",
      "mentorSays": "Search left subtree recursively.",
      "example": "function lowestCommonAncestor(root, p, q) {\n  if (!root || root === p || root === q) return root;\n  let left = lowestCommonAncestor(root.left, p, q);",
      "action": "continue",
      "next": "coding-search-right-js"
    },
    {
      "stepId": "coding-search-right-js",
      "mentorSays": "Search right subtree recursively.",
      "example": "function lowestCommonAncestor(root, p, q) {\n  if (!root || root === p || root === q) return root;\n  let left = lowestCommonAncestor(root.left, p, q);\n  let right = lowestCommonAncestor(root.right, p, q);",
      "action": "continue",
      "next": "coding-both-found-js"
    },
    {
      "stepId": "coding-both-found-js",
      "mentorSays": "If both left and right are non-null, root is LCA.",
      "example": "function lowestCommonAncestor(root, p, q) {\n  if (!root || root === p || root === q) return root;\n  let left = lowestCommonAncestor(root.left, p, q);\n  let right = lowestCommonAncestor(root.right, p, q);\n  if (left && right) return root;",
      "action": "continue",
      "next": "coding-return-result-js"
    },
    {
      "stepId": "coding-return-result-js",
      "mentorSays": "Return non-null child (or null if both are null).",
      "example": "function lowestCommonAncestor(root, p, q) {\n  if (!root || root === p || root === q) return root;\n  let left = lowestCommonAncestor(root.left, p, q);\n  let right = lowestCommonAncestor(root.right, p, q);\n  if (left && right) return root;\n  return left || right;\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Test cases:\n1. root=[3,5,1,6,2,0,8,null,null,7,4], p=5, q=1 → 3\n2. p=5, q=4 → 5\n3. root=[1,2], p=1, q=2 → 1\n4. root=[2,1,3], p=1, q=3 → 2\n5. Deep tree test\n6. Edge cases",
      "example": "",
      "action": "continue",
      "next": "variable-check-python"
    },
    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Python?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-python"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-python"
        }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "left = None",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Do you know what a function is in Python?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-python"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-python"
        }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function is a reusable block of code.",
      "example": "def lowestCommonAncestor(root, p, q):",
      "action": "continue",
      "next": "parameter-check-python"
    },
    {
      "stepId": "parameter-check-python",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-python"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-python"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-python",
      "mentorSays": "Parameters are inputs to a function.",
      "example": "",
      "action": "continue",
      "next": "tree-check-python"
    },
    {
      "stepId": "tree-check-python",
      "mentorSays": "Do you know how to work with tree?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "recursion-check-python"
        },
        {
          "label": "No, explain",
          "next": "tree-explanation-python"
        }
      ]
    },
    {
      "stepId": "tree-explanation-python",
      "mentorSays": "A binary tree has nodes with left and right children. We traverse using root.left and root.right.",
      "example": "root.left  # Left child\nroot.right  # Right child\nroot.val    # Node value",
      "action": "continue",
      "next": "recursion-check-python"
    },
    {
      "stepId": "recursion-check-python",
      "mentorSays": "Do you know what recursion is?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "coding-start-python"
        },
        {
          "label": "No, explain",
          "next": "recursion-explanation-python"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-python",
      "mentorSays": "Recursion is when a function calls itself. We'll search left and right subtrees recursively.",
      "example": "def search(node):\n    if not node:\n        return None\n    return search(node.left)  # Recursive call",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Implement LCA in PYTHON.",
      "example": "def lowestCommonAncestor(root, p, q):",
      "action": "continue",
      "next": "coding-base-case-python"
    },
    {
      "stepId": "coding-base-case-python",
      "mentorSays": "Add base case: if root is null or matches p/q, return root.",
      "example": "def lowestCommonAncestor(root, p, q):\n    if not root or root == p or root == q:\n        return root",
      "action": "continue",
      "next": "coding-search-left-python"
    },
    {
      "stepId": "coding-search-left-python",
      "mentorSays": "Search left subtree recursively.",
      "example": "def lowestCommonAncestor(root, p, q):\n    if not root or root == p or root == q:\n        return root\n    left = lowestCommonAncestor(root.left, p, q)",
      "action": "continue",
      "next": "coding-search-right-python"
    },
    {
      "stepId": "coding-search-right-python",
      "mentorSays": "Search right subtree recursively.",
      "example": "def lowestCommonAncestor(root, p, q):\n    if not root or root == p or root == q:\n        return root\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)",
      "action": "continue",
      "next": "coding-both-found-python"
    },
    {
      "stepId": "coding-both-found-python",
      "mentorSays": "If both left and right are non-null, root is LCA.",
      "example": "def lowestCommonAncestor(root, p, q):\n    if not root or root == p or root == q:\n        return root\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n    if left and right:\n        return root",
      "action": "continue",
      "next": "coding-return-result-python"
    },
    {
      "stepId": "coding-return-result-python",
      "mentorSays": "Return non-null child (or null if both are null).",
      "example": "def lowestCommonAncestor(root, p, q):\n    if not root or root == p or root == q:\n        return root\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n    if left and right:\n        return root\n    return left or right",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Test cases:\n1. root=[3,5,1,6,2,0,8,null,null,7,4], p=5, q=1 → 3\n2. p=5, q=4 → 5\n3. root=[1,2], p=1, q=2 → 1\n4. root=[2,1,3], p=1, q=3 → 2\n5. Deep tree test\n6. Edge cases",
      "example": "",
      "action": "continue",
      "next": "variable-check-java"
    },
    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Java?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-java"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-java"
        }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "TreeNode left = null;",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Do you know what a function is in Java?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-java"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-java"
        }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A function is a reusable block of code.",
      "example": "public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {}",
      "action": "continue",
      "next": "parameter-check-java"
    },
    {
      "stepId": "parameter-check-java",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-java"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-java"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-java",
      "mentorSays": "Parameters are inputs to a function.",
      "example": "",
      "action": "continue",
      "next": "tree-check-java"
    },
    {
      "stepId": "tree-check-java",
      "mentorSays": "Do you know how to work with tree?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "recursion-check-java"
        },
        {
          "label": "No, explain",
          "next": "tree-explanation-java"
        }
      ]
    },
    {
      "stepId": "tree-explanation-java",
      "mentorSays": "A binary tree has nodes with left and right children. We traverse using root.left and root.right.",
      "example": "root.left  // Left child\nroot.right  // Right child\nroot.val    // Node value",
      "action": "continue",
      "next": "recursion-check-java"
    },
    {
      "stepId": "recursion-check-java",
      "mentorSays": "Do you know what recursion is?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "coding-start-java"
        },
        {
          "label": "No, explain",
          "next": "recursion-explanation-java"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-java",
      "mentorSays": "Recursion is when a function calls itself. We'll search left and right subtrees recursively.",
      "example": "TreeNode search(TreeNode node) {\n    if (node == null) return null;\n    return search(node.left);  // Recursive call\n}",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Implement LCA in JAVA.",
      "example": "public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {}",
      "action": "continue",
      "next": "coding-base-case-java"
    },
    {
      "stepId": "coding-base-case-java",
      "mentorSays": "Add base case: if root is null or matches p/q, return root.",
      "example": "public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || root == p || root == q) return root;",
      "action": "continue",
      "next": "coding-search-left-java"
    },
    {
      "stepId": "coding-search-left-java",
      "mentorSays": "Search left subtree recursively.",
      "example": "public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || root == p || root == q) return root;\n    TreeNode left = lowestCommonAncestor(root.left, p, q);",
      "action": "continue",
      "next": "coding-search-right-java"
    },
    {
      "stepId": "coding-search-right-java",
      "mentorSays": "Search right subtree recursively.",
      "example": "public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || root == p || root == q) return root;\n    TreeNode left = lowestCommonAncestor(root.left, p, q);\n    TreeNode right = lowestCommonAncestor(root.right, p, q);",
      "action": "continue",
      "next": "coding-both-found-java"
    },
    {
      "stepId": "coding-both-found-java",
      "mentorSays": "If both left and right are non-null, root is LCA.",
      "example": "public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || root == p || root == q) return root;\n    TreeNode left = lowestCommonAncestor(root.left, p, q);\n    TreeNode right = lowestCommonAncestor(root.right, p, q);\n    if (left != null && right != null) return root;",
      "action": "continue",
      "next": "coding-return-result-java"
    },
    {
      "stepId": "coding-return-result-java",
      "mentorSays": "Return non-null child (or null if both are null).",
      "example": "public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || root == p || root == q) return root;\n    TreeNode left = lowestCommonAncestor(root.left, p, q);\n    TreeNode right = lowestCommonAncestor(root.right, p, q);\n    if (left != null && right != null) return root;\n    return left != null ? left : right;\n}",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Test cases:\n1. root=[3,5,1,6,2,0,8,null,null,7,4], p=5, q=1 → 3\n2. p=5, q=4 → 5\n3. root=[1,2], p=1, q=2 → 1\n4. root=[2,1,3], p=1, q=3 → 2\n5. Deep tree test\n6. Edge cases",
      "example": "",
      "action": "continue",
      "next": "variable-check-cpp"
    },
    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in C++?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-cpp"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "TreeNode* left = nullptr;",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Do you know what a function is in C++?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-cpp"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function is a reusable block of code.",
      "example": "TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {}",
      "action": "continue",
      "next": "parameter-check-cpp"
    },
    {
      "stepId": "parameter-check-cpp",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-cpp"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-cpp",
      "mentorSays": "Parameters are inputs to a function.",
      "example": "",
      "action": "continue",
      "next": "tree-check-cpp"
    },
    {
      "stepId": "tree-check-cpp",
      "mentorSays": "Do you know how to work with tree?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "recursion-check-cpp"
        },
        {
          "label": "No, explain",
          "next": "tree-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "tree-explanation-cpp",
      "mentorSays": "A binary tree has nodes with left and right children. We traverse using root.left and root.right.",
      "example": "root->left  // Left child\nroot->right  // Right child\nroot->val    // Node value",
      "action": "continue",
      "next": "recursion-check-cpp"
    },
    {
      "stepId": "recursion-check-cpp",
      "mentorSays": "Do you know what recursion is?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "coding-start-cpp"
        },
        {
          "label": "No, explain",
          "next": "recursion-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-cpp",
      "mentorSays": "Recursion is when a function calls itself. We'll search left and right subtrees recursively.",
      "example": "TreeNode* search(TreeNode* node) {\n    if (!node) return nullptr;\n    return search(node->left);  // Recursive call\n}",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Implement LCA in CPP.",
      "example": "TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {}",
      "action": "continue",
      "next": "coding-base-case-cpp"
    },
    {
      "stepId": "coding-base-case-cpp",
      "mentorSays": "Add base case: if root is null or matches p/q, return root.",
      "example": "TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (!root || root == p || root == q) return root;",
      "action": "continue",
      "next": "coding-search-left-cpp"
    },
    {
      "stepId": "coding-search-left-cpp",
      "mentorSays": "Search left subtree recursively.",
      "example": "TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (!root || root == p || root == q) return root;\n    TreeNode* left = lowestCommonAncestor(root->left, p, q);",
      "action": "continue",
      "next": "coding-search-right-cpp"
    },
    {
      "stepId": "coding-search-right-cpp",
      "mentorSays": "Search right subtree recursively.",
      "example": "TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (!root || root == p || root == q) return root;\n    TreeNode* left = lowestCommonAncestor(root->left, p, q);\n    TreeNode* right = lowestCommonAncestor(root->right, p, q);",
      "action": "continue",
      "next": "coding-both-found-cpp"
    },
    {
      "stepId": "coding-both-found-cpp",
      "mentorSays": "If both left and right are non-null, root is LCA.",
      "example": "TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (!root || root == p || root == q) return root;\n    TreeNode* left = lowestCommonAncestor(root->left, p, q);\n    TreeNode* right = lowestCommonAncestor(root->right, p, q);\n    if (left && right) return root;",
      "action": "continue",
      "next": "coding-return-result-cpp"
    },
    {
      "stepId": "coding-return-result-cpp",
      "mentorSays": "Return non-null child (or null if both are null).",
      "example": "TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (!root || root == p || root == q) return root;\n    TreeNode* left = lowestCommonAncestor(root->left, p, q);\n    TreeNode* right = lowestCommonAncestor(root->right, p, q);\n    if (left && right) return root;\n    return left ? left : right;\n}",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Test cases:\n1. root=[3,5,1,6,2,0,8,null,null,7,4], p=5, q=1 → 3\n2. p=5, q=4 → 5\n3. root=[1,2], p=1, q=2 → 1\n4. root=[2,1,3], p=1, q=3 → 2\n5. Deep tree test\n6. Edge cases",
      "example": "",
      "action": "continue",
      "next": "variable-check-ts"
    },
    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-ts"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-ts"
        }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable is like a labeled box where you can store a value.",
      "example": "let left: TreeNode | null = null;",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Do you know what a function is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-ts"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-ts"
        }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function is a reusable block of code.",
      "example": "function lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {}",
      "action": "continue",
      "next": "parameter-check-ts"
    },
    {
      "stepId": "parameter-check-ts",
      "mentorSays": "Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-ts"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-ts"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-ts",
      "mentorSays": "Parameters are inputs to a function.",
      "example": "",
      "action": "continue",
      "next": "tree-check-ts"
    },
    {
      "stepId": "tree-check-ts",
      "mentorSays": "Do you know how to work with tree?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "recursion-check-ts"
        },
        {
          "label": "No, explain",
          "next": "tree-explanation-ts"
        }
      ]
    },
    {
      "stepId": "tree-explanation-ts",
      "mentorSays": "A binary tree has nodes with left and right children. We traverse using root.left and root.right.",
      "example": "root.left  // Left child\nroot.right  // Right child\nroot.val    // Node value",
      "action": "continue",
      "next": "recursion-check-ts"
    },
    {
      "stepId": "recursion-check-ts",
      "mentorSays": "Do you know what recursion is?",
      "choices": [
        {
          "label": "Yes, I know",
          "next": "coding-start-ts"
        },
        {
          "label": "No, explain",
          "next": "recursion-explanation-ts"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-ts",
      "mentorSays": "Recursion is when a function calls itself. We'll search left and right subtrees recursively.",
      "example": "function search(node: TreeNode | null): TreeNode | null {\n    if (!node) return null;\n    return search(node.left);  // Recursive call\n}",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Implement LCA in TS.",
      "example": "function lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {}",
      "action": "continue",
      "next": "coding-base-case-ts"
    },
    {
      "stepId": "coding-base-case-ts",
      "mentorSays": "Add base case: if root is null or matches p/q, return root.",
      "example": "function lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\n    if (!root || root === p || root === q) return root;",
      "action": "continue",
      "next": "coding-search-left-ts"
    },
    {
      "stepId": "coding-search-left-ts",
      "mentorSays": "Search left subtree recursively.",
      "example": "function lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\n    if (!root || root === p || root === q) return root;\n    let left = lowestCommonAncestor(root.left, p, q);",
      "action": "continue",
      "next": "coding-search-right-ts"
    },
    {
      "stepId": "coding-search-right-ts",
      "mentorSays": "Search right subtree recursively.",
      "example": "function lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\n    if (!root || root === p || root === q) return root;\n    let left = lowestCommonAncestor(root.left, p, q);\n    let right = lowestCommonAncestor(root.right, p, q);",
      "action": "continue",
      "next": "coding-both-found-ts"
    },
    {
      "stepId": "coding-both-found-ts",
      "mentorSays": "If both left and right are non-null, root is LCA.",
      "example": "function lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\n    if (!root || root === p || root === q) return root;\n    let left = lowestCommonAncestor(root.left, p, q);\n    let right = lowestCommonAncestor(root.right, p, q);\n    if (left && right) return root;",
      "action": "continue",
      "next": "coding-return-result-ts"
    },
    {
      "stepId": "coding-return-result-ts",
      "mentorSays": "Return non-null child (or null if both are null).",
      "example": "function lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\n    if (!root || root === p || root === q) return root;\n    let left = lowestCommonAncestor(root.left, p, q);\n    let right = lowestCommonAncestor(root.right, p, q);\n    if (left && right) return root;\n    return left || right;\n}",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Test cases:\n1. root=[3,5,1,6,2,0,8,null,null,7,4], p=5, q=1 → 3\n2. p=5, q=4 → 5\n3. root=[1,2], p=1, q=2 → 1\n4. root=[2,1,3], p=1, q=3 → 2\n5. Deep tree test\n6. Edge cases",
      "example": "",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "final",
      "mentorSays": "Time: O(n), Space: O(h) where h is height. Recursive approach finds LCA efficiently.\n\nRelated Problems:\n- Lowest Common Ancestor of a BST\n- Find Distance in Binary Tree\n- Binary Tree Maximum Path Sum",
      "action": "continue"
    }
  ]
}