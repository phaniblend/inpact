{
  "id": "same-tree",
  "title": "Same Tree",
  "pattern": "tree",
  "difficulty": "easy",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what the Same Tree problem asks for\n2. Use recursion to compare two binary trees\n3. Check if trees have the same structure and values\n4. Handle base cases (null nodes)\n5. Implement the solution step by step in your chosen language",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Perfect! Now let's understand what the Same Tree problem is asking.\n\n**Problem Definition:**\nGiven the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\n**Key Observations:**\n- Trees must have the same structure (same shape)\n- Corresponding nodes must have the same values\n- Both trees being null is considered the same\n- One null and one non-null is different\n\n**Example 1:**\nTree p:\n    1\n   / \\\n  2   3\n\nTree q:\n    1\n   / \\\n  2   3\n\nBoth trees are identical in structure and values.\nAnswer: true\n\n**Example 2:**\nTree p:\n    1\n   /\n  2\n\nTree q:\n    1\n     \\\n      2\n\nDifferent structure (left child vs right child).\nAnswer: false\n\n**Example 3:**\nTree p:\n    1\n   / \\\n  2   1\n\nTree q:\n    1\n   / \\\n  1   2\n\nSame structure but different values at positions.\nAnswer: false\n\n**Step-by-step trace for Example 1 (Recursive approach):**\n\nTree p:      Tree q:\n    1           1\n   / \\         / \\\n  2   3       2   3\n\nWe'll use recursion:\n- **isSameTree(p=1, q=1)**:\n  - Both not null âœ“\n  - Values equal (1 == 1) âœ“\n  - Check left subtrees: isSameTree(p.left=2, q.left=2)\n  - Check right subtrees: isSameTree(p.right=3, q.right=3)\n  - Return true && true = true âœ“\n\n- **isSameTree(p=2, q=2)**:\n  - Both not null âœ“\n  - Values equal (2 == 2) âœ“\n  - Left: isSameTree(null, null) = true\n  - Right: isSameTree(null, null) = true\n  - Return true && true = true\n\n- **isSameTree(p=3, q=3)**:\n  - Both not null âœ“\n  - Values equal (3 == 3) âœ“\n  - Left: isSameTree(null, null) = true\n  - Right: isSameTree(null, null) = true\n  - Return true && true = true\n\n- **isSameTree(null, null)**:\n  - Both null, return true (base case)\n\n**Key Insight:**\nTwo trees are the same if:\n1. Both roots are null (base case: return true)\n2. One is null, one is not (return false)\n3. Both have same value AND left subtrees are same AND right subtrees are same\n\n**What makes this tricky:**\n1. Handling null cases correctly\n2. Recursive thinking: trees are same if roots match AND subtrees match\n3. Understanding that structure and values must both match\n4. The base case: two null nodes are considered the same\n\n**Common pitfalls:**\n- Not handling null cases correctly\n- Only checking values without checking structure\n- Not checking both left and right subtrees\n- Returning false when both are null (should return true)",
      "example": "Example 1:\nTree p:      Tree q:\n    1           1\n   / \\         / \\\n  2   3       2   3\n\nSame: true\n\nExample 2:\nTree p:      Tree q:\n    1           1\n   /             \\\n  2               2\n\nSame: false (different structure)\n\nExample 3:\nTree p:      Tree q:\n    1           1\n   / \\         / \\\n  2   1       1   2\n\nSame: false (different values)",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Now that you understand what the problem wants, here's the real question:\n\nHow would YOU check if two binary trees are the same?\n\nThink about it for a moment. What approach feels natural to you?",
      "choices": [
        {
          "label": "Use recursion - check roots match, then recursively check subtrees",
          "next": "explore-recursive"
        },
        {
          "label": "Traverse both trees and compare node by node",
          "next": "explore-traversal"
        },
        {
          "label": "Convert both trees to arrays and compare arrays",
          "next": "explore-convert"
        }
      ]
    },
    {
      "stepId": "explore-traversal",
      "mentorSays": "That's a good approach! You're thinking: \"I'll traverse both trees (e.g., preorder) and compare the sequences.\"\n\nThis works! However, you need to handle null nodes in the traversal, and it requires storing the traversal results.\n\nThere's a more direct recursive approach that compares trees node-by-node without storing anything. Would you like to learn that?",
      "action": "continue",
      "next": "explore-recursive"
    },
    {
      "stepId": "explore-convert",
      "mentorSays": "That's a creative approach! You're thinking: \"I'll convert both trees to arrays and compare the arrays.\"\n\nThis works, but it uses extra space and is more complex than needed.\n\nThere's a simpler recursive approach that compares trees directly. Would you like to learn that?",
      "action": "continue",
      "next": "explore-recursive"
    },
    {
      "stepId": "explore-recursive",
      "mentorSays": "Excellent choice! Recursion is perfect for this problem. Here's the core idea:\n\n**The Algorithm:**\n1. **Base case 1**: If both p and q are null, return true (two empty trees are the same)\n2. **Base case 2**: If one is null and the other is not, return false (different structure)\n3. **Value check**: If p.val != q.val, return false (different values)\n4. **Recursive check**: Return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n\n**Why it works**:\n- We check if the roots match (both null, or both have same value)\n- We recursively check if left subtrees match\n- We recursively check if right subtrees match\n- All three conditions must be true for trees to be the same\n\n**Key insight**: Two trees are the same if their roots match AND their left subtrees match AND their right subtrees match!\n\nLet's trace with p = [1,2,3], q = [1,2,3]:\n\n- **isSameTree(1, 1)**:\n  - Both not null âœ“\n  - Values equal (1 == 1) âœ“\n  - Left: isSameTree(2, 2) = true\n  - Right: isSameTree(3, 3) = true\n  - Return true && true = true âœ“\n\n- **isSameTree(2, 2)**:\n  - Both not null âœ“\n  - Values equal âœ“\n  - Left: isSameTree(null, null) = true\n  - Right: isSameTree(null, null) = true\n  - Return true\n\n- **isSameTree(null, null)**:\n  - Both null, return true (base case)\n\nThis is O(n) time (visit each node once) and O(h) space (recursion stack)! Now let's code it step by step.",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Great! Now let's code this solution. Which programming language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "variable-check-js"
        },
        {
          "label": "Python",
          "next": "variable-check-python"
        },
        {
          "label": "Java",
          "next": "variable-check-java"
        },
        {
          "label": "C++",
          "next": "variable-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "variable-check-ts"
        }
      ]
    },
    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-js"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-js"
        }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'p' or 'q') and put data inside it.",
      "example": "let p = root1;  // First tree root\nlet q = root2;  // Second tree root",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-js"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-js"
        }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function isSameTree(p, q) {\n  // Returns true if trees are same\n  return false;\n}",
      "action": "continue",
      "next": "parameter-check-js"
    },
    {
      "stepId": "parameter-check-js",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-js"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-js"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-js",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function isSameTree(p, q)', the 'p' and 'q' are parameters that receive the root nodes of the two trees.",
      "example": "function isSameTree(p, q) {\n  // Parameters receive root nodes\n}\n\n// Call: isSameTree(root1, root2)",
      "action": "continue",
      "next": "tree-check-js"
    },
    {
      "stepId": "tree-check-js",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-js"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-js"
        }
      ]
    },
    {
      "stepId": "tree-explanation-js",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.\n\nFor example, a tree:\n    1\n   / \\\n  2   3\n\nNode 1 has value 1, left child 2, and right child 3.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// Example tree:\n//     1\n//    / \\\n//   2   3",
      "action": "continue",
      "next": "recursion-check-js"
    },
    {
      "stepId": "recursion-check-js",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-js"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-js"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-js",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees\n\nFor example, to check if two trees are the same, we check if roots match, then recursively check if left subtrees match and right subtrees match.",
      "example": "function isSameTree(p, q) {\n  // Base case: both null\n  if (p === null && q === null) return true;\n  \n  // Recursive case: check roots and subtrees\n  return p.val === q.val && \n         isSameTree(p.left, q.left) &&  // Recursive call!\n         isSameTree(p.right, q.right); // Recursive call!\n}",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Perfect! Let's implement the same tree solution in JavaScript. We'll create a function that takes two tree roots and returns true if they are the same.",
      "example": "function isSameTree(p, q) {\n  \n}",
      "action": "continue",
      "next": "coding-base-case-both-null-js"
    },
    {
      "stepId": "coding-base-case-both-null-js",
      "mentorSays": "First, handle the base case: if both p and q are null, return true (two empty trees are the same).",
      "example": "function isSameTree(p, q) {\n  // Base case: both null means trees are the same\n  if (p === null && q === null) {\n    return true;\n  }\n  \n}",
      "action": "continue",
      "next": "coding-base-case-one-null-js"
    },
    {
      "stepId": "coding-base-case-one-null-js",
      "mentorSays": "Handle the case where one is null and the other is not. This means different structure, return false.",
      "example": "function isSameTree(p, q) {\n  if (p === null && q === null) {\n    return true;\n  }\n  \n  // If one is null and the other is not, trees are different\n  if (p === null || q === null) {\n    return false;\n  }\n  \n}",
      "action": "continue",
      "next": "coding-check-values-js"
    },
    {
      "stepId": "coding-check-values-js",
      "mentorSays": "Check if the values of the current nodes match. If not, return false.",
      "example": "function isSameTree(p, q) {\n  if (p === null && q === null) {\n    return true;\n  }\n  \n  if (p === null || q === null) {\n    return false;\n  }\n  \n  // Check if values match\n  if (p.val !== q.val) {\n    return false;\n  }\n  \n}",
      "action": "continue",
      "next": "coding-recursive-check-js"
    },
    {
      "stepId": "coding-recursive-check-js",
      "mentorSays": "Recursively check if left subtrees match AND right subtrees match. Return the result.",
      "example": "function isSameTree(p, q) {\n  if (p === null && q === null) {\n    return true;\n  }\n  \n  if (p === null || q === null) {\n    return false;\n  }\n  \n  if (p.val !== q.val) {\n    return false;\n  }\n  \n  // Recursively check left and right subtrees\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** p = [1,2,3], q = [1,2,3]\nExpected: true (identical trees)\n\n**Test 2:** p = [1,2], q = [1,null,2]\nExpected: false (different structure)\n\n**Test 3:** p = [1,2,1], q = [1,1,2]\nExpected: false (different values)\n\n**Test 4:** p = null, q = null\nExpected: true (both empty)\n\n**Test 5:** p = [1], q = [1]\nExpected: true (single node, same)\n\n**Test 6:** p = [1], q = [2]\nExpected: false (single node, different values)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,2,3] vs [1,2,3] â†’ true\nTest 2: [1,2] vs [1,null,2] â†’ false\nTest 3: [1,2,1] vs [1,1,2] â†’ false\nTest 4: null vs null â†’ true\nTest 5: [1] vs [1] â†’ true\nTest 6: [1] vs [2] â†’ false",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Python?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-python"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-python"
        }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'p' or 'q') and put data inside it.",
      "example": " p = root1;  // First tree root\n q = root2;  // Second tree root",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Python?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-python"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-python"
        }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "def isSameTree(p, q) {\n  // Returns true if trees are same\n  return false;\n}",
      "action": "continue",
      "next": "parameter-check-python"
    },
    {
      "stepId": "parameter-check-python",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-python"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-python"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-python",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'def isSameTree(p, q)', the 'p' and 'q' are parameters that receive the root nodes of the two trees.",
      "example": "def isSameTree(p, q) {\n  // Parameters receive root nodes\n}\n\n// Call: isSameTree(root1, root2)",
      "action": "continue",
      "next": "tree-check-python"
    },
    {
      "stepId": "tree-check-python",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-python"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-python"
        }
      ]
    },
    {
      "stepId": "tree-explanation-python",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.\n\nFor example, a tree:\n    1\n   / \\\n  2   3\n\nNode 1 has value 1, left child 2, and right child 3.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// Example tree:\n//     1\n//    / \\\n//   2   3",
      "action": "continue",
      "next": "recursion-check-python"
    },
    {
      "stepId": "recursion-check-python",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in Python?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-python"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-python"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-python",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees\n\nFor example, to check if two trees are the same, we check if roots match, then recursively check if left subtrees match and right subtrees match.",
      "example": "function isSameTree(p, q) {\n  // Base case: both null\n  if (p === null && q === null) return true;\n  \n  // Recursive case: check roots and subtrees\n  return p.val === q.val && \n         isSameTree(p.left, q.left) &&  // Recursive call!\n         isSameTree(p.right, q.right); // Recursive call!\n}",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Perfect! Let's implement the solution in Python.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-base-case-both-null-python"
    },
    {
      "stepId": "coding-base-case-both-null-python",
      "mentorSays": "Handle base case: both null.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-base-case-one-null-python"
    },
    {
      "stepId": "coding-base-case-one-null-python",
      "mentorSays": "Handle case: one null, one not.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-check-values-python"
    },
    {
      "stepId": "coding-check-values-python",
      "mentorSays": "Check if values match.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-recursive-check-python"
    },
    {
      "stepId": "coding-recursive-check-python",
      "mentorSays": "Recursively check left and right subtrees.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** p = [1,2,3], q = [1,2,3]\nExpected: true (identical trees)\n\n**Test 2:** p = [1,2], q = [1,null,2]\nExpected: false (different structure)\n\n**Test 3:** p = [1,2,1], q = [1,1,2]\nExpected: false (different values)\n\n**Test 4:** p = null, q = null\nExpected: true (both empty)\n\n**Test 5:** p = [1], q = [1]\nExpected: true (single node, same)\n\n**Test 6:** p = [1], q = [2]\nExpected: false (single node, different values)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,2,3] vs [1,2,3] â†’ true\nTest 2: [1,2] vs [1,null,2] â†’ false\nTest 3: [1,2,1] vs [1,1,2] â†’ false\nTest 4: null vs null â†’ true\nTest 5: [1] vs [1] â†’ true\nTest 6: [1] vs [2] â†’ false",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Java?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-java"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-java"
        }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'p' or 'q') and put data inside it.",
      "example": "boolean p = root1;  // First tree root\nboolean q = root2;  // Second tree root",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Java?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-java"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-java"
        }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "public boolean isSameTree(p, q) {\n  // Returns true if trees are same\n  return false;\n}",
      "action": "continue",
      "next": "parameter-check-java"
    },
    {
      "stepId": "parameter-check-java",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-java"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-java"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-java",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'public boolean isSameTree(p, q)', the 'p' and 'q' are parameters that receive the root nodes of the two trees.",
      "example": "public boolean isSameTree(p, q) {\n  // Parameters receive root nodes\n}\n\n// Call: isSameTree(root1, root2)",
      "action": "continue",
      "next": "tree-check-java"
    },
    {
      "stepId": "tree-check-java",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-java"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-java"
        }
      ]
    },
    {
      "stepId": "tree-explanation-java",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.\n\nFor example, a tree:\n    1\n   / \\\n  2   3\n\nNode 1 has value 1, left child 2, and right child 3.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// Example tree:\n//     1\n//    / \\\n//   2   3",
      "action": "continue",
      "next": "recursion-check-java"
    },
    {
      "stepId": "recursion-check-java",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in Java?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-java"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-java"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-java",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees\n\nFor example, to check if two trees are the same, we check if roots match, then recursively check if left subtrees match and right subtrees match.",
      "example": "function isSameTree(p, q) {\n  // Base case: both null\n  if (p === null && q === null) return true;\n  \n  // Recursive case: check roots and subtrees\n  return p.val === q.val && \n         isSameTree(p.left, q.left) &&  // Recursive call!\n         isSameTree(p.right, q.right); // Recursive call!\n}",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Perfect! Let's implement the solution in Java.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-base-case-both-null-java"
    },
    {
      "stepId": "coding-base-case-both-null-java",
      "mentorSays": "Handle base case: both null.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-base-case-one-null-java"
    },
    {
      "stepId": "coding-base-case-one-null-java",
      "mentorSays": "Handle case: one null, one not.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-check-values-java"
    },
    {
      "stepId": "coding-check-values-java",
      "mentorSays": "Check if values match.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-recursive-check-java"
    },
    {
      "stepId": "coding-recursive-check-java",
      "mentorSays": "Recursively check left and right subtrees.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** p = [1,2,3], q = [1,2,3]\nExpected: true (identical trees)\n\n**Test 2:** p = [1,2], q = [1,null,2]\nExpected: false (different structure)\n\n**Test 3:** p = [1,2,1], q = [1,1,2]\nExpected: false (different values)\n\n**Test 4:** p = null, q = null\nExpected: true (both empty)\n\n**Test 5:** p = [1], q = [1]\nExpected: true (single node, same)\n\n**Test 6:** p = [1], q = [2]\nExpected: false (single node, different values)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,2,3] vs [1,2,3] â†’ true\nTest 2: [1,2] vs [1,null,2] â†’ false\nTest 3: [1,2,1] vs [1,1,2] â†’ false\nTest 4: null vs null â†’ true\nTest 5: [1] vs [1] â†’ true\nTest 6: [1] vs [2] â†’ false",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in C++?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-cpp"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'p' or 'q') and put data inside it.",
      "example": "bool p = root1;  // First tree root\nbool q = root2;  // Second tree root",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in C++?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-cpp"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "bool isSameTree(p, q) {\n  // Returns true if trees are same\n  return false;\n}",
      "action": "continue",
      "next": "parameter-check-cpp"
    },
    {
      "stepId": "parameter-check-cpp",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-cpp"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-cpp",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'bool isSameTree(p, q)', the 'p' and 'q' are parameters that receive the root nodes of the two trees.",
      "example": "bool isSameTree(p, q) {\n  // Parameters receive root nodes\n}\n\n// Call: isSameTree(root1, root2)",
      "action": "continue",
      "next": "tree-check-cpp"
    },
    {
      "stepId": "tree-check-cpp",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-cpp"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "tree-explanation-cpp",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.\n\nFor example, a tree:\n    1\n   / \\\n  2   3\n\nNode 1 has value 1, left child 2, and right child 3.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// Example tree:\n//     1\n//    / \\\n//   2   3",
      "action": "continue",
      "next": "recursion-check-cpp"
    },
    {
      "stepId": "recursion-check-cpp",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in C++?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-cpp"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-cpp",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees\n\nFor example, to check if two trees are the same, we check if roots match, then recursively check if left subtrees match and right subtrees match.",
      "example": "function isSameTree(p, q) {\n  // Base case: both null\n  if (p === null && q === null) return true;\n  \n  // Recursive case: check roots and subtrees\n  return p.val === q.val && \n         isSameTree(p.left, q.left) &&  // Recursive call!\n         isSameTree(p.right, q.right); // Recursive call!\n}",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Perfect! Let's implement the solution in C++.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-base-case-both-null-cpp"
    },
    {
      "stepId": "coding-base-case-both-null-cpp",
      "mentorSays": "Handle base case: both null.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-base-case-one-null-cpp"
    },
    {
      "stepId": "coding-base-case-one-null-cpp",
      "mentorSays": "Handle case: one null, one not.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-check-values-cpp"
    },
    {
      "stepId": "coding-check-values-cpp",
      "mentorSays": "Check if values match.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-recursive-check-cpp"
    },
    {
      "stepId": "coding-recursive-check-cpp",
      "mentorSays": "Recursively check left and right subtrees.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** p = [1,2,3], q = [1,2,3]\nExpected: true (identical trees)\n\n**Test 2:** p = [1,2], q = [1,null,2]\nExpected: false (different structure)\n\n**Test 3:** p = [1,2,1], q = [1,1,2]\nExpected: false (different values)\n\n**Test 4:** p = null, q = null\nExpected: true (both empty)\n\n**Test 5:** p = [1], q = [1]\nExpected: true (single node, same)\n\n**Test 6:** p = [1], q = [2]\nExpected: false (single node, different values)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,2,3] vs [1,2,3] â†’ true\nTest 2: [1,2] vs [1,null,2] â†’ false\nTest 3: [1,2,1] vs [1,1,2] â†’ false\nTest 4: null vs null â†’ true\nTest 5: [1] vs [1] â†’ true\nTest 6: [1] vs [2] â†’ false",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-ts"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-ts"
        }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'p' or 'q') and put data inside it.",
      "example": "let p = root1;  // First tree root\nlet q = root2;  // Second tree root",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-ts"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-ts"
        }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function isSameTree(p, q) {\n  // Returns true if trees are same\n  return false;\n}",
      "action": "continue",
      "next": "parameter-check-ts"
    },
    {
      "stepId": "parameter-check-ts",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-ts"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-ts"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-ts",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function isSameTree(p, q)', the 'p' and 'q' are parameters that receive the root nodes of the two trees.",
      "example": "function isSameTree(p, q) {\n  // Parameters receive root nodes\n}\n\n// Call: isSameTree(root1, root2)",
      "action": "continue",
      "next": "tree-check-ts"
    },
    {
      "stepId": "tree-check-ts",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-ts"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-ts"
        }
      ]
    },
    {
      "stepId": "tree-explanation-ts",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.\n\nFor example, a tree:\n    1\n   / \\\n  2   3\n\nNode 1 has value 1, left child 2, and right child 3.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// Example tree:\n//     1\n//    / \\\n//   2   3",
      "action": "continue",
      "next": "recursion-check-ts"
    },
    {
      "stepId": "recursion-check-ts",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-ts"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-ts"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-ts",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees\n\nFor example, to check if two trees are the same, we check if roots match, then recursively check if left subtrees match and right subtrees match.",
      "example": "function isSameTree(p, q) {\n  // Base case: both null\n  if (p === null && q === null) return true;\n  \n  // Recursive case: check roots and subtrees\n  return p.val === q.val && \n         isSameTree(p.left, q.left) &&  // Recursive call!\n         isSameTree(p.right, q.right); // Recursive call!\n}",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Perfect! Let's implement the solution in TypeScript.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-base-case-both-null-ts"
    },
    {
      "stepId": "coding-base-case-both-null-ts",
      "mentorSays": "Handle base case: both null.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-base-case-one-null-ts"
    },
    {
      "stepId": "coding-base-case-one-null-ts",
      "mentorSays": "Handle case: one null, one not.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-check-values-ts"
    },
    {
      "stepId": "coding-check-values-ts",
      "mentorSays": "Check if values match.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-recursive-check-ts"
    },
    {
      "stepId": "coding-recursive-check-ts",
      "mentorSays": "Recursively check left and right subtrees.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** p = [1,2,3], q = [1,2,3]\nExpected: true (identical trees)\n\n**Test 2:** p = [1,2], q = [1,null,2]\nExpected: false (different structure)\n\n**Test 3:** p = [1,2,1], q = [1,1,2]\nExpected: false (different values)\n\n**Test 4:** p = null, q = null\nExpected: true (both empty)\n\n**Test 5:** p = [1], q = [1]\nExpected: true (single node, same)\n\n**Test 6:** p = [1], q = [2]\nExpected: false (single node, different values)\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [1,2,3] vs [1,2,3] â†’ true\nTest 2: [1,2] vs [1,null,2] â†’ false\nTest 3: [1,2,1] vs [1,1,2] â†’ false\nTest 4: null vs null â†’ true\nTest 5: [1] vs [1] â†’ true\nTest 6: [1] vs [2] â†’ false",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "final",
      "mentorSays": "ðŸŽ‰ Well done! You've successfully implemented the Same Tree solution!\n\n**Time Complexity:** O(n)\n- We visit each node exactly once\n- n is the minimum number of nodes in the two trees\n- In the worst case, we visit all nodes of both trees\n\n**Space Complexity:** O(h)\n- The recursion stack uses space proportional to the height of the tree\n- In the worst case (skewed tree), h = n, so O(n)\n- In the best case (balanced tree), h = log n, so O(log n)\n\n**Key Takeaways:**\n1. **Recursive approach**: Check if roots match, then recursively check subtrees\n2. **Base cases**: Both null = true, one null = false\n3. **Value check**: Corresponding nodes must have the same value\n4. **Structure check**: Both left and right subtrees must match\n5. **Natural recursion**: Trees are recursive structures, so recursion fits perfectly\n\n**Related Practice Problems:**\n- Symmetric Tree (LeetCode #101) - check if tree is symmetric\n- Subtree of Another Tree (LeetCode #572) - check if one tree is subtree of another\n- Maximum Depth of Binary Tree (LeetCode #104) - similar recursive pattern\n\nKeep practicing tree problems - they're fundamental for interviews!",
      "action": "continue"
    }
  ]
}