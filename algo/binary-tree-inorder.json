{
  "id": "binary-tree-inorder",
  "title": "Binary Tree Inorder Traversal",
  "pattern": "tree + recursion",
  "difficulty": "medium",
  "language": "javascript",
  "quality": "PERFECT",
  "version": "v1.0-fixed",
  "flow": [
    {
      "stepId": "problem-statement",
      "mentorSays": "You are given the **root of a binary tree**.\n\nYour task is to return the values of the nodes using **inorder traversal**.\n\nInorder traversal follows a specific visiting order that we will build step by step.",
      "action": "next"
    },
    {
      "stepId": "tiny-tree-example",
      "mentorSays": "Let’s start with a very small tree.\n\n      2\n     / \\\n    1   3\n\nThis tree has:\n- a root (2)\n- a left child (1)\n- a right child (3)",
      "action": "next"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Before learning any rules, think carefully.\n\nIf you had to **visit all nodes** in this tree, what could be a reasonable order?\n\nShould you:\n- Visit the root first?\n- Visit the children first?\n\nThere are multiple valid traversal styles. We are learning one of them.",
      "action": "next"
    },
    {
      "stepId": "define-inorder",
      "mentorSays": "In **inorder traversal**, the rule is:\n\n1. Visit the **left subtree**\n2. Visit the **current node**\n3. Visit the **right subtree**\n\nThis order is always followed.",
      "action": "next"
    },
    {
      "stepId": "walkthrough-example",
      "mentorSays": "Let’s apply the rule to our tiny tree.\n\n      2\n     / \\\n    1   3\n\nStep-by-step:\n- Go left → visit 1\n- Visit current node → 2\n- Go right → visit 3\n\nSo the inorder result is:\n[1, 2, 3]",
      "action": "next"
    },
    {
      "stepId": "why-recursion",
      "mentorSays": "Notice something important.\n\nEach subtree is itself a **smaller tree**.\n\nThat means the same rule applies again and again.\n\nThis is a strong hint that **recursion** is a natural fit for this problem.",
      "action": "next"
    },
    {
      "stepId": "concept-recursion",
      "mentorSays": "Recursion means a function **calls itself** to solve a smaller version of the same problem.\n\nFor a tree:\n- If the node is null → do nothing\n- Otherwise:\n  - Traverse left\n  - Process current node\n  - Traverse right",
      "action": "next"
    },
    {
      "stepId": "pseudocode",
      "mentorSays": "Let’s write the logic in plain steps.\n\nNo JavaScript yet.",
      "pseudocode": [
        "create an empty result list",
        "define a recursive function",
        "if node is null, return",
        "traverse left subtree",
        "add node value to result",
        "traverse right subtree",
        "call recursive function with root",
        "return result"
      ],
      "action": "next"
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now that the logic is clear, we can translate it into JavaScript.\n\nType the code yourself to build confidence with recursion.",
      "action": "next"
    },
    {
      "stepId": "coding-js",
      "mentorSays": "Here is the JavaScript implementation.",
      "code": "function inorderTraversal(root) {\n  const result = [];\n\n  function traverse(node) {\n    if (node === null) return;\n\n    traverse(node.left);\n    result.push(node.val);\n    traverse(node.right);\n  }\n\n  traverse(root);\n  return result;\n}",
      "action": "next"
    },
    {
      "stepId": "final-check",
      "mentorSays": "If the tree is:\n\n      2\n     / \\\n    1   3\n\nThe output will be:\n[1, 2, 3]\n\nThis confirms the traversal order is correct.",
      "action": "complete"
    }
  ]
}
