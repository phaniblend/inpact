{
  "id": "invert-binary-tree",
  "title": "Invert Binary Tree",
  "pattern": "tree",
  "difficulty": "easy",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what the Invert Binary Tree problem asks for\n2. Use recursion to swap left and right children\n3. Invert the tree by recursively inverting subtrees\n4. Handle base cases (null nodes)\n5. Implement the solution step by step in your chosen language",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Perfect! Now let's understand what the Invert Binary Tree problem is asking.\n\n**Problem Definition:**\nGiven the root of a binary tree, invert the tree, and return its root.\n\n**Key Observations:**\n- We need to swap the left and right children of every node\n- This should be done recursively for all nodes\n- An empty tree (null root) remains empty\n- After inversion, the tree structure is mirrored\n\n**Example 1:**\nOriginal tree:\n    4\n   / \\\n  2   7\n / \\ / \\\n1  3 6  9\n\nInverted tree:\n    4\n   / \\\n  7   2\n / \\ / \\\n9  6 3  1\n\n**Example 2:**\nOriginal tree:\n    2\n   / \\\n  1   3\n\nInverted tree:\n    2\n   / \\\n  3   1\n\n**Example 3:**\nOriginal tree: null (empty tree)\n\nInverted tree: null (empty tree)\n\n**Step-by-step trace for Example 1 (Recursive approach):**\n\nOriginal:\n    4\n   / \\\n  2   7\n / \\ / \\\n1  3 6  9\n\nWe'll use recursion:\n- **invertTree(4)**:\n  - Swap left (2) and right (7)\n  - Recursively invert left subtree: invertTree(2)\n  - Recursively invert right subtree: invertTree(7)\n  - Return root (4)\n\n- **invertTree(2)**:\n  - Swap left (1) and right (3)\n  - Recursively invert left: invertTree(1) = null\n  - Recursively invert right: invertTree(3) = null\n  - Return root (2)\n\n- **invertTree(7)**:\n  - Swap left (6) and right (9)\n  - Recursively invert left: invertTree(6) = null\n  - Recursively invert right: invertTree(9) = null\n  - Return root (7)\n\nResult:\n    4\n   / \\\n  7   2\n / \\ / \\\n9  6 3  1\n\n**Key Insight:**\nTo invert a tree, we:\n1. Swap the left and right children of the current node\n2. Recursively invert the left subtree\n3. Recursively invert the right subtree\n\n**What makes this tricky:**\n1. Understanding that we need to swap children at every node\n2. Recursive thinking: invert subtrees first, then swap\n3. Handling null nodes correctly\n4. The order matters: we can swap before or after recursion (both work!)\n\n**Common pitfalls:**\n- Not swapping children\n- Only swapping at root level (need to swap at all levels)\n- Not handling null nodes\n- Forgetting to return the root",
      "example": "Example 1:\nOriginal:\n    4\n   / \\\n  2   7\n / \\ / \\\n1  3 6  9\n\nInverted:\n    4\n   / \\\n  7   2\n / \\ / \\\n9  6 3  1\n\nExample 2:\nOriginal:\n    2\n   / \\\n  1   3\n\nInverted:\n    2\n   / \\\n  3   1",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Now that you understand what the problem wants, here's the real question:\n\nHow would YOU invert a binary tree?\n\nThink about it for a moment. What approach feels natural to you?",
      "choices": [
        {
          "label": "Use recursion - swap children, then recursively invert subtrees",
          "next": "explore-recursive"
        },
        {
          "label": "Use BFS/level-order traversal and swap at each level",
          "next": "explore-bfs"
        },
        {
          "label": "Use DFS with a stack to swap nodes",
          "next": "explore-dfs"
        }
      ]
    },
    {
      "stepId": "explore-bfs",
      "mentorSays": "That's a great approach! You're thinking: \"I'll use BFS (level-order traversal) to visit nodes level by level, and swap children at each level.\"\n\nThis works perfectly! However, it requires a queue and uses O(n) space.\n\nThere's a more elegant recursive approach that uses O(h) space (where h is the height). Would you like to learn that?",
      "action": "continue",
      "next": "explore-recursive"
    },
    {
      "stepId": "explore-dfs",
      "mentorSays": "That's a solid approach! You're thinking: \"I'll use DFS with a stack to traverse the tree and swap children.\"\n\nThis works! However, it's more complex than needed.\n\nThere's a simpler recursive approach that's very elegant. Would you like to learn that?",
      "action": "continue",
      "next": "explore-recursive"
    },
    {
      "stepId": "explore-recursive",
      "mentorSays": "Excellent choice! Recursion is the most elegant solution for this problem. Here's the core idea:\n\n**The Algorithm:**\n1. **Base case**: If root is null, return null (empty tree)\n2. **Swap children**: Swap the left and right children of the current node\n3. **Recursive case**: \n   - Recursively invert the left subtree: invertTree(root.left)\n   - Recursively invert the right subtree: invertTree(root.right)\n4. **Return root**\n\n**Why it works**:\n- We swap children at each node\n- We recursively invert the subtrees\n- The base case handles null nodes\n\n**Key insight**: We can swap before or after recursion - both work! The classic approach swaps after recursion, but swapping before also works.\n\nLet's trace with tree:\n    4\n   / \\\n  2   7\n\n- **invertTree(4)**:\n  - Recursively invert left: invertTree(2) = 2 (swapped)\n  - Recursively invert right: invertTree(7) = 7 (swapped)\n  - Swap left and right: 4's children are now swapped\n  - Return 4\n\n- **invertTree(2)**:\n  - Both children are null, so nothing to swap\n  - Return 2\n\n- **invertTree(7)**:\n  - Both children are null, so nothing to swap\n  - Return 7\n\nResult: 4 with left=7, right=2 âœ“\n\nThis is O(n) time (visit each node once) and O(h) space (recursion stack)! Now let's code it step by step.",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Great! Now let's code this solution. Which programming language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "variable-check-js"
        },
        {
          "label": "Python",
          "next": "variable-check-python"
        },
        {
          "label": "Java",
          "next": "variable-check-java"
        },
        {
          "label": "C++",
          "next": "variable-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "variable-check-ts"
        }
      ]
    },
    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-js"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-js"
        }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'temp' or 'left') and put data inside it.",
      "example": "let temp = root.left;  // Temporary variable\nlet left = root.left;   // Left child",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-js"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-js"
        }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function invertTree(root) {\n  // Returns inverted tree root\n  return null;\n}",
      "action": "continue",
      "next": "parameter-check-js"
    },
    {
      "stepId": "parameter-check-js",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-js"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-js"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-js",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function invertTree(root)', the 'root' is a parameter that receives the root node.",
      "example": "function invertTree(root) {\n  // Parameter receives root node\n}\n\n// Call: invertTree(rootNode)",
      "action": "continue",
      "next": "tree-check-js"
    },
    {
      "stepId": "tree-check-js",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-js"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-js"
        }
      ]
    },
    {
      "stepId": "tree-explanation-js",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-js"
    },
    {
      "stepId": "recursion-check-js",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-js"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-js"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-js",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees",
      "example": "function invertTree(root) {\n  if (root === null) return null;\n  \n  // Recursive calls\n  invertTree(root.left);   // Recursive call!\n  invertTree(root.right);  // Recursive call!\n  \n  // Swap children\n  let temp = root.left;\n  root.left = root.right;\n  root.right = temp;\n  \n  return root;\n}",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Perfect! Let's implement the invert binary tree solution in JavaScript. We'll create a function that takes the root and returns the inverted tree root.",
      "example": "function invertTree(root) {\n  \n}",
      "action": "continue",
      "next": "coding-base-case-js"
    },
    {
      "stepId": "coding-base-case-js",
      "mentorSays": "First, handle the base case: if root is null, return null (empty tree).",
      "example": "function invertTree(root) {\n  // Base case: empty tree\n  if (root === null) {\n    return null;\n  }\n  \n}",
      "action": "continue",
      "next": "coding-recursive-left-js"
    },
    {
      "stepId": "coding-recursive-left-js",
      "mentorSays": "Recursively invert the left subtree.",
      "example": "function invertTree(root) {\n  if (root === null) {\n    return null;\n  }\n  \n  // Recursively invert left subtree\n  invertTree(root.left);\n  \n}",
      "action": "continue",
      "next": "coding-recursive-right-js"
    },
    {
      "stepId": "coding-recursive-right-js",
      "mentorSays": "Recursively invert the right subtree.",
      "example": "function invertTree(root) {\n  if (root === null) {\n    return null;\n  }\n  \n  invertTree(root.left);\n  // Recursively invert right subtree\n  invertTree(root.right);\n  \n}",
      "action": "continue",
      "next": "coding-swap-js"
    },
    {
      "stepId": "coding-swap-js",
      "mentorSays": "Swap the left and right children of the current node.",
      "example": "function invertTree(root) {\n  if (root === null) {\n    return null;\n  }\n  \n  invertTree(root.left);\n  invertTree(root.right);\n  \n  // Swap left and right children\n  let temp = root.left;\n  root.left = root.right;\n  root.right = temp;\n  \n}",
      "action": "continue",
      "next": "coding-return-js"
    },
    {
      "stepId": "coding-return-js",
      "mentorSays": "Return the root node.",
      "example": "function invertTree(root) {\n  if (root === null) {\n    return null;\n  }\n  \n  invertTree(root.left);\n  invertTree(root.right);\n  \n  let temp = root.left;\n  root.left = root.right;\n  root.right = temp;\n  \n  return root;\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [4, 2, 7, 1, 3, 6, 9]\nExpected: [4, 7, 2, 9, 6, 3, 1]\n\n**Test 2:** root = [2, 1, 3]\nExpected: [2, 3, 1]\n\n**Test 3:** root = null\nExpected: null\n\n**Test 4:** root = [1]\nExpected: [1] (single node)\n\n**Test 5:** root = [1, 2]\nExpected: [1, null, 2]\n\n**Test 6:** root = [1, null, 2]\nExpected: [1, 2]\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [4,2,7,1,3,6,9] â†’ [4,7,2,9,6,3,1]\nTest 2: [2,1,3] â†’ [2,3,1]\nTest 3: null â†’ null\nTest 4: [1] â†’ [1]\nTest 5: [1,2] â†’ [1,null,2]\nTest 6: [1,null,2] â†’ [1,2]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Python?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-python"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-python"
        }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'temp' or 'left') and put data inside it.",
      "example": " temp = root.left;  // Temporary variable\n left = root.left;   // Left child",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Python?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-python"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-python"
        }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "def invertTree(root) {\n  // Returns inverted tree root\n  return null;\n}",
      "action": "continue",
      "next": "parameter-check-python"
    },
    {
      "stepId": "parameter-check-python",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-python"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-python"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-python",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'def invertTree(root)', the 'root' is a parameter that receives the root node.",
      "example": "def invertTree(root) {\n  // Parameter receives root node\n}\n\n// Call: invertTree(rootNode)",
      "action": "continue",
      "next": "tree-check-python"
    },
    {
      "stepId": "tree-check-python",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-python"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-python"
        }
      ]
    },
    {
      "stepId": "tree-explanation-python",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-python"
    },
    {
      "stepId": "recursion-check-python",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in Python?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-python"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-python"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-python",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees",
      "example": "function invertTree(root) {\n  if (root === null) return null;\n  \n  // Recursive calls\n  invertTree(root.left);   // Recursive call!\n  invertTree(root.right);  // Recursive call!\n  \n  // Swap children\n  let temp = root.left;\n  root.left = root.right;\n  root.right = temp;\n  \n  return root;\n}",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Perfect! Let's implement the solution in Python.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-base-case-python"
    },
    {
      "stepId": "coding-base-case-python",
      "mentorSays": "Handle base case (null root).",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-recursive-left-python"
    },
    {
      "stepId": "coding-recursive-left-python",
      "mentorSays": "Recursively invert left subtree.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-recursive-right-python"
    },
    {
      "stepId": "coding-recursive-right-python",
      "mentorSays": "Recursively invert right subtree.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-swap-python"
    },
    {
      "stepId": "coding-swap-python",
      "mentorSays": "Swap left and right children.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "coding-return-python"
    },
    {
      "stepId": "coding-return-python",
      "mentorSays": "Return root.",
      "example": "// Python implementation",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [4, 2, 7, 1, 3, 6, 9]\nExpected: [4, 7, 2, 9, 6, 3, 1]\n\n**Test 2:** root = [2, 1, 3]\nExpected: [2, 3, 1]\n\n**Test 3:** root = null\nExpected: null\n\n**Test 4:** root = [1]\nExpected: [1] (single node)\n\n**Test 5:** root = [1, 2]\nExpected: [1, null, 2]\n\n**Test 6:** root = [1, null, 2]\nExpected: [1, 2]\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [4,2,7,1,3,6,9] â†’ [4,7,2,9,6,3,1]\nTest 2: [2,1,3] â†’ [2,3,1]\nTest 3: null â†’ null\nTest 4: [1] â†’ [1]\nTest 5: [1,2] â†’ [1,null,2]\nTest 6: [1,null,2] â†’ [1,2]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Java?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-java"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-java"
        }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'temp' or 'left') and put data inside it.",
      "example": "TreeNode temp = root.left;  // Temporary variable\nTreeNode left = root.left;   // Left child",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Java?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-java"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-java"
        }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "public TreeNode invertTree(root) {\n  // Returns inverted tree root\n  return null;\n}",
      "action": "continue",
      "next": "parameter-check-java"
    },
    {
      "stepId": "parameter-check-java",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-java"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-java"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-java",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'public TreeNode invertTree(root)', the 'root' is a parameter that receives the root node.",
      "example": "public TreeNode invertTree(root) {\n  // Parameter receives root node\n}\n\n// Call: invertTree(rootNode)",
      "action": "continue",
      "next": "tree-check-java"
    },
    {
      "stepId": "tree-check-java",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-java"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-java"
        }
      ]
    },
    {
      "stepId": "tree-explanation-java",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-java"
    },
    {
      "stepId": "recursion-check-java",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in Java?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-java"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-java"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-java",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees",
      "example": "function invertTree(root) {\n  if (root === null) return null;\n  \n  // Recursive calls\n  invertTree(root.left);   // Recursive call!\n  invertTree(root.right);  // Recursive call!\n  \n  // Swap children\n  let temp = root.left;\n  root.left = root.right;\n  root.right = temp;\n  \n  return root;\n}",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Perfect! Let's implement the solution in Java.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-base-case-java"
    },
    {
      "stepId": "coding-base-case-java",
      "mentorSays": "Handle base case (null root).",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-recursive-left-java"
    },
    {
      "stepId": "coding-recursive-left-java",
      "mentorSays": "Recursively invert left subtree.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-recursive-right-java"
    },
    {
      "stepId": "coding-recursive-right-java",
      "mentorSays": "Recursively invert right subtree.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-swap-java"
    },
    {
      "stepId": "coding-swap-java",
      "mentorSays": "Swap left and right children.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "coding-return-java"
    },
    {
      "stepId": "coding-return-java",
      "mentorSays": "Return root.",
      "example": "// Java implementation",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [4, 2, 7, 1, 3, 6, 9]\nExpected: [4, 7, 2, 9, 6, 3, 1]\n\n**Test 2:** root = [2, 1, 3]\nExpected: [2, 3, 1]\n\n**Test 3:** root = null\nExpected: null\n\n**Test 4:** root = [1]\nExpected: [1] (single node)\n\n**Test 5:** root = [1, 2]\nExpected: [1, null, 2]\n\n**Test 6:** root = [1, null, 2]\nExpected: [1, 2]\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [4,2,7,1,3,6,9] â†’ [4,7,2,9,6,3,1]\nTest 2: [2,1,3] â†’ [2,3,1]\nTest 3: null â†’ null\nTest 4: [1] â†’ [1]\nTest 5: [1,2] â†’ [1,null,2]\nTest 6: [1,null,2] â†’ [1,2]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in C++?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-cpp"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'temp' or 'left') and put data inside it.",
      "example": "TreeNode* temp = root.left;  // Temporary variable\nTreeNode* left = root.left;   // Left child",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in C++?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-cpp"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "TreeNode* invertTree(root) {\n  // Returns inverted tree root\n  return null;\n}",
      "action": "continue",
      "next": "parameter-check-cpp"
    },
    {
      "stepId": "parameter-check-cpp",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-cpp"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-cpp",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'TreeNode* invertTree(root)', the 'root' is a parameter that receives the root node.",
      "example": "TreeNode* invertTree(root) {\n  // Parameter receives root node\n}\n\n// Call: invertTree(rootNode)",
      "action": "continue",
      "next": "tree-check-cpp"
    },
    {
      "stepId": "tree-check-cpp",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-cpp"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "tree-explanation-cpp",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-cpp"
    },
    {
      "stepId": "recursion-check-cpp",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in C++?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-cpp"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-cpp",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees",
      "example": "function invertTree(root) {\n  if (root === null) return null;\n  \n  // Recursive calls\n  invertTree(root.left);   // Recursive call!\n  invertTree(root.right);  // Recursive call!\n  \n  // Swap children\n  let temp = root.left;\n  root.left = root.right;\n  root.right = temp;\n  \n  return root;\n}",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Perfect! Let's implement the solution in C++.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-base-case-cpp"
    },
    {
      "stepId": "coding-base-case-cpp",
      "mentorSays": "Handle base case (null root).",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-recursive-left-cpp"
    },
    {
      "stepId": "coding-recursive-left-cpp",
      "mentorSays": "Recursively invert left subtree.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-recursive-right-cpp"
    },
    {
      "stepId": "coding-recursive-right-cpp",
      "mentorSays": "Recursively invert right subtree.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-swap-cpp"
    },
    {
      "stepId": "coding-swap-cpp",
      "mentorSays": "Swap left and right children.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "coding-return-cpp"
    },
    {
      "stepId": "coding-return-cpp",
      "mentorSays": "Return root.",
      "example": "// C++ implementation",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [4, 2, 7, 1, 3, 6, 9]\nExpected: [4, 7, 2, 9, 6, 3, 1]\n\n**Test 2:** root = [2, 1, 3]\nExpected: [2, 3, 1]\n\n**Test 3:** root = null\nExpected: null\n\n**Test 4:** root = [1]\nExpected: [1] (single node)\n\n**Test 5:** root = [1, 2]\nExpected: [1, null, 2]\n\n**Test 6:** root = [1, null, 2]\nExpected: [1, 2]\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [4,2,7,1,3,6,9] â†’ [4,7,2,9,6,3,1]\nTest 2: [2,1,3] â†’ [2,3,1]\nTest 3: null â†’ null\nTest 4: [1] â†’ [1]\nTest 5: [1,2] â†’ [1,null,2]\nTest 6: [1,null,2] â†’ [1,2]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-ts"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-ts"
        }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'temp' or 'left') and put data inside it.",
      "example": "let temp = root.left;  // Temporary variable\nlet left = root.left;   // Left child",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-ts"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-ts"
        }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function invertTree(root) {\n  // Returns inverted tree root\n  return null;\n}",
      "action": "continue",
      "next": "parameter-check-ts"
    },
    {
      "stepId": "parameter-check-ts",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "tree-check-ts"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-ts"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-ts",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function invertTree(root)', the 'root' is a parameter that receives the root node.",
      "example": "function invertTree(root) {\n  // Parameter receives root node\n}\n\n// Call: invertTree(rootNode)",
      "action": "continue",
      "next": "tree-check-ts"
    },
    {
      "stepId": "tree-check-ts",
      "mentorSays": "To solve this problem, we'll need to work with binary trees. Do you know what a binary tree is?",
      "choices": [
        {
          "label": "Yes, I know binary trees",
          "next": "recursion-check-ts"
        },
        {
          "label": "No, explain binary trees",
          "next": "tree-explanation-ts"
        }
      ]
    },
    {
      "stepId": "tree-explanation-ts",
      "mentorSays": "A binary tree is a data structure where each node has at most two children (left and right). Each node contains a value and references to its children.",
      "example": "// Node structure:\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}",
      "action": "continue",
      "next": "recursion-check-ts"
    },
    {
      "stepId": "recursion-check-ts",
      "mentorSays": "To solve this problem, we'll use recursion. Do you know what recursion is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know recursion",
          "next": "coding-start-ts"
        },
        {
          "label": "No, explain recursion",
          "next": "recursion-explanation-ts"
        }
      ]
    },
    {
      "stepId": "recursion-explanation-ts",
      "mentorSays": "Recursion is when a function calls itself. For tree problems, we often use recursion because:\n- A tree is naturally recursive (each subtree is also a tree)\n- We can solve the problem for the whole tree by solving it for subtrees",
      "example": "function invertTree(root) {\n  if (root === null) return null;\n  \n  // Recursive calls\n  invertTree(root.left);   // Recursive call!\n  invertTree(root.right);  // Recursive call!\n  \n  // Swap children\n  let temp = root.left;\n  root.left = root.right;\n  root.right = temp;\n  \n  return root;\n}",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Perfect! Let's implement the solution in TypeScript.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-base-case-ts"
    },
    {
      "stepId": "coding-base-case-ts",
      "mentorSays": "Handle base case (null root).",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-recursive-left-ts"
    },
    {
      "stepId": "coding-recursive-left-ts",
      "mentorSays": "Recursively invert left subtree.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-recursive-right-ts"
    },
    {
      "stepId": "coding-recursive-right-ts",
      "mentorSays": "Recursively invert right subtree.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-swap-ts"
    },
    {
      "stepId": "coding-swap-ts",
      "mentorSays": "Swap left and right children.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "coding-return-ts"
    },
    {
      "stepId": "coding-return-ts",
      "mentorSays": "Return root.",
      "example": "// TypeScript implementation",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Perfect! Now test your code with multiple test cases:\n\n**Test 1:** root = [4, 2, 7, 1, 3, 6, 9]\nExpected: [4, 7, 2, 9, 6, 3, 1]\n\n**Test 2:** root = [2, 1, 3]\nExpected: [2, 3, 1]\n\n**Test 3:** root = null\nExpected: null\n\n**Test 4:** root = [1]\nExpected: [1] (single node)\n\n**Test 5:** root = [1, 2]\nExpected: [1, null, 2]\n\n**Test 6:** root = [1, null, 2]\nExpected: [1, 2]\n\nTry these in your IDE or code editor!",
      "example": "Test 1: [4,2,7,1,3,6,9] â†’ [4,7,2,9,6,3,1]\nTest 2: [2,1,3] â†’ [2,3,1]\nTest 3: null â†’ null\nTest 4: [1] â†’ [1]\nTest 5: [1,2] â†’ [1,null,2]\nTest 6: [1,null,2] â†’ [1,2]",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "final",
      "mentorSays": "ðŸŽ‰ Well done! You've successfully implemented the Invert Binary Tree solution!\n\n**Time Complexity:** O(n)\n- We visit each node exactly once\n- n is the number of nodes in the tree\n\n**Space Complexity:** O(h)\n- The recursion stack uses space proportional to the height of the tree\n- In the worst case (skewed tree), h = n, so O(n)\n- In the best case (balanced tree), h = log n, so O(log n)\n\n**Key Takeaways:**\n1. **Recursive approach**: Invert subtrees recursively, then swap children\n2. **Base case**: Empty tree (null) returns null\n3. **Swap children**: At each node, swap left and right children\n4. **Post-order traversal**: We process children before swapping (can also swap before recursion)\n5. **Natural recursion**: Trees are recursive structures, so recursion fits perfectly\n\n**Related Practice Problems:**\n- Same Tree (LeetCode #100) - compare trees\n- Symmetric Tree (LeetCode #101) - check if tree is symmetric\n- Maximum Depth of Binary Tree (LeetCode #104) - similar recursive pattern\n\nKeep practicing tree problems - they're fundamental for interviews!",
      "action": "continue"
    }
  ]
}