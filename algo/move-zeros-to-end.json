{
  "id": "move-zeros-to-end",
  "title": "Move zeros to end",
  "pattern": "two-pointers",
  "difficulty": "easy",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what it means to move zeros to the end\n2. Use two pointers to rearrange elements in-place\n3. Maintain the relative order of non-zero elements\n4. Implement the solution step by step in your chosen language",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Perfect! Now let's understand what the Move Zeros to End problem is asking.\n\nImagine you have an array: [0, 1, 0, 3, 12]\n\nYour task: Move all zeros to the end while keeping the relative order of non-zero elements the same.\n\nLooking at the array:\n- Non-zero elements: 1, 3, 12 (in that order)\n- Zeros: 0, 0\n\nAfter moving zeros to the end:\n- [1, 3, 12, 0, 0]\n\nNotice:\n- All non-zero elements (1, 3, 12) are at the front, in the same order\n- All zeros are at the end\n- The array is modified in-place (we don't create a new array)\n\nThat's what the problem wants: rearrange the array so all zeros are at the end, and all non-zero elements maintain their original relative order at the front.",
      "example": "nums = [0, 1, 0, 3, 12]\n\nMove zeros to end:\n[1, 3, 12, 0, 0]\n\nAnother example:\nnums = [0, 0, 1]\n\nMove zeros to end:\n[1, 0, 0]\n\nNote: We modify the array in-place, and non-zero elements keep their relative order.",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Now that you understand what the problem wants, here's the real question:\n\nHow would YOU move zeros to the end?\n\nThink about it for a moment. What approach feels natural to you?",
      "choices": [
        {
          "label": "Use two pointers: one to track position for non-zeros, one to scan",
          "next": "explore-two-pointers"
        },
        {
          "label": "Create a new array and copy non-zeros first, then zeros",
          "next": "explore-new-array"
        },
        {
          "label": "Count zeros, remove them, then add zeros at the end",
          "next": "explore-count"
        }
      ]
    },
    {
      "stepId": "explore-new-array",
      "mentorSays": "That's a straightforward approach! You're thinking: \"I'll create a new array, copy all non-zero elements first, then add zeros at the end.\"\n\nFor [0, 1, 0, 3, 12]:\n- Non-zeros: [1, 3, 12]\n- Zeros: [0, 0]\n- Result: [1, 3, 12, 0, 0]\n\nThis works! However, the problem asks us to modify the array in-place (without creating a new array). Also, using extra space makes it less efficient.\n\nWould you like to learn the two pointers approach that works in-place?",
      "choices": [
        {
          "label": "Yes, teach me the two pointers approach",
          "next": "explore-two-pointers"
        },
        {
          "label": "No, I want to code the new array approach",
          "next": "language-selection-new-array"
        }
      ]
    },
    {
      "stepId": "explore-count",
      "mentorSays": "That's creative thinking! You're thinking: \"I'll count how many zeros there are, remove all zeros, then add that many zeros at the end.\"\n\nFor [0, 1, 0, 3, 12]:\n- Count zeros: 2\n- Remove zeros: [1, 3, 12]\n- Add 2 zeros: [1, 3, 12, 0, 0]\n\nThis works! However, removing elements from an array can be inefficient, and we need to modify the original array in-place.\n\nThere's a more efficient approach using two pointers that works in-place without removing elements. Would you like to learn that?",
      "action": "continue",
      "next": "explore-two-pointers"
    },
    {
      "stepId": "explore-two-pointers",
      "mentorSays": "Excellent choice! The two pointers approach is both efficient and elegant. Here's the core idea:\n\n1. **Two pointers**: \n   - `writeIndex`: Points to the next position where we should write a non-zero element\n   - `readIndex`: Scans through the array\n\n2. **Process**: For each element:\n   - If it's non-zero, write it at `writeIndex` and move `writeIndex` forward\n   - If it's zero, skip it (just move `readIndex` forward)\n\n3. **Fill zeros**: After processing all elements, fill the remaining positions with zeros\n\nLet's trace this with [0, 1, 0, 3, 12]:\n\n- **Initial**: writeIndex = 0, readIndex = 0\n- **readIndex = 0**: nums[0] = 0 (zero, skip) → readIndex = 1\n- **readIndex = 1**: nums[1] = 1 (non-zero) → nums[writeIndex] = 1, writeIndex = 1, readIndex = 2\n  Array: [1, 1, 0, 3, 12]\n- **readIndex = 2**: nums[2] = 0 (zero, skip) → readIndex = 3\n- **readIndex = 3**: nums[3] = 3 (non-zero) → nums[writeIndex] = 3, writeIndex = 2, readIndex = 4\n  Array: [1, 3, 0, 3, 12]\n- **readIndex = 4**: nums[4] = 12 (non-zero) → nums[writeIndex] = 12, writeIndex = 3, readIndex = 5\n  Array: [1, 3, 12, 3, 12]\n- **Fill zeros**: From writeIndex (3) to end, set to 0\n  Array: [1, 3, 12, 0, 0] ✓\n\nThis is O(n) time and O(1) space! Now let's code it step by step.",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Great! Now let's code the two pointers solution. Which programming language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "variable-check-js"
        },
        {
          "label": "Python",
          "next": "variable-check-python"
        },
        {
          "label": "Java",
          "next": "variable-check-java"
        },
        {
          "label": "C++",
          "next": "variable-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "variable-check-ts"
        }
      ]
    },
    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-js"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-js"
        }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'writeIndex' or 'readIndex') and put data inside it.\n\nFor example, 'let writeIndex = 0;' creates a variable that stores the number 0. Later, you can use that variable name to refer to it.",
      "example": "let writeIndex = 0;\n\nNow the variable refers to the number 0\nWe can use the variable name to access this value",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-js"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-js"
        }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the function does the work, and gives you a result (return value).",
      "example": "function add(a, b) {\n  return a + b;\n}\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-js"
    },
    {
      "stepId": "parameter-check-js",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "loop-check-js"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-js"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-js",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function moveZeros(nums)', the 'nums' is a parameter - it's a placeholder that will receive an actual array when you call the function.\n\nWhen you call 'moveZeros([0, 1, 0, 3, 12])', the array [0, 1, 0, 3, 12] goes into 'nums'. Inside the function, you can use 'nums' to refer to that array.",
      "example": "function moveZeros(nums) {\n  // 'nums' is a parameter\n}\n\n// When we call it:\nmoveZeros([0, 1, 0, 3, 12]);\n// The array goes into 'nums'",
      "action": "continue",
      "next": "loop-check-js"
    },
    {
      "stepId": "loop-check-js",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "two-pointers-check-js"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-js"
        }
      ]
    },
    {
      "stepId": "two-pointers-check-js",
      "mentorSays": "Do you understand the two-pointer technique?",
      "choices": [
        {
          "label": "Yes, I know two-pointers",
          "next": "coding-start-js"
        },
        {
          "label": "No, explain two-pointers",
          "next": "two-pointers-explanation-js"
        }
      ]
    },
    {
      "stepId": "two-pointers-explanation-js",
      "mentorSays": "The two-pointer technique uses two indices to traverse an array efficiently. For this problem, one pointer tracks where to write non-zero elements, and another scans through the array.\n\nlet writeIndex = 0;\nlet readIndex = 0;\n\n// Two pointers: writeIndex writes, readIndex reads\nwhile (readIndex < nums.length) {\n  if (nums[readIndex] !== 0) {\n    nums[writeIndex++] = nums[readIndex];\n  }\n  readIndex++;\n}\n\nGot it?",
      "example": "let writeIndex = 0;\nlet readIndex = 0;\n\n// Two pointers: writeIndex writes, readIndex reads\nwhile (readIndex < nums.length) {\n  if (nums[readIndex] !== 0) {\n    nums[writeIndex++] = nums[readIndex];\n  }\n  readIndex++;\n}",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "loop-explanation-js",
      "mentorSays": "A loop lets you repeat code multiple times. A 'for' loop runs code for each item in a sequence.\n\nFor example, 'for (let i = 0; i < 3; i++)' means: start at 0, keep going while i is less than 3, and add 1 to i each time. So it runs 3 times: when i is 0, 1, and 2.",
      "example": "for (let i = 0; i < 3; i++) {\n  console.log(i);\n}\n\nThis prints: 0, 1, 2",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Perfect! Let's implement the move zeros solution in JavaScript. We'll create a function that takes an array and moves all zeros to the end in-place.",
      "example": "function moveZeros(nums) {\n  // Your code here\n}",
      "action": "continue",
      "next": "coding-write-index-js"
    },
    {
      "stepId": "coding-write-index-js",
      "mentorSays": "First, let's initialize a writeIndex pointer that tracks where we should write the next non-zero element.",
      "example": "function moveZeros(nums) {\n  let writeIndex = 0;\n  // writeIndex points to the next position for a non-zero element\n}",
      "action": "continue",
      "next": "coding-loop-js"
    },
    {
      "stepId": "coding-loop-js",
      "mentorSays": "Now, let's loop through the array. For each non-zero element, write it at writeIndex and increment writeIndex.",
      "example": "function moveZeros(nums) {\n  let writeIndex = 0;\n  \n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      nums[writeIndex] = nums[i];\n      writeIndex++;\n    }\n  }\n  // After this loop, all non-zeros are at the front\n}",
      "action": "continue",
      "next": "coding-swap-logic-js"
    },
    {
      "stepId": "coding-swap-logic-js",
      "mentorSays": "Let's optimize our solution! Instead of creating a new array, we can use the two-pointer technique to move zeros in-place.\n\nWe use one pointer to track where to write non-zero elements, and another to scan through the array. This is more space-efficient!",
      "example": "function moveZeroes(nums) {\n  let writeIndex = 0;\n  \n  // Move all non-zero elements to the front\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      nums[writeIndex++] = nums[i];\n    }\n  }\n  \n  // Fill remaining positions with zeros\n  while (writeIndex < nums.length) {\n    nums[writeIndex++] = 0;\n  }\n}",
      "action": "continue",
      "next": "coding-fill-zeros-js"
    },
    {
      "stepId": "coding-optimization-js",
      "mentorSays": "Let's add one more optimization! We can combine the two-pointer technique with a single pass to make the code even cleaner.\n\nInstead of first moving non-zeros and then filling zeros, we can do it all in one pass using swap operations.",
      "example": "function moveZeroes(nums) {\n  let writeIndex = 0;\n  \n  // Move all non-zero elements to the front\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      // Swap if needed\n      if (i !== writeIndex) {\n        [nums[writeIndex], nums[i]] = [nums[i], nums[writeIndex]];\n      }\n      writeIndex++;\n    }\n  }\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "coding-fill-zeros-js",
      "mentorSays": "Finally, fill the remaining positions (from writeIndex to the end) with zeros.",
      "example": "function moveZeros(nums) {\n  let writeIndex = 0;\n  \n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      nums[writeIndex] = nums[i];\n      writeIndex++;\n    }\n  }\n  \n  // Fill remaining positions with zeros\n  for (let i = writeIndex; i < nums.length; i++) {\n    nums[i] = 0;\n  }\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nnums = [0, 1, 0, 3, 12]\n\nAfter calling moveZeros(nums), the array should be:\n[1, 3, 12, 0, 0]\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nnums = [0, 1, 0, 3, 12]\n\nAfter moveZeros(nums):\nnums = [1, 3, 12, 0, 0]\n\nAll non-zeros are at the front in order, zeros are at the end.",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Python?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-python"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-python"
        }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'writeIndex' or 'readIndex') and put data inside it.\n\nFor example, 'writeIndex = 0' creates a variable that stores the number 0. Later, you can use that variable name to refer to it.",
      "example": "writeIndex = 0\n\nNow the variable refers to the number 0\nWe can use the variable name to access this value",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Python?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-python"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-python"
        }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the function does the work, and gives you a result (return value).",
      "example": "def add(a, b):\n    return a + b\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-python"
    },
    {
      "stepId": "parameter-check-python",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "loop-check-python"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-python"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-python",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'def move_zeros(nums):', the 'nums' is a parameter - it's a placeholder that will receive an actual list when you call the function.\n\nWhen you call 'move_zeros([0, 1, 0, 3, 12])', the list [0, 1, 0, 3, 12] goes into 'nums'. Inside the function, you can use 'nums' to refer to that list.",
      "example": "def move_zeros(nums):\n  # 'nums' is a parameter\n\n# When we call it:\nmove_zeros([0, 1, 0, 3, 12])\n# The list goes into 'nums'",
      "action": "continue",
      "next": "loop-check-python"
    },
    {
      "stepId": "loop-check-python",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in Python?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "two-pointers-check-python"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-python"
        }
      ]
    },
    {
      "stepId": "two-pointers-check-python",
      "mentorSays": "Do you understand the two-pointer technique?",
      "choices": [
        {
          "label": "Yes, I know two-pointers",
          "next": "coding-start-python"
        },
        {
          "label": "No, explain two-pointers",
          "next": "two-pointers-explanation-python"
        }
      ]
    },
    {
      "stepId": "two-pointers-explanation-python",
      "mentorSays": "The two-pointer technique uses two indices to traverse an array efficiently. For this problem, one pointer tracks where to write non-zero elements, and another scans through the array.\n\nlet writeIndex = 0;\nlet readIndex = 0;\n\n// Two pointers: writeIndex writes, readIndex reads\nwhile (readIndex < nums.length) {\n  if (nums[readIndex] !== 0) {\n    nums[writeIndex++] = nums[readIndex];\n  }\n  readIndex++;\n}\n\nGot it?",
      "example": "let writeIndex = 0;\nlet readIndex = 0;\n\n// Two pointers: writeIndex writes, readIndex reads\nwhile (readIndex < nums.length) {\n  if (nums[readIndex] !== 0) {\n    nums[writeIndex++] = nums[readIndex];\n  }\n  readIndex++;\n}",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "loop-explanation-python",
      "mentorSays": "A loop lets you repeat code multiple times. A 'for' loop in Python runs code for each item in a sequence.\n\nFor example, 'for i in range(3):' means: run the code 3 times, with i being 0, then 1, then 2.",
      "example": "for i in range(3):\n    print(i)\n\nThis prints: 0, 1, 2",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Perfect! Let's implement the move zeros solution in Python. We'll create a function that takes a list and moves all zeros to the end in-place.",
      "example": "def move_zeros(nums):\n    # Your code here\n    pass",
      "action": "continue",
      "next": "coding-write-index-python"
    },
    {
      "stepId": "coding-write-index-python",
      "mentorSays": "First, let's initialize a writeIndex pointer that tracks where we should write the next non-zero element.",
      "example": "def move_zeros(nums):\n    write_index = 0\n    # write_index points to the next position for a non-zero element",
      "action": "continue",
      "next": "coding-loop-python"
    },
    {
      "stepId": "coding-loop-python",
      "mentorSays": "Now, let's loop through the list. For each non-zero element, write it at write_index and increment write_index.",
      "example": "def move_zeros(nums):\n    write_index = 0\n    \n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[write_index] = nums[i]\n            write_index += 1\n    # After this loop, all non-zeros are at the front",
      "action": "continue",
      "next": "coding-swap-logic-python"
    },
    {
      "stepId": "coding-swap-logic-python",
      "mentorSays": "Let's optimize our solution! Instead of creating a new array, we can use the two-pointer technique to move zeros in-place.\n\nWe use one pointer to track where to write non-zero elements, and another to scan through the array. This is more space-efficient!",
      "example": "function moveZeroes(nums) {\n  let writeIndex = 0;\n  \n  // Move all non-zero elements to the front\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      nums[writeIndex++] = nums[i];\n    }\n  }\n  \n  // Fill remaining positions with zeros\n  while (writeIndex < nums.length) {\n    nums[writeIndex++] = 0;\n  }\n}",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "coding-optimization-python",
      "mentorSays": "Let's add one more optimization! We can combine the two-pointer technique with a single pass to make the code even cleaner.\n\nInstead of first moving non-zeros and then filling zeros, we can do it all in one pass using swap operations.",
      "example": "function moveZeroes(nums) {\n  let writeIndex = 0;\n  \n  // Move all non-zero elements to the front\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      // Swap if needed\n      if (i !== writeIndex) {\n        [nums[writeIndex], nums[i]] = [nums[i], nums[writeIndex]];\n      }\n      writeIndex++;\n    }\n  }\n}",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "coding-fill-zeros-python",
      "mentorSays": "Finally, fill the remaining positions (from write_index to the end) with zeros.",
      "example": "def move_zeros(nums):\n    write_index = 0\n    \n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[write_index] = nums[i]\n            write_index += 1\n    \n    # Fill remaining positions with zeros\n    for i in range(write_index, len(nums)):\n        nums[i] = 0",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nnums = [0, 1, 0, 3, 12]\n\nAfter calling move_zeros(nums), the list should be:\n[1, 3, 12, 0, 0]\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nnums = [0, 1, 0, 3, 12]\n\nAfter move_zeros(nums):\nnums = [1, 3, 12, 0, 0]\n\nAll non-zeros are at the front in order, zeros are at the end.",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Java?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-java"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-java"
        }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'writeIndex' or 'readIndex') and put data inside it.\n\nFor example, 'int writeIndex = 0;' creates a variable that stores the number 0. Later, you can use that variable name to refer to it.",
      "example": "int writeIndex = 0;\n\nNow the variable refers to the number 0\nWe can use the variable name to access this value",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a method is in Java?",
      "choices": [
        {
          "label": "Yes, I know methods",
          "next": "parameter-check-java"
        },
        {
          "label": "No, explain methods",
          "next": "function-explanation-java"
        }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A method (Java's version of a function) is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the method does the work, and gives you a result (return value).",
      "example": "public int add(int a, int b) {\n    return a + b;\n}\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-java"
    },
    {
      "stepId": "parameter-check-java",
      "mentorSays": "When we write a method, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "loop-check-java"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-java"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-java",
      "mentorSays": "Parameters are like variables that receive values when you call the method. When you write 'public void moveZeros(int[] nums)', the 'nums' is a parameter - it's a placeholder that will receive an actual array when you call the method.\n\nWhen you call 'moveZeros(new int[]{0, 1, 0, 3, 12})', the array goes into 'nums'. Inside the method, you can use 'nums' to refer to that array.",
      "example": "public void moveZeros(int[] nums) {\n  // 'nums' is a parameter\n}\n\n// When we call it:\nmoveZeros(new int[]{0, 1, 0, 3, 12});\n// The array goes into 'nums'",
      "action": "continue",
      "next": "loop-check-java"
    },
    {
      "stepId": "loop-check-java",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in Java?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "two-pointers-check-java"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-java"
        }
      ]
    },
    {
      "stepId": "two-pointers-check-java",
      "mentorSays": "Do you understand the two-pointer technique?",
      "choices": [
        {
          "label": "Yes, I know two-pointers",
          "next": "coding-start-java"
        },
        {
          "label": "No, explain two-pointers",
          "next": "two-pointers-explanation-java"
        }
      ]
    },
    {
      "stepId": "two-pointers-explanation-java",
      "mentorSays": "The two-pointer technique uses two indices to traverse an array efficiently. For this problem, one pointer tracks where to write non-zero elements, and another scans through the array.\n\nlet writeIndex = 0;\nlet readIndex = 0;\n\n// Two pointers: writeIndex writes, readIndex reads\nwhile (readIndex < nums.length) {\n  if (nums[readIndex] !== 0) {\n    nums[writeIndex++] = nums[readIndex];\n  }\n  readIndex++;\n}\n\nGot it?",
      "example": "let writeIndex = 0;\nlet readIndex = 0;\n\n// Two pointers: writeIndex writes, readIndex reads\nwhile (readIndex < nums.length) {\n  if (nums[readIndex] !== 0) {\n    nums[writeIndex++] = nums[readIndex];\n  }\n  readIndex++;\n}",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "loop-explanation-java",
      "mentorSays": "A loop lets you repeat code multiple times. A 'for' loop runs code for each item in a sequence.\n\nFor example, 'for (int i = 0; i < 3; i++)' means: start at 0, keep going while i is less than 3, and add 1 to i each time. So it runs 3 times: when i is 0, 1, and 2.",
      "example": "for (int i = 0; i < 3; i++) {\n    System.out.println(i);\n}\n\nThis prints: 0, 1, 2",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Perfect! Let's implement the move zeros solution in Java. We'll create a method that takes an array and moves all zeros to the end in-place.",
      "example": "public void moveZeros(int[] nums) {\n    // Your code here\n}",
      "action": "continue",
      "next": "coding-write-index-java"
    },
    {
      "stepId": "coding-write-index-java",
      "mentorSays": "First, let's initialize a writeIndex pointer that tracks where we should write the next non-zero element.",
      "example": "public void moveZeros(int[] nums) {\n    int writeIndex = 0;\n    // writeIndex points to the next position for a non-zero element\n}",
      "action": "continue",
      "next": "coding-loop-java"
    },
    {
      "stepId": "coding-loop-java",
      "mentorSays": "Now, let's loop through the array. For each non-zero element, write it at writeIndex and increment writeIndex.",
      "example": "public void moveZeros(int[] nums) {\n    int writeIndex = 0;\n    \n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != 0) {\n            nums[writeIndex] = nums[i];\n            writeIndex++;\n        }\n    }\n    // After this loop, all non-zeros are at the front\n}",
      "action": "continue",
      "next": "coding-swap-logic-java"
    },
    {
      "stepId": "coding-swap-logic-java",
      "mentorSays": "Let's optimize our solution! Instead of creating a new array, we can use the two-pointer technique to move zeros in-place.\n\nWe use one pointer to track where to write non-zero elements, and another to scan through the array. This is more space-efficient!",
      "example": "function moveZeroes(nums) {\n  let writeIndex = 0;\n  \n  // Move all non-zero elements to the front\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      nums[writeIndex++] = nums[i];\n    }\n  }\n  \n  // Fill remaining positions with zeros\n  while (writeIndex < nums.length) {\n    nums[writeIndex++] = 0;\n  }\n}",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "coding-optimization-java",
      "mentorSays": "Let's add one more optimization! We can combine the two-pointer technique with a single pass to make the code even cleaner.\n\nInstead of first moving non-zeros and then filling zeros, we can do it all in one pass using swap operations.",
      "example": "function moveZeroes(nums) {\n  let writeIndex = 0;\n  \n  // Move all non-zero elements to the front\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      // Swap if needed\n      if (i !== writeIndex) {\n        [nums[writeIndex], nums[i]] = [nums[i], nums[writeIndex]];\n      }\n      writeIndex++;\n    }\n  }\n}",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "coding-fill-zeros-java",
      "mentorSays": "Finally, fill the remaining positions (from writeIndex to the end) with zeros.",
      "example": "public void moveZeros(int[] nums) {\n    int writeIndex = 0;\n    \n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != 0) {\n            nums[writeIndex] = nums[i];\n            writeIndex++;\n        }\n    }\n    \n    // Fill remaining positions with zeros\n    for (int i = writeIndex; i < nums.length; i++) {\n        nums[i] = 0;\n    }\n}",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nnums = [0, 1, 0, 3, 12]\n\nAfter calling moveZeros(nums), the array should be:\n[1, 3, 12, 0, 0]\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nnums = [0, 1, 0, 3, 12]\n\nAfter moveZeros(nums):\nnums = [1, 3, 12, 0, 0]\n\nAll non-zeros are at the front in order, zeros are at the end.",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in C++?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-cpp"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'writeIndex' or 'readIndex') and put data inside it.\n\nFor example, 'int writeIndex = 0;' creates a variable that stores the number 0. Later, you can use that variable name to refer to it.",
      "example": "int writeIndex = 0;\n\nNow the variable refers to the number 0\nWe can use the variable name to access this value",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in C++?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-cpp"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the function does the work, and gives you a result (return value).",
      "example": "int add(int a, int b) {\n    return a + b;\n}\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-cpp"
    },
    {
      "stepId": "parameter-check-cpp",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "loop-check-cpp"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-cpp",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'void moveZeros(vector<int>& nums)', the 'nums' is a parameter - it's a placeholder that will receive an actual vector when you call the function.\n\nWhen you call 'moveZeros({0, 1, 0, 3, 12})', the vector goes into 'nums'. Inside the function, you can use 'nums' to refer to that vector.",
      "example": "void moveZeros(vector<int>& nums) {\n  // 'nums' is a parameter\n}\n\n// When we call it:\nmoveZeros({0, 1, 0, 3, 12});\n// The vector goes into 'nums'",
      "action": "continue",
      "next": "loop-check-cpp"
    },
    {
      "stepId": "loop-check-cpp",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in C++?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "two-pointers-check-cpp"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "two-pointers-check-cpp",
      "mentorSays": "Do you understand the two-pointer technique?",
      "choices": [
        {
          "label": "Yes, I know two-pointers",
          "next": "coding-start-cpp"
        },
        {
          "label": "No, explain two-pointers",
          "next": "two-pointers-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "two-pointers-explanation-cpp",
      "mentorSays": "The two-pointer technique uses two indices to traverse an array efficiently. For this problem, one pointer tracks where to write non-zero elements, and another scans through the array.\n\nlet writeIndex = 0;\nlet readIndex = 0;\n\n// Two pointers: writeIndex writes, readIndex reads\nwhile (readIndex < nums.length) {\n  if (nums[readIndex] !== 0) {\n    nums[writeIndex++] = nums[readIndex];\n  }\n  readIndex++;\n}\n\nGot it?",
      "example": "let writeIndex = 0;\nlet readIndex = 0;\n\n// Two pointers: writeIndex writes, readIndex reads\nwhile (readIndex < nums.length) {\n  if (nums[readIndex] !== 0) {\n    nums[writeIndex++] = nums[readIndex];\n  }\n  readIndex++;\n}",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "loop-explanation-cpp",
      "mentorSays": "A loop lets you repeat code multiple times. A 'for' loop runs code for each item in a sequence.\n\nFor example, 'for (int i = 0; i < 3; i++)' means: start at 0, keep going while i is less than 3, and add 1 to i each time. So it runs 3 times: when i is 0, 1, and 2.",
      "example": "for (int i = 0; i < 3; i++) {\n    cout << i << endl;\n}\n\nThis prints: 0, 1, 2",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Perfect! Let's implement the move zeros solution in C++. We'll create a function that takes a vector and moves all zeros to the end in-place.",
      "example": "void moveZeros(vector<int>& nums) {\n    // Your code here\n}",
      "action": "continue",
      "next": "coding-write-index-cpp"
    },
    {
      "stepId": "coding-write-index-cpp",
      "mentorSays": "First, let's initialize a writeIndex pointer that tracks where we should write the next non-zero element.",
      "example": "void moveZeros(vector<int>& nums) {\n    int writeIndex = 0;\n    // writeIndex points to the next position for a non-zero element\n}",
      "action": "continue",
      "next": "coding-loop-cpp"
    },
    {
      "stepId": "coding-loop-cpp",
      "mentorSays": "Now, let's loop through the vector. For each non-zero element, write it at writeIndex and increment writeIndex.",
      "example": "void moveZeros(vector<int>& nums) {\n    int writeIndex = 0;\n    \n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] != 0) {\n            nums[writeIndex] = nums[i];\n            writeIndex++;\n        }\n    }\n    // After this loop, all non-zeros are at the front\n}",
      "action": "continue",
      "next": "coding-swap-logic-cpp"
    },
    {
      "stepId": "coding-swap-logic-cpp",
      "mentorSays": "Let's optimize our solution! Instead of creating a new array, we can use the two-pointer technique to move zeros in-place.\n\nWe use one pointer to track where to write non-zero elements, and another to scan through the array. This is more space-efficient!",
      "example": "function moveZeroes(nums) {\n  let writeIndex = 0;\n  \n  // Move all non-zero elements to the front\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      nums[writeIndex++] = nums[i];\n    }\n  }\n  \n  // Fill remaining positions with zeros\n  while (writeIndex < nums.length) {\n    nums[writeIndex++] = 0;\n  }\n}",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "coding-optimization-cpp",
      "mentorSays": "Let's add one more optimization! We can combine the two-pointer technique with a single pass to make the code even cleaner.\n\nInstead of first moving non-zeros and then filling zeros, we can do it all in one pass using swap operations.",
      "example": "function moveZeroes(nums) {\n  let writeIndex = 0;\n  \n  // Move all non-zero elements to the front\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      // Swap if needed\n      if (i !== writeIndex) {\n        [nums[writeIndex], nums[i]] = [nums[i], nums[writeIndex]];\n      }\n      writeIndex++;\n    }\n  }\n}",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "coding-fill-zeros-cpp",
      "mentorSays": "Finally, fill the remaining positions (from writeIndex to the end) with zeros.",
      "example": "void moveZeros(vector<int>& nums) {\n    int writeIndex = 0;\n    \n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] != 0) {\n            nums[writeIndex] = nums[i];\n            writeIndex++;\n        }\n    }\n    \n    // Fill remaining positions with zeros\n    for (int i = writeIndex; i < nums.size(); i++) {\n        nums[i] = 0;\n    }\n}",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nnums = [0, 1, 0, 3, 12]\n\nAfter calling moveZeros(nums), the vector should be:\n[1, 3, 12, 0, 0]\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nnums = [0, 1, 0, 3, 12]\n\nAfter moveZeros(nums):\nnums = [1, 3, 12, 0, 0]\n\nAll non-zeros are at the front in order, zeros are at the end.",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-ts"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-ts"
        }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'writeIndex' or 'readIndex') and put data inside it.\n\nFor example, 'let writeIndex: number = 0;' creates a variable that stores the number 0. Later, you can use that variable name to refer to it.",
      "example": "let writeIndex: number = 0;\n\nNow the variable refers to the number 0\nWe can use the variable name to access this value",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-ts"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-ts"
        }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the function does the work, and gives you a result (return value).",
      "example": "function add(a: number, b: number): number {\n  return a + b;\n}\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-ts"
    },
    {
      "stepId": "parameter-check-ts",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "loop-check-ts"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-ts"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-ts",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function moveZeros(nums: number[]): void', the 'nums' is a parameter - it's a placeholder that will receive an actual array when you call the function.\n\nWhen you call 'moveZeros([0, 1, 0, 3, 12])', the array goes into 'nums'. Inside the function, you can use 'nums' to refer to that array.",
      "example": "function moveZeros(nums: number[]): void {\n  // 'nums' is a parameter\n}\n\n// When we call it:\nmoveZeros([0, 1, 0, 3, 12]);\n// The array goes into 'nums'",
      "action": "continue",
      "next": "loop-check-ts"
    },
    {
      "stepId": "loop-check-ts",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "two-pointers-check-ts"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-ts"
        }
      ]
    },
    {
      "stepId": "two-pointers-check-ts",
      "mentorSays": "Do you understand the two-pointer technique?",
      "choices": [
        {
          "label": "Yes, I know two-pointers",
          "next": "coding-start-ts"
        },
        {
          "label": "No, explain two-pointers",
          "next": "two-pointers-explanation-ts"
        }
      ]
    },
    {
      "stepId": "two-pointers-explanation-ts",
      "mentorSays": "The two-pointer technique uses two indices to traverse an array efficiently. For this problem, one pointer tracks where to write non-zero elements, and another scans through the array.\n\nlet writeIndex = 0;\nlet readIndex = 0;\n\n// Two pointers: writeIndex writes, readIndex reads\nwhile (readIndex < nums.length) {\n  if (nums[readIndex] !== 0) {\n    nums[writeIndex++] = nums[readIndex];\n  }\n  readIndex++;\n}\n\nGot it?",
      "example": "let writeIndex = 0;\nlet readIndex = 0;\n\n// Two pointers: writeIndex writes, readIndex reads\nwhile (readIndex < nums.length) {\n  if (nums[readIndex] !== 0) {\n    nums[writeIndex++] = nums[readIndex];\n  }\n  readIndex++;\n}",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "loop-explanation-ts",
      "mentorSays": "A loop lets you repeat code multiple times. A 'for' loop runs code for each item in a sequence.\n\nFor example, 'for (let i = 0; i < 3; i++)' means: start at 0, keep going while i is less than 3, and add 1 to i each time. So it runs 3 times: when i is 0, 1, and 2.",
      "example": "for (let i = 0; i < 3; i++) {\n  console.log(i);\n}\n\nThis prints: 0, 1, 2",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Perfect! Let's implement the move zeros solution in TypeScript. We'll create a function that takes an array and moves all zeros to the end in-place.",
      "example": "function moveZeros(nums: number[]): void {\n  // Your code here\n}",
      "action": "continue",
      "next": "coding-write-index-ts"
    },
    {
      "stepId": "coding-write-index-ts",
      "mentorSays": "First, let's initialize a writeIndex pointer that tracks where we should write the next non-zero element.",
      "example": "function moveZeros(nums: number[]): void {\n  let writeIndex: number = 0;\n  // writeIndex points to the next position for a non-zero element\n}",
      "action": "continue",
      "next": "coding-loop-ts"
    },
    {
      "stepId": "coding-loop-ts",
      "mentorSays": "Now, let's loop through the array. For each non-zero element, write it at writeIndex and increment writeIndex.",
      "example": "function moveZeros(nums: number[]): void {\n  let writeIndex: number = 0;\n  \n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      nums[writeIndex] = nums[i];\n      writeIndex++;\n    }\n  }\n  // After this loop, all non-zeros are at the front\n}",
      "action": "continue",
      "next": "coding-swap-logic-ts"
    },
    {
      "stepId": "coding-swap-logic-ts",
      "mentorSays": "Let's optimize our solution! Instead of creating a new array, we can use the two-pointer technique to move zeros in-place.\n\nWe use one pointer to track where to write non-zero elements, and another to scan through the array. This is more space-efficient!",
      "example": "function moveZeroes(nums) {\n  let writeIndex = 0;\n  \n  // Move all non-zero elements to the front\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      nums[writeIndex++] = nums[i];\n    }\n  }\n  \n  // Fill remaining positions with zeros\n  while (writeIndex < nums.length) {\n    nums[writeIndex++] = 0;\n  }\n}",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "coding-optimization-ts",
      "mentorSays": "Let's add one more optimization! We can combine the two-pointer technique with a single pass to make the code even cleaner.\n\nInstead of first moving non-zeros and then filling zeros, we can do it all in one pass using swap operations.",
      "example": "function moveZeroes(nums) {\n  let writeIndex = 0;\n  \n  // Move all non-zero elements to the front\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      // Swap if needed\n      if (i !== writeIndex) {\n        [nums[writeIndex], nums[i]] = [nums[i], nums[writeIndex]];\n      }\n      writeIndex++;\n    }\n  }\n}",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "coding-fill-zeros-ts",
      "mentorSays": "Finally, fill the remaining positions (from writeIndex to the end) with zeros.",
      "example": "function moveZeros(nums: number[]): void {\n  let writeIndex: number = 0;\n  \n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      nums[writeIndex] = nums[i];\n      writeIndex++;\n    }\n  }\n  \n  // Fill remaining positions with zeros\n  for (let i = writeIndex; i < nums.length; i++) {\n    nums[i] = 0;\n  }\n}",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nnums = [0, 1, 0, 3, 12]\n\nAfter calling moveZeros(nums), the array should be:\n[1, 3, 12, 0, 0]\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nnums = [0, 1, 0, 3, 12]\n\nAfter moveZeros(nums):\nnums = [1, 3, 12, 0, 0]\n\nAll non-zeros are at the front in order, zeros are at the end.",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "language-selection-new-array",
      "mentorSays": "Great! Now let's code the new array approach. Which programming language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "coding-new-array-js"
        },
        {
          "label": "Python",
          "next": "coding-new-array-python"
        },
        {
          "label": "Java",
          "next": "coding-new-array-java"
        },
        {
          "label": "C++",
          "next": "coding-new-array-cpp"
        },
        {
          "label": "TypeScript",
          "next": "coding-new-array-ts"
        }
      ]
    },
    {
      "stepId": "coding-new-array-js",
      "mentorSays": "The new array approach creates a new array with non-zeros first, then zeros. This works but uses extra space.",
      "example": "function moveZeros(nums) {\n  const result = [];\n  let zeroCount = 0;\n  \n  // Add all non-zeros\n  for (let num of nums) {\n    if (num !== 0) {\n      result.push(num);\n    } else {\n      zeroCount++;\n    }\n  }\n  \n  // Add zeros at the end\n  for (let i = 0; i < zeroCount; i++) {\n    result.push(0);\n  }\n  \n  // Copy back to original array\n  for (let i = 0; i < nums.length; i++) {\n    nums[i] = result[i];\n  }\n}",
      "action": "continue",
      "next": "recommend-two-pointers"
    },
    {
      "stepId": "coding-new-array-python",
      "mentorSays": "The new array approach creates a new list with non-zeros first, then zeros. This works but uses extra space.",
      "example": "def move_zeros(nums):\n    result = []\n    zero_count = 0\n    \n    # Add all non-zeros\n    for num in nums:\n        if num != 0:\n            result.append(num)\n        else:\n            zero_count += 1\n    \n    # Add zeros at the end\n    result.extend([0] * zero_count)\n    \n    # Copy back to original list\n    nums[:] = result",
      "action": "continue",
      "next": "recommend-two-pointers"
    },
    {
      "stepId": "coding-new-array-java",
      "mentorSays": "The new array approach creates a new array with non-zeros first, then zeros. This works but uses extra space.",
      "example": "public void moveZeros(int[] nums) {\n    List<Integer> result = new ArrayList<>();\n    int zeroCount = 0;\n    \n    // Add all non-zeros\n    for (int num : nums) {\n        if (num != 0) {\n            result.add(num);\n        } else {\n            zeroCount++;\n        }\n    }\n    \n    // Add zeros at the end\n    for (int i = 0; i < zeroCount; i++) {\n        result.add(0);\n    }\n    \n    // Copy back to original array\n    for (int i = 0; i < nums.length; i++) {\n        nums[i] = result.get(i);\n    }\n}",
      "action": "continue",
      "next": "recommend-two-pointers"
    },
    {
      "stepId": "coding-new-array-cpp",
      "mentorSays": "The new array approach creates a new vector with non-zeros first, then zeros. This works but uses extra space.",
      "example": "void moveZeros(vector<int>& nums) {\n    vector<int> result;\n    int zeroCount = 0;\n    \n    // Add all non-zeros\n    for (int num : nums) {\n        if (num != 0) {\n            result.push_back(num);\n        } else {\n            zeroCount++;\n        }\n    }\n    \n    // Add zeros at the end\n    for (int i = 0; i < zeroCount; i++) {\n        result.push_back(0);\n    }\n    \n    // Copy back to original vector\n    nums = result;\n}",
      "action": "continue",
      "next": "recommend-two-pointers"
    },
    {
      "stepId": "coding-new-array-ts",
      "mentorSays": "The new array approach creates a new array with non-zeros first, then zeros. This works but uses extra space.",
      "example": "function moveZeros(nums: number[]): void {\n  const result: number[] = [];\n  let zeroCount = 0;\n  \n  // Add all non-zeros\n  for (let num of nums) {\n    if (num !== 0) {\n      result.push(num);\n    } else {\n      zeroCount++;\n    }\n  }\n  \n  // Add zeros at the end\n  for (let i = 0; i < zeroCount; i++) {\n    result.push(0);\n  }\n  \n  // Copy back to original array\n  for (let i = 0; i < nums.length; i++) {\n    nums[i] = result[i];\n  }\n}",
      "action": "continue",
      "next": "recommend-two-pointers"
    },
    {
      "stepId": "recommend-two-pointers",
      "mentorSays": "Great job! You've successfully implemented the new array approach. This solution works, but there's a more efficient method using two pointers.\n\nThe two pointers method is more space-efficient (O(1) space instead of O(n)) and works in-place. Would you like to learn the two pointers approach now?",
      "choices": [
        {
          "label": "Yes, teach me the two pointers approach",
          "next": "explore-two-pointers"
        },
        {
          "label": "No, I'm done for now",
          "next": "final"
        }
      ]
    },
    {
      "stepId": "final",
      "mentorSays": "🎉 Well done! You've learned to think through the Move Zeros to End problem. You understand what the problem asks for, how to use two pointers to rearrange elements in-place, and you've explored different approaches to solve it.\n\nThis kind of thinking—using two pointers to rearrange elements efficiently—is essential for solving many algorithm problems. Keep practicing!",
      "action": "continue"
    }
  ]
}