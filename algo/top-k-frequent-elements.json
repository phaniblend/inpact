{
  "id": "top-k-frequent-elements",
  "title": "Top K Frequent Elements",
  "difficulty": "medium",
  "pattern": "frequency-count + bucket",
  "language": "javascript",
  "quality": "PERFECT",
  "version": "v1.0-fixed",
  "flow": [
    {
      "stepId": "problem-statement",
      "mentorSays": "You are given a list of numbers and a number **k**.\n\nYour task is to return the **k numbers that appear most frequently** in the list.\n\nOrder of the result does not matter.",
      "example": "Numbers: [1,1,1,2,2,3]\nk = 2",
      "action": "next"
    },
    {
      "stepId": "tiny-example",
      "mentorSays": "Let’s start small.\n\nNumbers: [1, 2, 2, 3]\nk = 1\n\nThe number 2 appears the most.\n\nSo the answer is:\n[2]",
      "action": "next"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Pause and think.\n\nWhat do we need to know first before choosing the top k elements?\n\n• The order of numbers?\n• Or how many times each number appears?",
      "choices": [
        {
          "label": "We need to know how many times each number appears",
          "next": "frequency-idea"
        },
        {
          "label": "Order matters more",
          "next": "frequency-idea"
        }
      ]
    },
    {
      "stepId": "frequency-idea",
      "mentorSays": "Correct.\n\nThe key is **frequency** — how often each number appears.\n\nSo the first step is to **count occurrences** of each number.",
      "action": "next"
    },
    {
      "stepId": "concept-frequency-map",
      "mentorSays": "To count occurrences, we use an **object**.\n\nAn object stores data as **key → value** pairs.\n\nExample:\nNumbers: [1,1,2]\n\nFrequency map:\n{\n  1: 2,\n  2: 1\n}",
      "action": "next"
    },
    {
      "stepId": "pain-point",
      "mentorSays": "Now we know the frequencies.\n\nBut how do we efficiently find the **top k**?\n\nIf we sort all elements by frequency, it works — but sorting does extra work.",
      "action": "next"
    },
    {
      "stepId": "optimized-idea",
      "mentorSays": "We can avoid sorting by using **buckets**.\n\nIdea:\n• The maximum frequency is the length of the list\n• Create buckets where index = frequency\n• Place numbers into buckets based on how often they appear",
      "action": "next"
    },
    {
      "stepId": "bucket-intuition",
      "mentorSays": "Example:\n\nNumbers: [1,1,1,2,2,3]\n\nFrequencies:\n1 → 3\n2 → 2\n3 → 1\n\nBuckets:\nindex 1: [3]\nindex 2: [2]\nindex 3: [1]\n\nWe collect from the highest index downward.",
      "action": "next"
    },
    {
      "stepId": "pseudocode",
      "mentorSays": "Let’s write the logic as steps.\n\nNo JavaScript yet.",
      "pseudocode": [
        "create frequency map",
        "create empty buckets array",
        "for each number in frequency map:",
        "  place number into bucket based on its frequency",
        "initialize empty result list",
        "iterate buckets from highest frequency down:",
        "  add numbers to result until k elements collected",
        "return result"
      ],
      "action": "next"
    },
    {
      "stepId": "coding-intro",
      "mentorSays": "Now that the logic is clear, we can translate it into JavaScript.\n\nType the code yourself to understand how buckets work.",
      "action": "next"
    },
    {
      "stepId": "coding-js",
      "mentorSays": "Here is the JavaScript implementation.",
      "code": "function topKFrequent(nums, k) {\n  const freq = {};\n\n  for (let num of nums) {\n    freq[num] = (freq[num] || 0) + 1;\n  }\n\n  const buckets = Array(nums.length + 1).fill(null).map(() => []);\n\n  for (let num in freq) {\n    const count = freq[num];\n    buckets[count].push(Number(num));\n  }\n\n  const result = [];\n\n  for (let i = buckets.length - 1; i >= 0 && result.length < k; i--) {\n    for (let num of buckets[i]) {\n      result.push(num);\n      if (result.length === k) break;\n    }\n  }\n\n  return result;\n}",
      "action": "next"
    },
    {
      "stepId": "final-check",
      "mentorSays": "Example check:\n\nNumbers: [1,1,1,2,2,3]\nk = 2\n\nOutput:\n[1, 2]\n\nThis confirms the frequency + bucket approach works correctly.",
      "action": "complete"
    }
  ]
}
