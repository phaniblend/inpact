{
  "id": "top-k-frequent-elements",
  "title": "Top K frequent elements",
  "pattern": "hash-map",
  "difficulty": "medium",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what the Top K Frequent Elements problem asks for\n2. Use hash maps to count element frequencies\n3. Sort or use heaps to find the K most frequent elements\n4. Implement the solution step by step in your chosen language",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Perfect! Now let's understand what the Top K Frequent Elements problem is asking.\n\nImagine you have an array of numbers: [1, 1, 1, 2, 2, 3]\n\nAnd you're told: \"Find the 2 most frequent elements.\"\n\nLet's count how many times each number appears:\n- 1 appears 3 times\n- 2 appears 2 times\n- 3 appears 1 time\n\nThe 2 most frequent elements are 1 (appears 3 times) and 2 (appears 2 times).\n\nSo the answer is [1, 2]. Note: The order can vary, but typically we return them in order of frequency (most frequent first).\n\nThat's what the problem wants: the K elements that appear most frequently in the array.",
      "example": "nums = [1, 1, 1, 2, 2, 3]\nK = 2\n\nCount frequencies:\n- 1 appears 3 times (most frequent)\n- 2 appears 2 times (second most frequent)\n- 3 appears 1 time\n\nAnswer: [1, 2]\n\nAnother example:\nnums = [4, 1, -1, 2, -1, 2, 3]\nK = 2\n\nCount frequencies:\n- -1 appears 2 times\n- 2 appears 2 times\n- 1 appears 1 time\n- 3 appears 1 time\n- 4 appears 1 time\n\nTop 2: [-1, 2] (both appear 2 times)",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Now that you understand what the problem wants, here's the real question:\n\nHow would YOU find the K most frequent elements?\n\nThink about it for a moment. What approach feels natural to you?",
      "choices": [
        {
          "label": "Count frequencies with a hash map, then sort by frequency",
          "next": "explore-hashmap-sort"
        },
        {
          "label": "Count frequencies, then use a heap to get top K",
          "next": "explore-heap"
        },
        {
          "label": "Use bucket sort based on frequencies",
          "next": "explore-bucket"
        }
      ]
    },
    {
      "stepId": "explore-hashmap-sort",
      "mentorSays": "Excellent approach! This is straightforward and easy to understand. Here's the plan:\n\n1. **Count frequencies**: Use a hash map to count how many times each element appears\n2. **Sort by frequency**: Convert the hash map entries to an array and sort by frequency (descending)\n3. **Take top K**: Return the first K elements\n\nLet's trace this with [1, 1, 1, 2, 2, 3] and K = 2:\n\n- **Step 1**: Count frequencies\n  - freq[1] = 3\n  - freq[2] = 2\n  - freq[3] = 1\n\n- **Step 2**: Convert to array and sort by frequency\n  - [[1, 3], [2, 2], [3, 1]] â†’ sorted: [[1, 3], [2, 2], [3, 1]]\n\n- **Step 3**: Take first K = 2\n  - Answer: [1, 2]\n\nThis works perfectly! Time complexity: O(n log n) due to sorting. Space complexity: O(n) for the hash map.\n\nNow let's code it step by step!",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "explore-heap",
      "mentorSays": "Great thinking! Using a heap (priority queue) is more efficient for large datasets. Here's the plan:\n\n1. **Count frequencies**: Use a hash map to count how many times each element appears\n2. **Build a min-heap of size K**: Keep only the K most frequent elements in the heap\n3. **Return the heap elements**: Extract all elements from the heap\n\nLet's trace this with [1, 1, 1, 2, 2, 3] and K = 2:\n\n- **Step 1**: Count frequencies\n  - freq[1] = 3\n  - freq[2] = 2\n  - freq[3] = 1\n\n- **Step 2**: Build min-heap of size K\n  - Add [1, 3]: heap = [[1, 3]]\n  - Add [2, 2]: heap = [[2, 2], [1, 3]] (min-heap by frequency)\n  - Add [3, 1]: Compare with min [2, 2]. Since 1 < 2, we remove [2, 2] and add [3, 1]. But wait, we want max frequencies, so we use a min-heap that keeps the K largest frequencies.\n\nActually, we use a min-heap that compares by frequency. We keep the K elements with highest frequencies.\n\n- **Step 3**: Extract: [1, 2]\n\nThis is more efficient: O(n log K) time instead of O(n log n). Space: O(n) for hash map + O(K) for heap.\n\nWould you like to learn the simpler hash map + sort approach first?",
      "choices": [
        {
          "label": "Yes, teach me the hash map + sort approach",
          "next": "explore-hashmap-sort"
        },
        {
          "label": "No, I want to code the heap approach",
          "next": "language-selection-heap"
        }
      ]
    },
    {
      "stepId": "explore-bucket",
      "mentorSays": "Clever idea! Bucket sort can be very efficient if we know the maximum frequency. Here's the plan:\n\n1. **Count frequencies**: Use a hash map to count frequencies\n2. **Create buckets**: Create an array where index i stores all elements with frequency i\n3. **Collect from buckets**: Start from the highest frequency bucket and collect K elements\n\nLet's trace this with [1, 1, 1, 2, 2, 3] and K = 2:\n\n- **Step 1**: Count frequencies\n  - freq[1] = 3\n  - freq[2] = 2\n  - freq[3] = 1\n\n- **Step 2**: Create buckets\n  - bucket[1] = [3]\n  - bucket[2] = [2]\n  - bucket[3] = [1]\n\n- **Step 3**: Collect from highest frequency\n  - From bucket[3]: [1]\n  - From bucket[2]: [2]\n  - We have K = 2 elements: [1, 2]\n\nThis is O(n) time! However, it requires knowing the maximum frequency, and we need to handle the case where multiple elements have the same frequency.\n\nFor now, let's learn the simpler hash map + sort approach, which is easier to understand and implement.",
      "action": "continue",
      "next": "explore-hashmap-sort"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Great! Now let's code the hash map + sort solution. Which programming language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "variable-check-js"
        },
        {
          "label": "Python",
          "next": "variable-check-python"
        },
        {
          "label": "Java",
          "next": "variable-check-java"
        },
        {
          "label": "C++",
          "next": "variable-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "variable-check-ts"
        }
      ]
    },
    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-js"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-js"
        }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'freq' or 'count') and put data inside it.\n\nFor example, 'let freq = {};' creates a variable that stores an object (hash map). Later, you can use that variable name to refer to it.",
      "example": "let freq = {};\n\nNow the variable refers to an empty object\nWe can use the variable name to access this object",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-js"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-js"
        }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the function does the work, and gives you a result (return value).",
      "example": "function add(a, b) {\n  return a + b;\n}\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-js"
    },
    {
      "stepId": "parameter-check-js",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "loop-check-js"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-js"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-js",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function topKFrequent(nums, k)', the 'nums' and 'k' are parameters - they're placeholders that will receive actual values when you call the function.\n\nWhen you call 'topKFrequent([1, 1, 1, 2, 2, 3], 2)', the array [1, 1, 1, 2, 2, 3] goes into 'nums' and 2 goes into 'k'.",
      "example": "function topKFrequent(nums, k) {\n  // 'nums' and 'k' are parameters\n}\n\n// When we call it:\ntopKFrequent([1, 1, 1, 2, 2, 3], 2);\n// The array goes into 'nums', 2 goes into 'k'",
      "action": "continue",
      "next": "loop-check-js"
    },
    {
      "stepId": "loop-check-js",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "heap-check-js"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-js"
        }
      ]
    },
    {
      "stepId": "heap-check-js",
      "mentorSays": "Do you understand how heaps/priority queues work?",
      "choices": [
        {
          "label": "Yes, I know heap",
          "next": "coding-start-js"
        },
        {
          "label": "No, explain heap",
          "next": "heap-explanation-js"
        }
      ]
    },
    {
      "stepId": "heap-explanation-js",
      "mentorSays": "A heap is a tree-based data structure where the parent is always greater (max-heap) or smaller (min-heap) than its children. For top K elements, we use a min-heap of size K to keep track of the K most frequent elements.\n\n// Min-heap keeps K largest elements\nlet heap = [];\n\nfor (let [num, freq] of Object.entries(count)) {\n  if (heap.length < k) {\n    heap.push([freq, num]);\n  } else if (freq > heap[0][0]) {\n    heap[0] = [freq, num];\n    heapifyDown(heap);\n  }\n}\n\nGot it?",
      "example": "// Min-heap keeps K largest elements\nlet heap = [];\n\nfor (let [num, freq] of Object.entries(count)) {\n  if (heap.length < k) {\n    heap.push([freq, num]);\n  } else if (freq > heap[0][0]) {\n    heap[0] = [freq, num];\n    heapifyDown(heap);\n  }\n}",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "loop-explanation-js",
      "mentorSays": "A loop lets you repeat code multiple times. A 'for' loop runs code for each item in a sequence.\n\nFor example, 'for (let i = 0; i < 3; i++)' means: start at 0, keep going while i is less than 3, and add 1 to i each time. So it runs 3 times: when i is 0, 1, and 2.",
      "example": "for (let i = 0; i < 3; i++) {\n  console.log(i);\n}\n\nThis prints: 0, 1, 2",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Perfect! Let's implement the top K frequent elements solution in JavaScript. We'll create a function that takes an array and K, then returns the K most frequent elements.",
      "example": "function topKFrequent(nums, k) {\n  \n}",
      "action": "continue",
      "next": "coding-count-freq-js"
    },
    {
      "stepId": "coding-count-freq-js",
      "mentorSays": "First, let's count the frequency of each element using a hash map (object in JavaScript).",
      "example": "function topKFrequent(nums, k) {\n  // Count frequencies\n  let freq = {};\n  for (let num of nums) {\n    freq[num] = (freq[num] || 0) + 1;\n  }\n  // freq = {1: 3, 2: 2, 3: 1} for [1, 1, 1, 2, 2, 3]\n}",
      "action": "continue",
      "next": "coding-convert-array-js"
    },
    {
      "stepId": "coding-convert-array-js",
      "mentorSays": "Now, let's convert the hash map entries to an array of [element, frequency] pairs so we can sort them.",
      "example": "function topKFrequent(nums, k) {\n  let freq = {};\n  for (let num of nums) {\n    freq[num] = (freq[num] || 0) + 1;\n  }\n  \n  // Convert to array of [element, frequency] pairs\n  let entries = Object.entries(freq);\n  // entries = [[\"1\", 3], [\"2\", 2], [\"3\", 1]]\n  // Note: Object.entries converts keys to strings, so we need to convert back\n  let pairs = Object.keys(freq).map(key => [parseInt(key), freq[key]]);\n  // pairs = [[1, 3], [2, 2], [3, 1]]\n}",
      "action": "continue",
      "next": "coding-sort-js"
    },
    {
      "stepId": "coding-sort-js",
      "mentorSays": "Now, let's sort the pairs by frequency in descending order (highest frequency first).",
      "example": "function topKFrequent(nums, k) {\n  let freq = {};\n  for (let num of nums) {\n    freq[num] = (freq[num] || 0) + 1;\n  }\n  \n  let pairs = Object.keys(freq).map(key => [parseInt(key), freq[key]]);\n  \n  // Sort by frequency (descending)\n  pairs.sort((a, b) => b[1] - a[1]);\n  // pairs = [[1, 3], [2, 2], [3, 1]] (already sorted)\n}",
      "action": "continue",
      "next": "coding-heap-operations-js"
    },
    {
      "stepId": "coding-heap-operations-js",
      "mentorSays": "Let's use a min-heap to efficiently find the top K frequent elements!\n\nWe maintain a min-heap of size K. For each element, if its frequency is greater than the minimum in the heap, we replace it. This keeps the K most frequent elements in the heap.",
      "example": "function topKFrequent(nums, k) {\n  let count = {};\n  for (let num of nums) {\n    count[num] = (count[num] || 0) + 1;\n  }\n  \n  // Use min-heap to keep top K\n  let heap = [];\n  for (let [num, freq] of Object.entries(count)) {\n    if (heap.length < k) {\n      heap.push([freq, num]);\n    } else if (freq > heap[0][0]) {\n      heap[0] = [freq, num];\n      // Re-heapify\n    }\n  }\n  \n  return heap.map(item => item[1]);\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "coding-extract-result-js",
      "mentorSays": "Finally, let's extract the top K elements from our heap!\n\nAfter building the heap with the K most frequent elements, we need to extract them. Since we stored [frequency, number] pairs, we extract just the numbers.",
      "example": "function topKFrequent(nums, k) {\n  let count = {};\n  for (let num of nums) {\n    count[num] = (count[num] || 0) + 1;\n  }\n  \n  // Use min-heap to keep top K\n  let heap = [];\n  for (let [num, freq] of Object.entries(count)) {\n    if (heap.length < k) {\n      heap.push([freq, num]);\n    } else if (freq > heap[0][0]) {\n      heap[0] = [freq, num];\n      // Re-heapify\n    }\n  }\n  \n  // Extract the numbers from heap\n  return heap.map(item => parseInt(item[1]));\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "coding-take-k-js",
      "mentorSays": "Finally, let's take the first K elements and return just the element values (not the frequencies).",
      "example": "function topKFrequent(nums, k) {\n  let freq = {};\n  for (let num of nums) {\n    freq[num] = (freq[num] || 0) + 1;\n  }\n  \n  let pairs = Object.keys(freq).map(key => [parseInt(key), freq[key]]);\n  pairs.sort((a, b) => b[1] - a[1]);\n  \n  // Take first K elements and return just the element values\n  return pairs.slice(0, k).map(pair => pair[0]);\n  // Returns [1, 2] for K = 2\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nnums = [1, 1, 1, 2, 2, 3]\nK = 2\n\nExpected output: [1, 2]\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nnums = [1, 1, 1, 2, 2, 3]\nK = 2\n\nExpected output: [1, 2]\n\nBecause 1 appears 3 times (most frequent) and 2 appears 2 times (second most frequent).",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Python?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-python"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-python"
        }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'freq' or 'count') and put data inside it.\n\nFor example, 'freq = {}' creates a variable that stores a dictionary (hash map). Later, you can use that variable name to refer to it.",
      "example": "freq = {}\n\nNow the variable refers to an empty dictionary\nWe can use the variable name to access this dictionary",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Python?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-python"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-python"
        }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the function does the work, and gives you a result (return value).",
      "example": "def add(a, b):\n    return a + b\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-python"
    },
    {
      "stepId": "parameter-check-python",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "loop-check-python"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-python"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-python",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'def top_k_frequent(nums, k):', the 'nums' and 'k' are parameters - they're placeholders that will receive actual values when you call the function.\n\nWhen you call 'top_k_frequent([1, 1, 1, 2, 2, 3], 2)', the list [1, 1, 1, 2, 2, 3] goes into 'nums' and 2 goes into 'k'.",
      "example": "def top_k_frequent(nums, k):\n  # 'nums' and 'k' are parameters\n\n# When we call it:\ntop_k_frequent([1, 1, 1, 2, 2, 3], 2)\n# The list goes into 'nums', 2 goes into 'k'",
      "action": "continue",
      "next": "loop-check-python"
    },
    {
      "stepId": "loop-check-python",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in Python?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "heap-check-python"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-python"
        }
      ]
    },
    {
      "stepId": "heap-check-python",
      "mentorSays": "Do you understand how heaps/priority queues work?",
      "choices": [
        {
          "label": "Yes, I know heap",
          "next": "coding-start-python"
        },
        {
          "label": "No, explain heap",
          "next": "heap-explanation-python"
        }
      ]
    },
    {
      "stepId": "heap-explanation-python",
      "mentorSays": "A heap is a tree-based data structure where the parent is always greater (max-heap) or smaller (min-heap) than its children. For top K elements, we use a min-heap of size K to keep track of the K most frequent elements.\n\n// Min-heap keeps K largest elements\nlet heap = [];\n\nfor (let [num, freq] of Object.entries(count)) {\n  if (heap.length < k) {\n    heap.push([freq, num]);\n  } else if (freq > heap[0][0]) {\n    heap[0] = [freq, num];\n    heapifyDown(heap);\n  }\n}\n\nGot it?",
      "example": "// Min-heap keeps K largest elements\nlet heap = [];\n\nfor (let [num, freq] of Object.entries(count)) {\n  if (heap.length < k) {\n    heap.push([freq, num]);\n  } else if (freq > heap[0][0]) {\n    heap[0] = [freq, num];\n    heapifyDown(heap);\n  }\n}",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "loop-explanation-python",
      "mentorSays": "A loop lets you repeat code multiple times. A 'for' loop in Python runs code for each item in a sequence.\n\nFor example, 'for i in range(3)' means: run the code 3 times, with i being 0, then 1, then 2.",
      "example": "for i in range(3):\n    print(i)\n\nThis prints: 0, 1, 2",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Perfect! Let's implement the top K frequent elements solution in Python. We'll create a function that takes a list and K, then returns the K most frequent elements.",
      "example": "def top_k_frequent(nums, k):\n    \n    pass",
      "action": "continue",
      "next": "coding-count-freq-python"
    },
    {
      "stepId": "coding-count-freq-python",
      "mentorSays": "First, let's count the frequency of each element using a dictionary (hash map in Python). We can use Counter from collections for this, or build it manually.",
      "example": "def top_k_frequent(nums, k):\n    # Count frequencies\n    from collections import Counter\n    freq = Counter(nums)\n    # freq = Counter({1: 3, 2: 2, 3: 1}) for [1, 1, 1, 2, 2, 3]\n    \n    # Or manually:\n    # freq = {}\n    # for num in nums:\n    #     freq[num] = freq.get(num, 0) + 1",
      "action": "continue",
      "next": "coding-heap-operations-python"
    },
    {
      "stepId": "coding-heap-operations-python",
      "mentorSays": "Let's use a min-heap to efficiently find the top K frequent elements!\n\nWe maintain a min-heap of size K. For each element, if its frequency is greater than the minimum in the heap, we replace it. This keeps the K most frequent elements in the heap.",
      "example": "function topKFrequent(nums, k) {\n  let count = {};\n  for (let num of nums) {\n    count[num] = (count[num] || 0) + 1;\n  }\n  \n  // Use min-heap to keep top K\n  let heap = [];\n  for (let [num, freq] of Object.entries(count)) {\n    if (heap.length < k) {\n      heap.push([freq, num]);\n    } else if (freq > heap[0][0]) {\n      heap[0] = [freq, num];\n      // Re-heapify\n    }\n  }\n  \n  return heap.map(item => item[1]);\n}",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "coding-extract-result-python",
      "mentorSays": "Finally, let's extract the top K elements from our heap!\n\nAfter building the heap with the K most frequent elements, we need to extract them. Since we stored [frequency, number] pairs, we extract just the numbers.",
      "example": "function topKFrequent(nums, k) {\n  let count = {};\n  for (let num of nums) {\n    count[num] = (count[num] || 0) + 1;\n  }\n  \n  // Use min-heap to keep top K\n  let heap = [];\n  for (let [num, freq] of Object.entries(count)) {\n    if (heap.length < k) {\n      heap.push([freq, num]);\n    } else if (freq > heap[0][0]) {\n      heap[0] = [freq, num];\n      // Re-heapify\n    }\n  }\n  \n  // Extract the numbers from heap\n  return heap.map(item => parseInt(item[1]));\n}",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "coding-sort-python",
      "mentorSays": "Now, let's sort the dictionary items by frequency in descending order and take the first K elements.",
      "example": "def top_k_frequent(nums, k):\n    from collections import Counter\n    freq = Counter(nums)\n    \n    # Sort by frequency (descending) and take first K\n    sorted_items = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n    # sorted_items = [(1, 3), (2, 2), (3, 1)]\n    \n    # Take first K elements and return just the keys\n    return [item[0] for item in sorted_items[:k]]\n    # Returns [1, 2] for K = 2",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nnums = [1, 1, 1, 2, 2, 3]\nK = 2\n\nExpected output: [1, 2]\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nnums = [1, 1, 1, 2, 2, 3]\nK = 2\n\nExpected output: [1, 2]\n\nBecause 1 appears 3 times (most frequent) and 2 appears 2 times (second most frequent).",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Java?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-java"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-java"
        }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'freq' or 'count') and put data inside it.\n\nFor example, 'Map<Integer, Integer> freq = new HashMap<>();' creates a variable that stores a hash map. Later, you can use that variable name to refer to it.",
      "example": "Map<Integer, Integer> freq = new HashMap<>();\n\nNow the variable refers to an empty hash map\nWe can use the variable name to access this hash map",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a method is in Java?",
      "choices": [
        {
          "label": "Yes, I know methods",
          "next": "parameter-check-java"
        },
        {
          "label": "No, explain methods",
          "next": "function-explanation-java"
        }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A method (Java's version of a function) is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the method does the work, and gives you a result (return value).",
      "example": "public int add(int a, int b) {\n    return a + b;\n}\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-java"
    },
    {
      "stepId": "parameter-check-java",
      "mentorSays": "When we write a method, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "loop-check-java"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-java"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-java",
      "mentorSays": "Parameters are like variables that receive values when you call the method. When you write 'public int[] topKFrequent(int[] nums, int k)', the 'nums' and 'k' are parameters - they're placeholders that will receive actual values when you call the method.\n\nWhen you call 'topKFrequent(new int[]{1, 1, 1, 2, 2, 3}, 2)', the array goes into 'nums' and 2 goes into 'k'.",
      "example": "public int[] topKFrequent(int[] nums, int k) {\n  // 'nums' and 'k' are parameters\n}\n\n// When we call it:\ntopKFrequent(new int[]{1, 1, 1, 2, 2, 3}, 2);\n// The array goes into 'nums', 2 goes into 'k'",
      "action": "continue",
      "next": "loop-check-java"
    },
    {
      "stepId": "loop-check-java",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in Java?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "heap-check-java"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-java"
        }
      ]
    },
    {
      "stepId": "heap-check-java",
      "mentorSays": "Do you understand how heaps/priority queues work?",
      "choices": [
        {
          "label": "Yes, I know heap",
          "next": "coding-start-java"
        },
        {
          "label": "No, explain heap",
          "next": "heap-explanation-java"
        }
      ]
    },
    {
      "stepId": "heap-explanation-java",
      "mentorSays": "A heap is a tree-based data structure where the parent is always greater (max-heap) or smaller (min-heap) than its children. For top K elements, we use a min-heap of size K to keep track of the K most frequent elements.\n\n// Min-heap keeps K largest elements\nlet heap = [];\n\nfor (let [num, freq] of Object.entries(count)) {\n  if (heap.length < k) {\n    heap.push([freq, num]);\n  } else if (freq > heap[0][0]) {\n    heap[0] = [freq, num];\n    heapifyDown(heap);\n  }\n}\n\nGot it?",
      "example": "// Min-heap keeps K largest elements\nlet heap = [];\n\nfor (let [num, freq] of Object.entries(count)) {\n  if (heap.length < k) {\n    heap.push([freq, num]);\n  } else if (freq > heap[0][0]) {\n    heap[0] = [freq, num];\n    heapifyDown(heap);\n  }\n}",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "loop-explanation-java",
      "mentorSays": "A loop lets you repeat code multiple times. A 'for' loop runs code for each item in a sequence.\n\nFor example, 'for (int i = 0; i < 3; i++)' means: start at 0, keep going while i is less than 3, and add 1 to i each time. So it runs 3 times: when i is 0, 1, and 2.",
      "example": "for (int i = 0; i < 3; i++) {\n    System.out.println(i);\n}\n\nThis prints: 0, 1, 2",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Perfect! Let's implement the top K frequent elements solution in Java. We'll create a method that takes an array and K, then returns the K most frequent elements.",
      "example": "public int[] topKFrequent(int[] nums, int k) {\n    \n}",
      "action": "continue",
      "next": "coding-count-freq-java"
    },
    {
      "stepId": "coding-count-freq-java",
      "mentorSays": "First, let's count the frequency of each element using a HashMap.",
      "example": "public int[] topKFrequent(int[] nums, int k) {\n    // Count frequencies\n    Map<Integer, Integer> freq = new HashMap<>();\n    for (int num : nums) {\n        freq.put(num, freq.getOrDefault(num, 0) + 1);\n    }\n    // freq = {1: 3, 2: 2, 3: 1} for [1, 1, 1, 2, 2, 3]\n}",
      "action": "continue",
      "next": "coding-heap-operations-java"
    },
    {
      "stepId": "coding-heap-operations-java",
      "mentorSays": "Let's use a min-heap to efficiently find the top K frequent elements!\n\nWe maintain a min-heap of size K. For each element, if its frequency is greater than the minimum in the heap, we replace it. This keeps the K most frequent elements in the heap.",
      "example": "function topKFrequent(nums, k) {\n  let count = {};\n  for (let num of nums) {\n    count[num] = (count[num] || 0) + 1;\n  }\n  \n  // Use min-heap to keep top K\n  let heap = [];\n  for (let [num, freq] of Object.entries(count)) {\n    if (heap.length < k) {\n      heap.push([freq, num]);\n    } else if (freq > heap[0][0]) {\n      heap[0] = [freq, num];\n      // Re-heapify\n    }\n  }\n  \n  return heap.map(item => item[1]);\n}",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "coding-extract-result-java",
      "mentorSays": "Finally, let's extract the top K elements from our heap!\n\nAfter building the heap with the K most frequent elements, we need to extract them. Since we stored [frequency, number] pairs, we extract just the numbers.",
      "example": "function topKFrequent(nums, k) {\n  let count = {};\n  for (let num of nums) {\n    count[num] = (count[num] || 0) + 1;\n  }\n  \n  // Use min-heap to keep top K\n  let heap = [];\n  for (let [num, freq] of Object.entries(count)) {\n    if (heap.length < k) {\n      heap.push([freq, num]);\n    } else if (freq > heap[0][0]) {\n      heap[0] = [freq, num];\n      // Re-heapify\n    }\n  }\n  \n  // Extract the numbers from heap\n  return heap.map(item => parseInt(item[1]));\n}",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "coding-sort-java",
      "mentorSays": "Now, let's convert the map entries to a list, sort by frequency (descending), and take the first K elements.",
      "example": "public int[] topKFrequent(int[] nums, int k) {\n    Map<Integer, Integer> freq = new HashMap<>();\n    for (int num : nums) {\n        freq.put(num, freq.getOrDefault(num, 0) + 1);\n    }\n    \n    // Convert to list and sort by frequency (descending)\n    List<Map.Entry<Integer, Integer>> entries = new ArrayList<>(freq.entrySet());\n    entries.sort((a, b) -> b.getValue() - a.getValue());\n    \n    // Take first K elements and return just the keys\n    int[] result = new int[k];\n    for (int i = 0; i < k; i++) {\n        result[i] = entries.get(i).getKey();\n    }\n    return result;\n}",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nnums = [1, 1, 1, 2, 2, 3]\nK = 2\n\nExpected output: [1, 2]\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nnums = [1, 1, 1, 2, 2, 3]\nK = 2\n\nExpected output: [1, 2]\n\nBecause 1 appears 3 times (most frequent) and 2 appears 2 times (second most frequent).",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in C++?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-cpp"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'freq' or 'count') and put data inside it.\n\nFor example, 'unordered_map<int, int> freq;' creates a variable that stores a hash map. Later, you can use that variable name to refer to it.",
      "example": "unordered_map<int, int> freq;\n\nNow the variable refers to an empty hash map\nWe can use the variable name to access this hash map",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in C++?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-cpp"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the function does the work, and gives you a result (return value).",
      "example": "int add(int a, int b) {\n    return a + b;\n}\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-cpp"
    },
    {
      "stepId": "parameter-check-cpp",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "loop-check-cpp"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-cpp",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'vector<int> topKFrequent(vector<int>& nums, int k)', the 'nums' and 'k' are parameters - they're placeholders that will receive actual values when you call the function.\n\nWhen you call 'topKFrequent({1, 1, 1, 2, 2, 3}, 2)', the vector goes into 'nums' and 2 goes into 'k'.",
      "example": "vector<int> topKFrequent(vector<int>& nums, int k) {\n  // 'nums' and 'k' are parameters\n}\n\n// When we call it:\ntopKFrequent({1, 1, 1, 2, 2, 3}, 2);\n// The vector goes into 'nums', 2 goes into 'k'",
      "action": "continue",
      "next": "loop-check-cpp"
    },
    {
      "stepId": "loop-check-cpp",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in C++?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "heap-check-cpp"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "heap-check-cpp",
      "mentorSays": "Do you understand how heaps/priority queues work?",
      "choices": [
        {
          "label": "Yes, I know heap",
          "next": "coding-start-cpp"
        },
        {
          "label": "No, explain heap",
          "next": "heap-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "heap-explanation-cpp",
      "mentorSays": "A heap is a tree-based data structure where the parent is always greater (max-heap) or smaller (min-heap) than its children. For top K elements, we use a min-heap of size K to keep track of the K most frequent elements.\n\n// Min-heap keeps K largest elements\nlet heap = [];\n\nfor (let [num, freq] of Object.entries(count)) {\n  if (heap.length < k) {\n    heap.push([freq, num]);\n  } else if (freq > heap[0][0]) {\n    heap[0] = [freq, num];\n    heapifyDown(heap);\n  }\n}\n\nGot it?",
      "example": "// Min-heap keeps K largest elements\nlet heap = [];\n\nfor (let [num, freq] of Object.entries(count)) {\n  if (heap.length < k) {\n    heap.push([freq, num]);\n  } else if (freq > heap[0][0]) {\n    heap[0] = [freq, num];\n    heapifyDown(heap);\n  }\n}",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "loop-explanation-cpp",
      "mentorSays": "A loop lets you repeat code multiple times. A 'for' loop runs code for each item in a sequence.\n\nFor example, 'for (int i = 0; i < 3; i++)' means: start at 0, keep going while i is less than 3, and add 1 to i each time. So it runs 3 times: when i is 0, 1, and 2.",
      "example": "for (int i = 0; i < 3; i++) {\n    cout << i << endl;\n}\n\nThis prints: 0, 1, 2",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Perfect! Let's implement the top K frequent elements solution in C++. We'll create a function that takes a vector and K, then returns the K most frequent elements.",
      "example": "vector<int> topKFrequent(vector<int>& nums, int k) {\n    \n}",
      "action": "continue",
      "next": "coding-count-freq-cpp"
    },
    {
      "stepId": "coding-count-freq-cpp",
      "mentorSays": "First, let's count the frequency of each element using an unordered_map.",
      "example": "vector<int> topKFrequent(vector<int>& nums, int k) {\n    // Count frequencies\n    unordered_map<int, int> freq;\n    for (int num : nums) {\n        freq[num]++;\n    }\n    // freq = {1: 3, 2: 2, 3: 1} for [1, 1, 1, 2, 2, 3]\n}",
      "action": "continue",
      "next": "coding-heap-operations-cpp"
    },
    {
      "stepId": "coding-heap-operations-cpp",
      "mentorSays": "Let's use a min-heap to efficiently find the top K frequent elements!\n\nWe maintain a min-heap of size K. For each element, if its frequency is greater than the minimum in the heap, we replace it. This keeps the K most frequent elements in the heap.",
      "example": "function topKFrequent(nums, k) {\n  let count = {};\n  for (let num of nums) {\n    count[num] = (count[num] || 0) + 1;\n  }\n  \n  // Use min-heap to keep top K\n  let heap = [];\n  for (let [num, freq] of Object.entries(count)) {\n    if (heap.length < k) {\n      heap.push([freq, num]);\n    } else if (freq > heap[0][0]) {\n      heap[0] = [freq, num];\n      // Re-heapify\n    }\n  }\n  \n  return heap.map(item => item[1]);\n}",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "coding-extract-result-cpp",
      "mentorSays": "Finally, let's extract the top K elements from our heap!\n\nAfter building the heap with the K most frequent elements, we need to extract them. Since we stored [frequency, number] pairs, we extract just the numbers.",
      "example": "function topKFrequent(nums, k) {\n  let count = {};\n  for (let num of nums) {\n    count[num] = (count[num] || 0) + 1;\n  }\n  \n  // Use min-heap to keep top K\n  let heap = [];\n  for (let [num, freq] of Object.entries(count)) {\n    if (heap.length < k) {\n      heap.push([freq, num]);\n    } else if (freq > heap[0][0]) {\n      heap[0] = [freq, num];\n      // Re-heapify\n    }\n  }\n  \n  // Extract the numbers from heap\n  return heap.map(item => parseInt(item[1]));\n}",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "coding-sort-cpp",
      "mentorSays": "Now, let's convert the map entries to a vector, sort by frequency (descending), and take the first K elements.",
      "example": "vector<int> topKFrequent(vector<int>& nums, int k) {\n    unordered_map<int, int> freq;\n    for (int num : nums) {\n        freq[num]++;\n    }\n    \n    // Convert to vector and sort by frequency (descending)\n    vector<pair<int, int>> pairs;\n    for (auto& p : freq) {\n        pairs.push_back({p.first, p.second});\n    }\n    sort(pairs.begin(), pairs.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second > b.second;\n    });\n    \n    // Take first K elements and return just the keys\n    vector<int> result;\n    for (int i = 0; i < k; i++) {\n        result.push_back(pairs[i].first);\n    }\n    return result;\n}",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nnums = [1, 1, 1, 2, 2, 3]\nK = 2\n\nExpected output: [1, 2]\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nnums = [1, 1, 1, 2, 2, 3]\nK = 2\n\nExpected output: [1, 2]\n\nBecause 1 appears 3 times (most frequent) and 2 appears 2 times (second most frequent).",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-ts"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-ts"
        }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'freq' or 'count') and put data inside it.\n\nFor example, 'let freq: {[key: number]: number} = {};' creates a variable that stores an object (hash map). Later, you can use that variable name to refer to it.",
      "example": "let freq: {[key: number]: number} = {};\n\nNow the variable refers to an empty object\nWe can use the variable name to access this object",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "parameter-check-ts"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-ts"
        }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.\n\nThink of it like a recipe: you provide ingredients (parameters), the function does the work, and gives you a result (return value).",
      "example": "function add(a: number, b: number): number {\n  return a + b;\n}\n\nadd(3, 5) returns 8\nadd(10, 20) returns 30",
      "action": "continue",
      "next": "parameter-check-ts"
    },
    {
      "stepId": "parameter-check-ts",
      "mentorSays": "When we write a function, we can give it inputs. These inputs are called 'parameters'. Do you know what parameters are?",
      "choices": [
        {
          "label": "Yes, I know parameters",
          "next": "loop-check-ts"
        },
        {
          "label": "No, explain parameters",
          "next": "parameter-explanation-ts"
        }
      ]
    },
    {
      "stepId": "parameter-explanation-ts",
      "mentorSays": "Parameters are like variables that receive values when you call the function. When you write 'function topKFrequent(nums: number[], k: number): number[]', the 'nums' and 'k' are parameters - they're placeholders that will receive actual values when you call the function.\n\nWhen you call 'topKFrequent([1, 1, 1, 2, 2, 3], 2)', the array goes into 'nums' and 2 goes into 'k'.",
      "example": "function topKFrequent(nums: number[], k: number): number[] {\n  // 'nums' and 'k' are parameters\n}\n\n// When we call it:\ntopKFrequent([1, 1, 1, 2, 2, 3], 2);\n// The array goes into 'nums', 2 goes into 'k'",
      "action": "continue",
      "next": "loop-check-ts"
    },
    {
      "stepId": "loop-check-ts",
      "mentorSays": "To solve this problem, we'll need to use loops. Do you know what a loop is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know loops",
          "next": "heap-check-ts"
        },
        {
          "label": "No, explain loops",
          "next": "loop-explanation-ts"
        }
      ]
    },
    {
      "stepId": "heap-check-ts",
      "mentorSays": "Do you understand how heaps/priority queues work?",
      "choices": [
        {
          "label": "Yes, I know heap",
          "next": "coding-start-ts"
        },
        {
          "label": "No, explain heap",
          "next": "heap-explanation-ts"
        }
      ]
    },
    {
      "stepId": "heap-explanation-ts",
      "mentorSays": "A heap is a tree-based data structure where the parent is always greater (max-heap) or smaller (min-heap) than its children. For top K elements, we use a min-heap of size K to keep track of the K most frequent elements.\n\n// Min-heap keeps K largest elements\nlet heap = [];\n\nfor (let [num, freq] of Object.entries(count)) {\n  if (heap.length < k) {\n    heap.push([freq, num]);\n  } else if (freq > heap[0][0]) {\n    heap[0] = [freq, num];\n    heapifyDown(heap);\n  }\n}\n\nGot it?",
      "example": "// Min-heap keeps K largest elements\nlet heap = [];\n\nfor (let [num, freq] of Object.entries(count)) {\n  if (heap.length < k) {\n    heap.push([freq, num]);\n  } else if (freq > heap[0][0]) {\n    heap[0] = [freq, num];\n    heapifyDown(heap);\n  }\n}",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "loop-explanation-ts",
      "mentorSays": "A loop lets you repeat code multiple times. A 'for' loop runs code for each item in a sequence.\n\nFor example, 'for (let i = 0; i < 3; i++)' means: start at 0, keep going while i is less than 3, and add 1 to i each time. So it runs 3 times: when i is 0, 1, and 2.",
      "example": "for (let i = 0; i < 3; i++) {\n  console.log(i);\n}\n\nThis prints: 0, 1, 2",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Perfect! Let's implement the top K frequent elements solution in TypeScript. We'll create a function that takes an array and K, then returns the K most frequent elements.",
      "example": "function topKFrequent(nums: number[], k: number): number[] {\n  \n}",
      "action": "continue",
      "next": "coding-count-freq-ts"
    },
    {
      "stepId": "coding-count-freq-ts",
      "mentorSays": "First, let's count the frequency of each element using an object (hash map in TypeScript).",
      "example": "function topKFrequent(nums: number[], k: number): number[] {\n  // Count frequencies\n  let freq: {[key: number]: number} = {};\n  for (let num of nums) {\n    freq[num] = (freq[num] || 0) + 1;\n  }\n  // freq = {1: 3, 2: 2, 3: 1} for [1, 1, 1, 2, 2, 3]\n}",
      "action": "continue",
      "next": "coding-convert-array-ts"
    },
    {
      "stepId": "coding-convert-array-ts",
      "mentorSays": "Now, let's convert the object entries to an array of [element, frequency] pairs so we can sort them.",
      "example": "function topKFrequent(nums: number[], k: number): number[] {\n  let freq: {[key: number]: number} = {};\n  for (let num of nums) {\n    freq[num] = (freq[num] || 0) + 1;\n  }\n  \n  // Convert to array of [element, frequency] pairs\n  let pairs: [number, number][] = Object.keys(freq).map(key => [parseInt(key), freq[parseInt(key)]]);\n  // pairs = [[1, 3], [2, 2], [3, 1]]\n}",
      "action": "continue",
      "next": "coding-sort-ts"
    },
    {
      "stepId": "coding-sort-ts",
      "mentorSays": "Now, let's sort the pairs by frequency in descending order (highest frequency first).",
      "example": "function topKFrequent(nums: number[], k: number): number[] {\n  let freq: {[key: number]: number} = {};\n  for (let num of nums) {\n    freq[num] = (freq[num] || 0) + 1;\n  }\n  \n  let pairs: [number, number][] = Object.keys(freq).map(key => [parseInt(key), freq[parseInt(key)]]);\n  \n  // Sort by frequency (descending)\n  pairs.sort((a, b) => b[1] - a[1]);\n  // pairs = [[1, 3], [2, 2], [3, 1]] (already sorted)\n}",
      "action": "continue",
      "next": "coding-heap-operations-ts"
    },
    {
      "stepId": "coding-heap-operations-ts",
      "mentorSays": "Let's use a min-heap to efficiently find the top K frequent elements!\n\nWe maintain a min-heap of size K. For each element, if its frequency is greater than the minimum in the heap, we replace it. This keeps the K most frequent elements in the heap.",
      "example": "function topKFrequent(nums, k) {\n  let count = {};\n  for (let num of nums) {\n    count[num] = (count[num] || 0) + 1;\n  }\n  \n  // Use min-heap to keep top K\n  let heap = [];\n  for (let [num, freq] of Object.entries(count)) {\n    if (heap.length < k) {\n      heap.push([freq, num]);\n    } else if (freq > heap[0][0]) {\n      heap[0] = [freq, num];\n      // Re-heapify\n    }\n  }\n  \n  return heap.map(item => item[1]);\n}",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "coding-extract-result-ts",
      "mentorSays": "Finally, let's extract the top K elements from our heap!\n\nAfter building the heap with the K most frequent elements, we need to extract them. Since we stored [frequency, number] pairs, we extract just the numbers.",
      "example": "function topKFrequent(nums, k) {\n  let count = {};\n  for (let num of nums) {\n    count[num] = (count[num] || 0) + 1;\n  }\n  \n  // Use min-heap to keep top K\n  let heap = [];\n  for (let [num, freq] of Object.entries(count)) {\n    if (heap.length < k) {\n      heap.push([freq, num]);\n    } else if (freq > heap[0][0]) {\n      heap[0] = [freq, num];\n      // Re-heapify\n    }\n  }\n  \n  // Extract the numbers from heap\n  return heap.map(item => parseInt(item[1]));\n}",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "coding-take-k-ts",
      "mentorSays": "Finally, let's take the first K elements and return just the element values (not the frequencies).",
      "example": "function topKFrequent(nums: number[], k: number): number[] {\n  let freq: {[key: number]: number} = {};\n  for (let num of nums) {\n    freq[num] = (freq[num] || 0) + 1;\n  }\n  \n  let pairs: [number, number][] = Object.keys(freq).map(key => [parseInt(key), freq[parseInt(key)]]);\n  pairs.sort((a, b) => b[1] - a[1]);\n  \n  // Take first K elements and return just the element values\n  return pairs.slice(0, k).map(pair => pair[0]);\n  // Returns [1, 2] for K = 2\n}",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nnums = [1, 1, 1, 2, 2, 3]\nK = 2\n\nExpected output: [1, 2]\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nnums = [1, 1, 1, 2, 2, 3]\nK = 2\n\nExpected output: [1, 2]\n\nBecause 1 appears 3 times (most frequent) and 2 appears 2 times (second most frequent).",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "language-selection-heap",
      "mentorSays": "Great! Now let's code the heap solution. Which programming language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "heap-note-js"
        },
        {
          "label": "Python",
          "next": "heap-note-python"
        },
        {
          "label": "Java",
          "next": "heap-note-java"
        },
        {
          "label": "C++",
          "next": "heap-note-cpp"
        },
        {
          "label": "TypeScript",
          "next": "heap-note-ts"
        }
      ]
    },
    {
      "stepId": "heap-note-js",
      "mentorSays": "Note: JavaScript doesn't have a built-in heap/priority queue. We'd need to implement one or use a library. For simplicity, let's stick with the hash map + sort approach, which is easier to understand and implement.\n\nWould you like to go back to the hash map + sort approach?",
      "choices": [
        {
          "label": "Yes, use hash map + sort",
          "next": "language-selection"
        },
        {
          "label": "I'll implement a heap myself",
          "next": "final"
        }
      ]
    },
    {
      "stepId": "heap-note-python",
      "mentorSays": "Python has a built-in heapq module! However, for learning purposes, the hash map + sort approach is clearer. Would you like to learn the hash map + sort approach first?",
      "choices": [
        {
          "label": "Yes, use hash map + sort",
          "next": "language-selection"
        },
        {
          "label": "No, I want to learn the heap approach",
          "next": "final"
        }
      ]
    },
    {
      "stepId": "heap-note-java",
      "mentorSays": "Java has PriorityQueue! However, for learning purposes, the hash map + sort approach is clearer. Would you like to learn the hash map + sort approach first?",
      "choices": [
        {
          "label": "Yes, use hash map + sort",
          "next": "language-selection"
        },
        {
          "label": "No, I want to learn the heap approach",
          "next": "final"
        }
      ]
    },
    {
      "stepId": "heap-note-cpp",
      "mentorSays": "C++ has priority_queue! However, for learning purposes, the hash map + sort approach is clearer. Would you like to learn the hash map + sort approach first?",
      "choices": [
        {
          "label": "Yes, use hash map + sort",
          "next": "language-selection"
        },
        {
          "label": "No, I want to learn the heap approach",
          "next": "final"
        }
      ]
    },
    {
      "stepId": "heap-note-ts",
      "mentorSays": "TypeScript doesn't have a built-in heap/priority queue. We'd need to implement one or use a library. For simplicity, let's stick with the hash map + sort approach, which is easier to understand and implement.\n\nWould you like to go back to the hash map + sort approach?",
      "choices": [
        {
          "label": "Yes, use hash map + sort",
          "next": "language-selection"
        },
        {
          "label": "I'll implement a heap myself",
          "next": "final"
        }
      ]
    },
    {
      "stepId": "final",
      "mentorSays": "ðŸŽ‰ Well done! You've learned to think through the Top K Frequent Elements problem. You understand what the problem asks for, how to count frequencies with hash maps, and how to find the K most frequent elements by sorting.\n\nThis kind of thinkingâ€”using hash maps to count frequencies and sorting to find top elementsâ€”is essential for solving many algorithm problems. Keep practicing!",
      "action": "continue"
    }
  ]
}